This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
_previous/
  ERRORS.txt
  midjargon.txt
  test_parameters.py
  test_workflow.py
.cursor/
  rules/
    midjargon.mdc
.devcontainer/
  devcontainer.json
.github/
  workflows/
    push.yml
    release.yml
  copilot-instructions.md
docs/
  midjourney-docs.md
  prompts_results.txt
  prompts_results2.txt
  prompts.sh
  prompts.txt
  refactoring-ideas.md
  specification.md
examples/
  basic_usage.py
src/
  midjargon/
    cli/
      __init__.py
      main.py
    core/
      __init__.py
      converter.py
      input.py
      main.py
      models.py
      parameters.py
      parser.py
      permutations.py
      type_defs.py
    engines/
      fal/
        __init__.py
        _fal.py
        converter.py
        fal.py
      midjourney/
        parser/
          __init__.py
          core.py
          exceptions.py
          parameters.py
          validation.py
        __init__.py
        constants.py
        midjourney.py
        models.py
        parser.py
      __init__.py
      base.py
    __init__.py
    __main__.py
tests/
  cli/
    test_main.py
  core/
    test_input.py
    test_parameters.py
    test_parser.py
  engines/
    midjourney/
      test_midjourney_parser.py
  integration/
    test_workflow.py
  conftest.py
  test_core.py
  test_package.py
.gitignore
.pre-commit-config.yaml
ERRORS.txt
LICENSE
LOG.md
midjargon.txt
package.toml
pyproject.toml
README.md
TODO.md
TODO2.md
VERSION.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_previous/ERRORS.txt">
cmd [1] | fd -e py -x pyupgrade --keep-runtime-typing --py310-plus
cmd [2] | ruff format .
32 files left unchanged
cmd [3] | ruff check --fix --unsafe-fixes .
src/midjargon/cli/main.py:39:33: FBT001 Boolean-typed positional argument in function definition
   |
37 |     """CLI interface for midjargon."""
38 |
39 |     def json(self, prompt: str, no_color: bool = False) -> None:
   |                                 ^^^^^^^^ FBT001
40 |         """Parse a prompt to MidjargonDict format.
   |

src/midjargon/cli/main.py:39:33: FBT002 Boolean default positional argument in function definition
   |
37 |     """CLI interface for midjargon."""
38 |
39 |     def json(self, prompt: str, no_color: bool = False) -> None:
   |                                 ^^^^^^^^ FBT002
40 |         """Parse a prompt to MidjargonDict format.
   |

src/midjargon/cli/main.py:54:28: FBT001 Boolean-typed positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT001
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:54:28: FBT002 Boolean default positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT002
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:54:55: FBT001 Boolean-typed positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT001
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:54:55: FBT002 Boolean default positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT002
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:92:28: FBT001 Boolean-typed positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT001
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:92:28: FBT002 Boolean default positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT002
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:92:55: FBT001 Boolean-typed positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT001
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:92:55: FBT002 Boolean default positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT002
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:124:28: FBT001 Boolean-typed positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                            ^^^^^^^^^^^ FBT001
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/cli/main.py:124:28: FBT002 Boolean default positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                            ^^^^^^^^^^^ FBT002
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/cli/main.py:124:55: FBT001 Boolean-typed positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                                                       ^^^^^^^^ FBT001
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/cli/main.py:124:55: FBT002 Boolean default positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                                                       ^^^^^^^^ FBT002
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/core/input.py:8:5: C901 `parse_weighted_prompt` is too complex (12 > 10)
  |
8 | def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
  |     ^^^^^^^^^^^^^^^^^^^^^ C901
9 |     """Parse a prompt with optional weights.
  |

src/midjargon/core/main.py:9:36: FBT001 Boolean-typed positional argument in function definition
   |
 8 | def format_json_output(
 9 |     variants: list[PromptVariant], include_parsed: bool = False
   |                                    ^^^^^^^^^^^^^^ FBT001
10 | ) -> dict[str, Any]:
11 |     """Format prompt variants as JSON output.
   |

src/midjargon/core/main.py:9:36: FBT002 Boolean default positional argument in function definition
   |
 8 | def format_json_output(
 9 |     variants: list[PromptVariant], include_parsed: bool = False
   |                                    ^^^^^^^^^^^^^^ FBT002
10 | ) -> dict[str, Any]:
11 |     """Format prompt variants as JSON output.
   |

src/midjargon/core/models.py:31:9: C901 `_missing_` is too complex (16 > 10)
   |
30 |     @classmethod
31 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ C901
32 |         """Handle missing values by trying to normalize the input."""
33 |         try:
   |

src/midjargon/core/models.py:31:9: PLR0911 Too many return statements (7 > 6)
   |
30 |     @classmethod
31 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ PLR0911
32 |         """Handle missing values by trying to normalize the input."""
33 |         try:
   |

src/midjargon/core/models.py:31:9: PLR0912 Too many branches (16 > 12)
   |
30 |     @classmethod
31 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ PLR0912
32 |         """Handle missing values by trying to normalize the input."""
33 |         try:
   |

src/midjargon/core/models.py:77:9: E722 Do not use bare `except`
   |
76 |             return None
77 |         except:
   |         ^^^^^^ E722
78 |             return None
   |

src/midjargon/core/models.py:140:9: E722 Do not use bare `except`
    |
138 |                 raise ValueError
139 |             return f"{w}:{h}"
140 |         except:
    |         ^^^^^^ E722
141 |             msg = "Invalid aspect ratio format. Expected W:H"
142 |             raise ValueError(msg)
    |

src/midjargon/core/models.py:142:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
140 |         except:
141 |             msg = "Invalid aspect ratio format. Expected W:H"
142 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
143 |
144 |     @field_validator("stylize")
    |

src/midjargon/core/models.py:216:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
214 |             except ValueError as e:
215 |                 msg = f"Invalid aspect ratio format: {e}"
216 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^ B904
217 |         return v
    |

src/midjargon/core/parameters.py:65:5: E722 Do not use bare `except`
   |
63 |         result = urlparse(value)
64 |         return all([result.scheme, result.netloc])
65 |     except:
   |     ^^^^^^ E722
66 |         return False
   |

src/midjargon/core/parameters.py:69:5: C901 `convert_parameter_value` is too complex (15 > 10)
   |
69 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ C901
70 |     """Convert a parameter value to the appropriate type."""
71 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:69:5: PLR0911 Too many return statements (10 > 6)
   |
69 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
70 |     """Convert a parameter value to the appropriate type."""
71 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:69:5: PLR0912 Too many branches (15 > 12)
   |
69 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
70 |     """Convert a parameter value to the appropriate type."""
71 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:89:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
87 |         except ValueError:
88 |             msg = f"Invalid version value: {value}"
89 |             raise ValueError(msg)
   |             ^^^^^^^^^^^^^^^^^^^^^ B904
90 |
91 |     # Handle integer parameters
   |

src/midjargon/core/parameters.py:97:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
95 |         except ValueError:
96 |             msg = f"Invalid integer value for {param}: {value}"
97 |             raise ValueError(msg)
   |             ^^^^^^^^^^^^^^^^^^^^^ B904
98 |
99 |     # Handle float parameters
   |

src/midjargon/core/parameters.py:114:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
112 |         except ValueError:
113 |             msg = f"Invalid numeric value for {param}: {value}"
114 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
115 |
116 |     # Handle style parameter
    |

src/midjargon/core/parameters.py:122:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
120 |         except ValueError:
121 |             msg = f"Invalid style value: {value}"
122 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
123 |
124 |     # Handle character and style references
    |

src/midjargon/core/parameters.py:139:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
137 |         except Exception:
138 |             msg = f"Invalid reference value for {param}: {value}"
139 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
140 |
141 |     # Default case: return as string
    |

src/midjargon/core/parameters.py:145:5: C901 `parse_parameters` is too complex (14 > 10)
    |
145 | def parse_parameters(param_str: str) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^ C901
146 |     """Parse parameters from a string into a dictionary."""
147 |     if not param_str:
    |

src/midjargon/core/parameters.py:145:5: PLR0912 Too many branches (18 > 12)
    |
145 | def parse_parameters(param_str: str) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^ PLR0912
146 |     """Parse parameters from a string into a dictionary."""
147 |     if not param_str:
    |

src/midjargon/core/parameters.py:155:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
153 |     except ValueError as e:
154 |         msg = f"Failed to parse parameters: {e}"
155 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
156 |
157 |     result: dict[str, Any] = {}
    |

src/midjargon/core/parameters.py:188:21: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
186 |                 except Exception as e:
187 |                     msg = f"Failed to parse parameter {current_param}: {e}"
188 |                     raise ValueError(msg)
    |                     ^^^^^^^^^^^^^^^^^^^^^ B904
189 |
190 |             # Start new parameter
    |

src/midjargon/core/parameters.py:221:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
219 |         except Exception as e:
220 |             msg = f"Failed to parse parameter {current_param}: {e}"
221 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
222 |
223 |     return result
    |

src/midjargon/core/parser.py:24:5: E722 Do not use bare `except`
   |
22 |             )
23 |         )
24 |     except:
   |     ^^^^^^ E722
25 |         return False
   |

src/midjargon/core/parser.py:60:5: C901 `parse_parameters` is too complex (12 > 10)
   |
60 | def parse_parameters(param_str: str) -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^ C901
61 |     """Parse parameter string into a dictionary.
   |

src/midjargon/core/parser.py:60:5: PLR0912 Too many branches (15 > 12)
   |
60 | def parse_parameters(param_str: str) -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^ PLR0912
61 |     """Parse parameter string into a dictionary.
   |

src/midjargon/core/parser.py:146:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
144 |         except Exception as e:
145 |             msg = f"Failed to parse parameters: {e!s}"
146 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
147 |     else:
148 |         text_part = remaining_text.strip()
    |

src/midjargon/core/parser.py:160:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
158 |     except Exception as e:
159 |         msg = f"Failed to create prompt object: {e!s}"
160 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
    |

src/midjargon/core/permutations.py:127:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
125 |     except Exception as e:
126 |         msg = f"Failed to parse options at position {start}: {e!s}"
127 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
128 |
129 |     if not options:
    |

src/midjargon/core/permutations.py:145:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
143 |         except Exception as e:
144 |             msg = f"Failed to expand option '{option}': {e!s}"
145 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
146 |
147 |     return results
    |

tests/core/test_parameters.py:134:5: PLR0915 Too many statements (58 > 50)
    |
134 | def test_parse_parameters():
    |     ^^^^^^^^^^^^^^^^^^^^^ PLR0915
135 |     """Test parse_parameters function to verify parameter parsing."""
136 |     param_str = "--ar 16:9 --stylize 100"
    |

Found 46 errors.
============================= test session starts ==============================
platform darwin -- Python 3.12.8, pytest-8.3.4, pluggy-1.5.0 -- /Users/adam/Library/Application Support/hatch/env/virtual/midjargon/XMQ91zt9/hatch-test.py3.12/bin/python3
cachedir: .pytest_cache
rootdir: /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/midjargon
configfile: pyproject.toml
plugins: rerunfailures-14.0, anyio-4.8.0, mock-3.14.0, xdist-3.6.1
collecting ... collected 92 items

tests/cli/test_main.py::test_basic_prompt FAILED                         [  1%]
tests/cli/test_main.py::test_permutations FAILED                         [  2%]
tests/cli/test_main.py::test_raw_output FAILED                           [  3%]
tests/cli/test_main.py::test_json_output_formatting FAILED               [  4%]
tests/cli/test_main.py::test_invalid_input FAILED                        [  5%]
tests/cli/test_main.py::test_parameter_validation FAILED                 [  6%]
tests/cli/test_main.py::test_image_url_handling FAILED                   [  7%]
tests/cli/test_main.py::test_no_color_output FAILED                      [  8%]
tests/cli/test_main.py::test_complex_prompt FAILED                       [  9%]
tests/cli/test_main.py::test_personalization_parameter FAILED            [ 10%]
tests/cli/test_main.py::test_numeric_range_permutations FAILED           [ 11%]
tests/cli/test_main.py::test_nested_parameter_permutations FAILED        [ 13%]
tests/cli/test_main.py::test_mj_command FAILED                           [ 14%]
tests/cli/test_main.py::test_fal_command FAILED                          [ 15%]
tests/cli/test_main.py::test_perm_command FAILED                         [ 16%]
tests/core/test_input.py::test_basic_input FAILED                        [ 17%]
tests/core/test_input.py::test_single_permutation FAILED                 [ 18%]
tests/core/test_input.py::test_empty_input FAILED                        [ 19%]
tests/core/test_input.py::test_multiple_permutations FAILED              [ 20%]
tests/core/test_input.py::test_nested_permutations FAILED                [ 21%]
tests/core/test_input.py::test_escaped_braces FAILED                     [ 22%]
tests/core/test_input.py::test_escaped_commas FAILED                     [ 23%]
tests/core/test_input.py::test_unmatched_braces FAILED                   [ 25%]
tests/core/test_input.py::test_empty_permutation FAILED                  [ 26%]
tests/core/test_input.py::test_whitespace_handling FAILED                [ 27%]
tests/core/test_input.py::test_expand_midjargon_input FAILED             [ 28%]
tests/core/test_input.py::test_handling_escaped_characters FAILED        [ 29%]
tests/core/test_parameters.py::test_basic_parameter_parsing FAILED       [ 30%]
tests/core/test_parameters.py::test_flag_parameters FAILED               [ 31%]
tests/core/test_parameters.py::test_parameter_with_multiple_values FAILED [ 32%]
tests/core/test_parameters.py::test_parameter_with_spaces FAILED         [ 33%]
tests/core/test_parameters.py::test_mixed_parameters FAILED              [ 34%]
tests/core/test_parameters.py::test_shorthand_parameters FAILED          [ 35%]
tests/core/test_parameters.py::test_niji_version_parameter FAILED        [ 36%]
tests/core/test_parameters.py::test_version_parameter FAILED             [ 38%]
tests/core/test_parameters.py::test_personalization_parameter FAILED     [ 39%]
tests/core/test_parameters.py::test_reference_parameters FAILED          [ 40%]
tests/core/test_parameters.py::test_parameter_order PASSED               [ 41%]
tests/core/test_parameters.py::test_invalid_parameters FAILED            [ 42%]
tests/core/test_parameters.py::test_parse_parameters FAILED              [ 43%]
tests/core/test_parameters.py::test_flag_parameters_handling FAILED      [ 44%]
tests/core/test_parameters.py::test_special_seed_values FAILED           [ 45%]
tests/core/test_parameters.py::test_reference_url_handling FAILED        [ 46%]
tests/core/test_parameters.py::test_niji_version_handling FAILED         [ 47%]
tests/core/test_parser.py::test_basic_prompt_parsing FAILED              [ 48%]
tests/core/test_parser.py::test_prompt_with_image_url FAILED             [ 50%]
tests/core/test_parser.py::test_prompt_with_multiple_image_urls FAILED   [ 51%]
tests/core/test_parser.py::test_prompt_with_parameters FAILED            [ 52%]
tests/core/test_parser.py::test_prompt_with_empty_parameters FAILED      [ 53%]
tests/core/test_parser.py::test_prompt_with_escaped_characters PASSED    [ 54%]
tests/core/test_parser.py::test_prompt_with_nested_permutations PASSED   [ 55%]
tests/core/test_parser.py::test_prompt_with_unmatched_braces PASSED      [ 56%]
tests/core/test_parser.py::test_prompt_with_empty_permutation PASSED     [ 57%]
tests/core/test_parser.py::test_prompt_with_whitespace_handling PASSED   [ 58%]
tests/engines/midjourney/test_midjourney_parser.py::test_numeric_parameters PASSED [ 59%]
tests/engines/midjourney/test_midjourney_parser.py::test_style_parameters PASSED [ 60%]
tests/engines/midjourney/test_midjourney_parser.py::test_aspect_ratio FAILED [ 61%]
tests/engines/midjourney/test_midjourney_parser.py::test_image_prompts PASSED [ 63%]
tests/engines/midjourney/test_midjourney_parser.py::test_extra_parameters PASSED [ 64%]
tests/engines/midjourney/test_midjourney_parser.py::test_parameter_conversion PASSED [ 65%]
tests/engines/midjourney/test_midjourney_parser.py::test_invalid_values FAILED [ 66%]
tests/engines/midjourney/test_midjourney_parser.py::test_empty_values FAILED [ 67%]
tests/engines/midjourney/test_midjourney_parser.py::test_version_parameter PASSED [ 68%]
tests/engines/midjourney/test_midjourney_parser.py::test_multiple_permutations PASSED [ 69%]
tests/engines/midjourney/test_midjourney_parser.py::test_personalization_parameter PASSED [ 70%]
tests/engines/midjourney/test_midjourney_parser.py::test_edge_cases PASSED [ 71%]
tests/integration/test_workflow.py::test_basic_workflow FAILED           [ 72%]
tests/integration/test_workflow.py::test_permutation_workflow FAILED     [ 73%]
tests/integration/test_workflow.py::test_image_workflow FAILED           [ 75%]
tests/integration/test_workflow.py::test_parameter_workflow FAILED       [ 76%]
tests/integration/test_workflow.py::test_new_parameters_workflow FAILED  [ 77%]
tests/integration/test_workflow.py::test_weighted_prompts_workflow FAILED [ 78%]
tests/integration/test_workflow.py::test_error_workflow FAILED           [ 79%]
tests/integration/test_workflow.py::test_complex_workflow FAILED         [ 80%]
tests/integration/test_workflow.py::test_permutations_with_parameters FAILED [ 81%]
tests/integration/test_workflow.py::test_permutations_with_flag_parameters FAILED [ 82%]
tests/integration/test_workflow.py::test_permutations_with_complex_parameters FAILED [ 83%]
tests/integration/test_workflow.py::test_cli_mj_command FAILED           [ 84%]
tests/integration/test_workflow.py::test_cli_fal_command FAILED          [ 85%]
tests/integration/test_workflow.py::test_cli_perm_command FAILED         [ 86%]
tests/test_core.py::test_basic_prompt_parsing PASSED                     [ 88%]
tests/test_core.py::test_prompt_with_parameters FAILED                   [ 89%]
tests/test_core.py::test_prompt_with_image PASSED                        [ 90%]
tests/test_core.py::test_invalid_parameters FAILED                       [ 91%]
tests/test_core.py::test_permutation_expansion PASSED                    [ 92%]
tests/test_core.py::test_escaped_permutations PASSED                     [ 93%]
tests/test_core.py::test_weighted_prompts FAILED                         [ 94%]
tests/test_core.py::test_combined_features FAILED                        [ 95%]
tests/test_core.py::test_style_reference PASSED                          [ 96%]
tests/test_core.py::test_character_reference FAILED                      [ 97%]
tests/test_core.py::test_prompt_to_string FAILED                         [ 98%]
tests/test_package.py::test_version PASSED                               [100%]

=================================== FAILURES ===================================
______________________________ test_basic_prompt _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10ef93ec0>

    def test_basic_prompt(cli):
        """Test basic prompt processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT}",
                json_output=True,
            )
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:58: TypeError
______________________________ test_permutations _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10f3dfd70>

    def test_permutations(cli):
        """Test permutation processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10fa4c100>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_raw_output ________________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fad9bb0>

    def test_raw_output(cli):
        """Test raw output mode."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"a photo --stylize {STYLIZE_VALUE}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:86: TypeError
_________________________ test_json_output_formatting __________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fa3c1d0>

    def test_json_output_formatting(cli):
        """Test JSON output formatting."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:98: TypeError
______________________________ test_invalid_input ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fa3c8f0>

    def test_invalid_input(cli):
        """Test handling of invalid input."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:110: TypeError
__________________________ test_parameter_validation ___________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fa3cfb0>

    def test_parameter_validation(cli):
        """Test parameter validation."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a photo --stylize {STYLIZE_VALUE * 20}", json_output=True
            )  # Over max
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:120: TypeError
___________________________ test_image_url_handling ____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fa3d790>

    def test_image_url_handling(cli):
        """Test handling of image URLs."""
        url = "https://example.com/image.jpg"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"{url} a fusion", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:133: TypeError
_____________________________ test_no_color_output _____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fa3e000>

    def test_no_color_output(cli):
        """Test no-color output mode."""
        Console(force_terminal=False)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True, no_color=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:147: TypeError
_____________________________ test_complex_prompt ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fa3e930>

    def test_complex_prompt(cli):
        """Test complex prompt with multiple features."""
        prompt = (
            "https://example.com/img1.jpg https://example.com/img2.jpg "
            "a {red, blue} bird on a {branch, rock} "
            f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
        )
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(prompt, json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:163: TypeError
________________________ test_personalization_parameter ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fa3f380>

    def test_personalization_parameter(cli):
        """Test personalization parameter handling in different forms."""
        # Test flag form (--p)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --p", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:180: TypeError
_______________________ test_numeric_range_permutations ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10f9f6f00>

    def test_numeric_range_permutations(cli):
        """Test handling of numeric parameters in permutations."""
        # Test stylize parameter range
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:210: TypeError
______________________ test_nested_parameter_permutations ______________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fadab70>

    def test_nested_parameter_permutations(cli):
        """Test handling of nested permutations with parameters."""
        # Test personalization with nested options
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("smooth edges {, --p {, CODE1}} --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:237: TypeError
_______________________________ test_mj_command ________________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10fadb2f0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
>               mj_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x10fadb4a0>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/midjourney/midjourney.py:46: TypeError

During handling of the above exception, another exception occurred:

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fadb2f0>

    def test_mj_command(cli):
        """Test Midjourney prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.mj("a serene landscape --ar 16:9 --stylize 100", json_output=True)

tests/cli/test_main.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10fadb2f0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
                mj_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(mj_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    params = " ".join(
                        f"--{k} {v}"
                        for k, v in result.items()
                        if k not in {"text", "image_prompts", "extra_params"}
                        and v is not None
                    )
                    console.print(
                        f"{result['text']} {params}",
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:89: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword 
argument 'extra_params'
_______________________________ test_fal_command _______________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10fa3d2b0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x10fa3d940>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fa3d2b0>

    def test_fal_command(cli):
        """Test Fal.ai prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal("a serene landscape --ar 16:9 --stylize 100", json_output=True)

tests/cli/test_main.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10fa3d2b0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
______________________________ test_perm_command _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10fa3d190>

    def test_perm_command(cli):
        """Test permutation expansion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird on a {branch, rock}", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10fa4c040>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_basic_input _______________________________

    def test_basic_input():
        """Test basic input without permutations."""
        result = expand_midjargon_input("a simple prompt")
        assert len(result) == 1
>       assert result[0] == "a simple prompt"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a simple prompt', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == 'a simple prompt'

tests/core/test_input.py:15: AssertionError
___________________________ test_single_permutation ____________________________

    def test_single_permutation():
        """Test input with a single permutation."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:22: AssertionError
_______________________________ test_empty_input _______________________________

    def test_empty_input():
        """Test empty input handling."""
        result = expand_midjargon_input("")
        assert len(result) == 1
>       assert result[0] == ""
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == ''

tests/core/test_input.py:30: AssertionError
__________________________ test_multiple_permutations __________________________

    def test_multiple_permutations():
        """Test input with multiple permutations."""
        result = expand_midjargon_input("a {red, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_3
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a green bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:37: AssertionError
___________________________ test_nested_permutations ___________________________

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
>               results.extend(expand_permutations(new_s))

src/midjargon/core/permutations.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a red {cat'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 6

src/midjargon/core/permutations.py:119: ValueError

During handling of the above exception, another exception occurred:

    def test_nested_permutations():
        """Test input with nested permutations."""
>       result = expand_midjargon_input("a {red {cat, dog}, blue bird}")

tests/core/test_input.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:84: in expand_midjargon_input
    permutation_options = expand_permutations(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
                results.extend(expand_permutations(new_s))
            except Exception as e:
                msg = f"Failed to expand option '{option}': {e!s}"
>               raise ValueError(msg)
E               ValueError: Failed to expand option 'red {cat': Unclosed brace at position 6

src/midjargon/core/permutations.py:145: ValueError
_____________________________ test_escaped_braces ______________________________

    def test_escaped_braces():
        """Test input with escaped braces."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:55: AssertionError
_____________________________ test_escaped_commas ______________________________

    def test_escaped_commas():
        """Test input with escaped commas."""
        result = expand_midjargon_input(r"a {red\, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red, blue bird" in result
E       AssertionError: assert 'a red, blue bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red, blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a green bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:62: AssertionError
____________________________ test_unmatched_braces _____________________________

    def test_unmatched_braces():
        """Test input with unmatched braces."""
>       result = expand_midjargon_input("a {red, blue bird")

tests/core/test_input.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:84: in expand_midjargon_input
    permutation_options = expand_permutations(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red, blue bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 2

src/midjargon/core/permutations.py:119: ValueError
____________________________ test_empty_permutation ____________________________

    def test_empty_permutation():
        """Test input with empty permutation options."""
>       result = expand_midjargon_input("a {} bird")

tests/core/test_input.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:84: in expand_midjargon_input
    permutation_options = expand_permutations(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {} bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
>           raise ValueError(msg)
E           ValueError: Empty permutation group at position 2

src/midjargon/core/permutations.py:131: ValueError
___________________________ test_whitespace_handling ___________________________

    def test_whitespace_handling():
        """Test input with various whitespace patterns."""
        result = expand_midjargon_input("a {  red  ,  blue  } bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:84: AssertionError
_________________________ test_expand_midjargon_input __________________________

    def test_expand_midjargon_input():
        """Test expand_midjargon_input function to verify prompt expansion."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == 2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:92: AssertionError
_______________________ test_handling_escaped_characters _______________________

    def test_handling_escaped_characters():
        """Test handling of escaped characters in expand_midjargon_input."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:112: AssertionError
_________________________ test_basic_parameter_parsing _________________________

    def test_basic_parameter_parsing():
        """Test parsing of basic parameters."""
        param_str = "--ar 16:9 --stylize 100"
        params = parse_parameters(param_str)
        assert params["aspect"] == "16:9"
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:14: AssertionError
_____________________________ test_flag_parameters _____________________________

    def test_flag_parameters():
        """Test parsing of flag parameters (without values)."""
        param_str = "--tile --turbo --relax"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:21: AssertionError
_____________________ test_parameter_with_multiple_values ______________________

    def test_parameter_with_multiple_values():
        """Test parsing parameters that accept multiple values."""
        param_str = "--no blur,cars,watermark"
        params = parse_parameters(param_str)
>       assert params["no"] == "blur,cars,watermark"
E       AssertionError: assert ['blur,cars,watermark'] == 'blur,cars,watermark'

tests/core/test_parameters.py:30: AssertionError
__________________________ test_parameter_with_spaces __________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
>                           value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )

src/midjargon/core/parameters.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:122: ValueError

During handling of the above exception, another exception occurred:

    def test_parameter_with_spaces():
        """Test parsing parameters with values containing spaces."""
        param_str = '--style "raw photo" --seed 123456'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
>                       raise ValueError(msg)
E                       ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:188: ValueError
____________________________ test_mixed_parameters _____________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
>                   value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )

src/midjargon/core/parameters.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:122: ValueError

During handling of the above exception, another exception occurred:

    def test_mixed_parameters():
        """Test parsing a mix of different parameter types."""
        param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
                    value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )
                    result[current_param] = value
            except Exception as e:
                msg = f"Failed to parse parameter {current_param}: {e}"
>               raise ValueError(msg)
E               ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:221: ValueError
__________________________ test_shorthand_parameters ___________________________

    def test_shorthand_parameters():
        """Test parsing of shorthand parameter names."""
        param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
        params = parse_parameters(param_str)
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:55: AssertionError
_________________________ test_niji_version_parameter __________________________

    def test_niji_version_parameter():
        """Test parsing of niji version parameter."""
        # Test basic niji
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:66: AssertionError
____________________________ test_version_parameter ____________________________

    def test_version_parameter():
        """Test parsing of version parameter."""
        # Test v parameter
        params = parse_parameters("--v 5.2")
>       assert params["version"] == "5.2"
E       AssertionError: assert <MidjourneyVe....V5_2: 'v5.2'> == '5.2'
E         
E         - 5.2
E         + v5.2
E         ? +

tests/core/test_parameters.py:77: AssertionError
________________________ test_personalization_parameter ________________________

    def test_personalization_parameter():
        """Test parsing of personalization parameter."""
        # Test basic p parameter
        params = parse_parameters("--p")
>       assert params["personalization"] is None  # Flag without value is None
E       assert True is None

tests/core/test_parameters.py:84: AssertionError
__________________________ test_reference_parameters ___________________________

    def test_reference_parameters():
        """Test parsing of reference parameters."""
        param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
        params = parse_parameters(param_str)
>       assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
E       AssertionError: assert [CharacterRef...e='img2.jpg')] == ['img1.jpg', 'img2.jpg']
E         
E         At index 0 diff: CharacterReference(url=HttpUrl('https://example.com/img1.jpg'), weight=1.0, code='img1.jpg') != 'img1.jpg'
E         
E         Full diff:
E           [
E         -     'img1.jpg',
E         -     'img2.jpg',...
E         
E         ...Full output truncated (3 lines hidden), use '-vv' to show

tests/core/test_parameters.py:107: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameter formats."""
>       with pytest.raises(ValueError, match="Empty parameter name"):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/core/test_parameters.py:121: Failed
____________________________ test_parse_parameters _____________________________

    def test_parse_parameters():
        """Test parse_parameters function to verify parameter parsing."""
        param_str = "--ar 16:9 --stylize 100"
        params = parse_parameters(param_str)
        assert params["aspect"] == "16:9"
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:139: AssertionError
________________________ test_flag_parameters_handling _________________________

    def test_flag_parameters_handling():
        """Test handling of flag parameters in parse_parameters."""
        param_str = "--tile --turbo --relax --video --remix"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:216: AssertionError
___________________________ test_special_seed_values ___________________________

param = 'seed', value = 'random'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
>               return int(value)
E               ValueError: invalid literal for int() with base 10: 'random'

src/midjargon/core/parameters.py:94: ValueError

During handling of the above exception, another exception occurred:

param_str = '--seed random'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
>                   value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )

src/midjargon/core/parameters.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'seed', value = 'random'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid integer value for seed: random

src/midjargon/core/parameters.py:97: ValueError

During handling of the above exception, another exception occurred:

    def test_special_seed_values():
        """Test handling of special seed values."""
        # Test random seed
>       params = parse_parameters("--seed random")

tests/core/test_parameters.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--seed random'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
                    value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )
                    result[current_param] = value
            except Exception as e:
                msg = f"Failed to parse parameter {current_param}: {e}"
>               raise ValueError(msg)
E               ValueError: Failed to parse parameter seed: Invalid integer value for seed: random

src/midjargon/core/parameters.py:221: ValueError
_________________________ test_reference_url_handling __________________________

    def test_reference_url_handling():
        """Test handling of URLs in reference parameters."""
        # Test character reference with quoted URL containing spaces
        params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
>       assert params["character_reference"] == [
            "https://example.com/image with spaces.jpg"
        ]
E       AssertionError: assert [CharacterRef...0, code=None)] == ['https://exa...h spaces.jpg']
E         
E         At index 0 diff: CharacterReference(url=HttpUrl('https://example.com/image%20with%20spaces.jpg'), weight=1.0, code=None) != 'https://example.com/image with spaces.jpg'
E         
E         Full diff:
E           [
E         -     'https://example.com/image with spaces.jpg',
E         +     CharacterReference(url=HttpUrl('https://example.com/image%20with%20spaces.jpg'), weight=1.0, code=None),
E           ]

tests/core/test_parameters.py:250: AssertionError
__________________________ test_niji_version_handling __________________________

    def test_niji_version_handling():
        """Test handling of niji version parameter."""
        # Test basic niji flag
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:271: AssertionError
__________________________ test_basic_prompt_parsing ___________________________

    def test_basic_prompt_parsing():
        """Test basic prompt parsing."""
        prompt = "a beautiful landscape --ar 16:9 --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a beautiful landscape"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:18: KeyError
__________________________ test_prompt_with_image_url __________________________

    def test_prompt_with_image_url():
        """Test prompt parsing with image URL."""
        prompt = f"{IMAGE_URL} a mystical forest --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a mystical forest"
>       assert result["images"] == [IMAGE_URL]
E       AssertionError: assert [HttpUrl('htt...m/image.jpg')] == ['https://exa...om/image.jpg']
E         
E         At index 0 diff: HttpUrl('https://example.com/image.jpg') != 'https://example.com/image.jpg'
E         
E         Full diff:
E           [
E         -     'https://example.com/image.jpg',
E         +     HttpUrl('https://example.com/image.jpg'),
E         ?     ++++++++                               +
E           ]

tests/core/test_parser.py:27: AssertionError
_____________________ test_prompt_with_multiple_image_urls _____________________

    def test_prompt_with_multiple_image_urls():
        """Test prompt parsing with multiple image URLs."""
        image_urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
        prompt = f"{image_urls[0]} {image_urls[1]} a serene landscape --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a serene landscape"
>       assert result["images"] == image_urls
E       AssertionError: assert [HttpUrl('htt.../image2.jpg')] == ['https://exa...m/image2.jpg']
E         
E         At index 0 diff: HttpUrl('https://example.com/image1.jpg') != 'https://example.com/image1.jpg'
E         
E         Full diff:
E           [
E         -     'https://example.com/image1.jpg',
E         +     HttpUrl('https://example.com/image1.jpg'),...
E         
E         ...Full output truncated (5 lines hidden), use '-vv' to show

tests/core/test_parser.py:40: AssertionError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a futuristic city --ar 16:9 --stylize 100 --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a futuristic city"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:49: KeyError
______________________ test_prompt_with_empty_parameters _______________________

    def test_prompt_with_empty_parameters():
        """Test prompt parsing with empty parameters."""
        prompt = "a landscape photo --tile --no blur,cars"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a landscape photo"
>       assert result["tile"] is None
E       assert True is None

tests/core/test_parser.py:59: AssertionError
______________________________ test_aspect_ratio _______________________________

    def test_aspect_ratio():
        """Test parsing of aspect ratio."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict({"text": "a photo", "ar": "16:9"})
    
        assert prompt.text == "a photo"
>       assert prompt.aspect_width == 16
E       AssertionError: assert None == 16
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={'ar': '16:9'}, images=[]).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:61: AssertionError
_____________________________ test_invalid_values ______________________________

    def test_invalid_values():
        """Test handling of invalid parameter values."""
        parser = MidjourneyParser()
    
        # Invalid aspect ratio - now accepts any value
        result = parser.parse_dict({"text": "a photo", "ar": "999:999"})
>       assert result.aspect_width == 999
E       AssertionError: assert None == 999
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={'ar': '999:999'}, images=[]).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:120: AssertionError
______________________________ test_empty_values _______________________________

    def test_empty_values():
        """Test handling of empty values."""
        parser = MidjourneyParser()
    
        # Empty text
        with pytest.raises(ValueError, match="Empty prompt"):
            parser.parse_dict({"text": ""})
    
        # Empty image list
        prompt = parser.parse_dict({"text": "a photo", "image_prompts": []})
        assert prompt.text == "a photo"
        assert not prompt.image_prompts
    
        # None values
>       prompt = parser.parse_dict({"text": "a photo", "stylize": None})

tests/engines/midjourney/test_midjourney_parser.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x1100d7d10>
prompt_dict = {'stylize': None}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for MidjourneyPrompt
E       stylize
E         Input should be a valid number [type=float_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.10/v/float_type

src/midjargon/engines/midjourney/midjourney.py:46: ValidationError
_____________________________ test_basic_workflow ______________________________

prompt = 'a beautiful landscape --ar 16:9 --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_basic_workflow():
        """Test basic prompt workflow without permutations."""
        prompt = f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'a beautiful landscape --ar 16:9 --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
__________________________ test_permutation_workflow ___________________________

prompt = 'a red bird on a branch --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutation_workflow():
        """Test workflow with permutations."""
        prompt = f"a {{red, blue}} bird on a {{branch, rock}} --stylize {STYLIZE_VALUE}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'a red bird on a branch --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_____________________________ test_image_workflow ______________________________

prompt = 'https://example.com/image1.jpg https://example.com/image2.jpg abstract fusion --iw 2.0 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_image_workflow():
        """Test workflow with image URLs."""
        urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
        prompt = f"{' '.join(urls)} abstract fusion --iw {IMAGE_WEIGHT_VALUE}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'https://example.com/image1.jpg https://example.com/image2.jpg abstract fusion --iw 2.0 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
___________________________ test_parameter_workflow ____________________________

prompt = 'cyberpunk city --v 5.2 --style raw --chaos 50 --weird 1000 --seed 12345 --stop 80 --turbo --tile --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_parameter_workflow():
        """Test workflow with various parameter types."""
        prompt = (
            "cyberpunk city --v 5.2 --style raw "
            f"--chaos {CHAOS_VALUE} --weird {WEIRD_VALUE} "
            f"--seed {SEED_VALUE} --stop {STOP_VALUE} "
            "--turbo --tile"
        )
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'cyberpunk city --v 5.2 --style raw --chaos 50 --weird 1000 --seed 12345 --stop 80 --turbo --tile --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_________________________ test_new_parameters_workflow _________________________

prompt = 'portrait photo --quality 1.0 --cw 100 --sw 200 --sv 2 --repeat 3 --cref ref1.jpg ref2.jpg --sref style1.jpg style2.jp... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_new_parameters_workflow():
        """Test workflow with new parameter types."""
        prompt = (
            "portrait photo "
            f"--quality {QUALITY_VALUE} "
            f"--cw {CHARACTER_WEIGHT_VALUE} "
            f"--sw {STYLE_WEIGHT_VALUE} "
            f"--sv {STYLE_VERSION_VALUE} "
            f"--repeat {REPEAT_VALUE} "
            "--cref ref1.jpg ref2.jpg "
            "--sref style1.jpg style2.jpg "
            "--p custom_profile1 custom_profile2"
        )
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'portrait photo --quality 1.0 --cw 100 --sw 200 --sv 2 --repeat 3 --cref ref1.jpg ref2.jpg --sref style1.jpg style2.jp... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
________________________ test_weighted_prompts_workflow ________________________

prompt = 'cyberpunk city::2 neon lights::1 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_weighted_prompts_workflow():
        """Test workflow with weighted prompts."""
        prompt = "cyberpunk city::2 neon lights::1"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'cyberpunk city::2 neon lights::1 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_____________________________ test_error_workflow ______________________________

prompt = ' --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_error_workflow():
        """Test error handling in workflow."""
        # Test empty prompt
        with pytest.raises(ValueError, match="Empty prompt"):
>           process_prompt("")

tests/integration/test_workflow.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = ' --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError

During handling of the above exception, another exception occurred:

    def test_error_workflow():
        """Test error handling in workflow."""
        # Test empty prompt
>       with pytest.raises(ValueError, match="Empty prompt"):
E       AssertionError: Regex pattern did not match.
E        Regex: 'Empty prompt'
E        Input: "Failed to create prompt object: 2 validation errors for MidjourneyPrompt\ncharacter_reference\n  Input should be a valid list [type=list_type, input_value='[]', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/list_type\nstyle_reference\n  Input should be a valid list [type=list_type, input_value='[]', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/list_type"

tests/integration/test_workflow.py:164: AssertionError
____________________________ test_complex_workflow _____________________________

prompt = 'https://example.com/img1.jpg https://example.com/img2.jpg a vintage portrait with warm tones --ar 16:9 --stylize 100 ... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_complex_workflow():
        """Test workflow with multiple features combined."""
        prompt = (
            "https://example.com/img1.jpg https://example.com/img2.jpg "
            "a {vintage, modern} {portrait, landscape} "
            "with {warm, cool} tones "
            f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} "
            f"--chaos {CHAOS_VALUE} --v 5.2 --style raw "
            f"--quality {QUALITY_VALUE} --cw {CHARACTER_WEIGHT_VALUE} "
            "--turbo"
        )
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'https://example.com/img1.jpg https://example.com/img2.jpg a vintage portrait with warm tones --ar 16:9 --stylize 100 ... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
______________________ test_permutations_with_parameters _______________________

prompt = 'smooth edges  --s 75 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutations_with_parameters():
        """Test permutations with parameters are handled correctly."""
        prompt = "smooth edges {, --p} --s {75, 300}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'smooth edges  --s 75 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
____________________ test_permutations_with_flag_parameters ____________________

prompt = 'photo   --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutations_with_flag_parameters():
        """Test permutations with flag parameters (no value) are handled correctly."""
        prompt = "photo {, --tile} {, --turbo}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'photo   --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
__________________ test_permutations_with_complex_parameters ___________________

prompt = 'portrait modern  --ar 1:1 --s 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutations_with_complex_parameters():
        """Test permutations with complex parameter combinations."""
        prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'portrait modern  --ar 1:1 --s 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_____________________________ test_cli_mj_command ______________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x110076270>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
>               mj_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x110076fc0>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/midjourney/midjourney.py:46: TypeError

During handling of the above exception, another exception occurred:

    def test_cli_mj_command():
        """Test Midjourney prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.mj(prompt, json_output=True)

tests/integration/test_workflow.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x110076270>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
                mj_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(mj_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    params = " ".join(
                        f"--{k} {v}"
                        for k, v in result.items()
                        if k not in {"text", "image_prompts", "extra_params"}
                        and v is not None
                    )
                    console.print(
                        f"{result['text']} {params}",
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:89: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword 
argument 'extra_params'
_____________________________ test_cli_fal_command _____________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x110076d80>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x1100764e0>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

    def test_cli_fal_command():
        """Test Fal.ai prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal(prompt, json_output=True)

tests/integration/test_workflow.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x110076d80>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
____________________________ test_cli_perm_command _____________________________

    def test_cli_perm_command():
        """Test permutation expansion using CLI."""
        cli = MidjargonCLI()
        prompt = "a {red, blue} bird on a {branch, rock}"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm(prompt, json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/integration/test_workflow.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x11006c040>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
        result = parse_midjargon_prompt(prompt)
    
        assert result.text == "a portrait"
>       assert result.parameters.aspect == "16:9"
E       AssertionError: assert '1:1' == '16:9'
E         
E         - 16:9
E         + 1:1

tests/test_core.py:31: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameters."""
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_core.py:49: Failed
____________________________ test_weighted_prompts _____________________________

    def test_weighted_prompts():
        """Test handling of weighted prompts."""
        prompt = "first prompt::0.7 second prompt::0.3"
        results = expand_midjargon_input(prompt)
    
>       assert len(results) == 2
E       AssertionError: assert 1 == 2
E        +  where 1 = len([PromptVariant(prompt=MidjourneyPrompt(text='first prompt::0.7 second prompt::0.3', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)])

tests/test_core.py:80: AssertionError
____________________________ test_combined_features ____________________________

    def test_combined_features():
        """Test combination of multiple features."""
        prompt = "a {red, blue} bird::0.6 a {green, yellow} tree::0.4"
        results = expand_midjargon_input(prompt)
    
        assert len(results) == 4
        # Check first group
        red_blue = [r for r in results if "bird" in r.prompt.text]
>       assert len(red_blue) == 2
E       AssertionError: assert 4 == 2
E        +  where 4 = len([PromptVariant(prompt=MidjourneyPrompt(text='a red bird::0.6 a green tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a red bird::0.6 a yellow tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird::0.6 a green tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird::0.6 a yellow tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)])

tests/test_core.py:93: AssertionError
___________________________ test_character_reference ___________________________

    def test_character_reference():
        """Test handling of character references."""
        prompt = "test --cref https://example.com/char.jpg --cw 50"
        result = parse_midjargon_prompt(prompt)
    
        assert result.character_reference
        assert str(result.character_reference[0].url) == "https://example.com/char.jpg"
>       assert result.character_weight == 50
E       AssertionError: assert 100 == 50
E        +  where 100 = MidjourneyPrompt(text='test', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[CharacterReference(url=HttpUrl('https://example.com/char.jpg'), weight=1.0, code=None)], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]).character_weight

tests/test_core.py:126: AssertionError
____________________________ test_prompt_to_string _____________________________

prompt = 'a portrait --stylize 200 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_prompt_to_string():
        """Test conversion of prompt back to string format."""
        original = "a portrait --ar 16:9 --stylize 200"
        result = parse_midjargon_prompt(original)
    
        # Convert back to string
        output = result.to_string()
    
        # Parse again to verify equivalence
>       reparsed = parse_midjargon_prompt(output)

tests/test_core.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'a portrait --stylize 200 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
============================= slowest 10 durations =============================

(10 durations < 0.005s hidden.  Use -vv to show these durations.)
=========================== short test summary info ============================
FAILED tests/cli/test_main.py::test_basic_prompt - TypeError: MidjargonCLI.js...
FAILED tests/cli/test_main.py::test_permutations - ValueError: No JSON found ...
FAILED tests/cli/test_main.py::test_raw_output - TypeError: MidjargonCLI.json...
FAILED tests/cli/test_main.py::test_json_output_formatting - TypeError: Midja...
FAILED tests/cli/test_main.py::test_invalid_input - TypeError: MidjargonCLI.j...
FAILED tests/cli/test_main.py::test_parameter_validation - TypeError: Midjarg...
FAILED tests/cli/test_main.py::test_image_url_handling - TypeError: Midjargon...
FAILED tests/cli/test_main.py::test_no_color_output - TypeError: MidjargonCLI...
FAILED tests/cli/test_main.py::test_complex_prompt - TypeError: MidjargonCLI....
FAILED tests/cli/test_main.py::test_personalization_parameter - TypeError: Mi...
FAILED tests/cli/test_main.py::test_numeric_range_permutations - TypeError: M...
FAILED tests/cli/test_main.py::test_nested_parameter_permutations - TypeError...
FAILED tests/cli/test_main.py::test_mj_command - SystemExit: 1
FAILED tests/cli/test_main.py::test_fal_command - SystemExit: 1
FAILED tests/cli/test_main.py::test_perm_command - ValueError: No JSON found ...
FAILED tests/core/test_input.py::test_basic_input - AssertionError: assert Pr...
FAILED tests/core/test_input.py::test_single_permutation - AssertionError: as...
FAILED tests/core/test_input.py::test_empty_input - AssertionError: assert Pr...
FAILED tests/core/test_input.py::test_multiple_permutations - AssertionError:...
FAILED tests/core/test_input.py::test_nested_permutations - ValueError: Faile...
FAILED tests/core/test_input.py::test_escaped_braces - AssertionError: assert...
FAILED tests/core/test_input.py::test_escaped_commas - AssertionError: assert...
FAILED tests/core/test_input.py::test_unmatched_braces - ValueError: Unclosed...
FAILED tests/core/test_input.py::test_empty_permutation - ValueError: Empty p...
FAILED tests/core/test_input.py::test_whitespace_handling - AssertionError: a...
FAILED tests/core/test_input.py::test_expand_midjargon_input - AssertionError...
FAILED tests/core/test_input.py::test_handling_escaped_characters - Assertion...
FAILED tests/core/test_parameters.py::test_basic_parameter_parsing - Assertio...
FAILED tests/core/test_parameters.py::test_flag_parameters - assert True is None
FAILED tests/core/test_parameters.py::test_parameter_with_multiple_values - A...
FAILED tests/core/test_parameters.py::test_parameter_with_spaces - ValueError...
FAILED tests/core/test_parameters.py::test_mixed_parameters - ValueError: Fai...
FAILED tests/core/test_parameters.py::test_shorthand_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_niji_version_parameter - Assertion...
FAILED tests/core/test_parameters.py::test_version_parameter - AssertionError...
FAILED tests/core/test_parameters.py::test_personalization_parameter - assert...
FAILED tests/core/test_parameters.py::test_reference_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_invalid_parameters - Failed: DID N...
FAILED tests/core/test_parameters.py::test_parse_parameters - AssertionError:...
FAILED tests/core/test_parameters.py::test_flag_parameters_handling - assert ...
FAILED tests/core/test_parameters.py::test_special_seed_values - ValueError: ...
FAILED tests/core/test_parameters.py::test_reference_url_handling - Assertion...
FAILED tests/core/test_parameters.py::test_niji_version_handling - AssertionE...
FAILED tests/core/test_parser.py::test_basic_prompt_parsing - KeyError: 'aspect'
FAILED tests/core/test_parser.py::test_prompt_with_image_url - AssertionError...
FAILED tests/core/test_parser.py::test_prompt_with_multiple_image_urls - Asse...
FAILED tests/core/test_parser.py::test_prompt_with_parameters - KeyError: 'as...
FAILED tests/core/test_parser.py::test_prompt_with_empty_parameters - assert ...
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_aspect_ratio
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_invalid_values
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_empty_values
FAILED tests/integration/test_workflow.py::test_basic_workflow - ValueError: ...
FAILED tests/integration/test_workflow.py::test_permutation_workflow - ValueE...
FAILED tests/integration/test_workflow.py::test_image_workflow - ValueError: ...
FAILED tests/integration/test_workflow.py::test_parameter_workflow - ValueErr...
FAILED tests/integration/test_workflow.py::test_new_parameters_workflow - Val...
FAILED tests/integration/test_workflow.py::test_weighted_prompts_workflow - V...
FAILED tests/integration/test_workflow.py::test_error_workflow - AssertionErr...
FAILED tests/integration/test_workflow.py::test_complex_workflow - ValueError...
FAILED tests/integration/test_workflow.py::test_permutations_with_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_flag_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_complex_parameters
FAILED tests/integration/test_workflow.py::test_cli_mj_command - SystemExit: 1
FAILED tests/integration/test_workflow.py::test_cli_fal_command - SystemExit: 1
FAILED tests/integration/test_workflow.py::test_cli_perm_command - ValueError...
FAILED tests/test_core.py::test_prompt_with_parameters - AssertionError: asse...
FAILED tests/test_core.py::test_invalid_parameters - Failed: DID NOT RAISE <c...
FAILED tests/test_core.py::test_weighted_prompts - AssertionError: assert 1 == 2
FAILED tests/test_core.py::test_combined_features - AssertionError: assert 4 ...
FAILED tests/test_core.py::test_character_reference - AssertionError: assert ...
FAILED tests/test_core.py::test_prompt_to_string - ValueError: Failed to crea...
======================== 71 failed, 21 passed in 1.07s =========================
</file>

<file path="_previous/midjargon.txt">
# Folder Tree Structure

.
 ERRORS.txt
 LICENSE
 LOG.md
 README.md
 TODO.md
 dist
 docs
  specification.md
 examples
  basic_usage.py
 package.toml
 pyproject.toml
 src
  midjargon
      __init__.py
      cli
       __init__.py
       main.py
      core
       __init__.py
       input.py
       main.py
       models.py
       parameters.py
       parser.py
       permutations.py
      engines
          __init__.py
          fal
           __init__.py
           fal.py
          midjourney
              __init__.py
              midjourney.py
              parser.py
 test-cases
  prompts-fal.txt
  prompts-in.txt
  prompts-json.txt
  prompts-mj.txt
  prompts-out.txt
  prompts-perm.txt
  prompts.sh
 tests
  __init__.py
  cli
   __init__.py
   test_main.py
  conftest.py
  core
   __init__.py
   test_input.py
   test_parameters.py
   test_parser.py
  engines
   __init__.py
   midjourney
       __init__.py
       test_midjourney_parser.py
  integration
   __init__.py
   test_workflow.py
  test_core.py
  test_package.py
 updateme.sh

18 directories, 48 files



# Folder: .

## File: .cursor/rules/midjargon.mdc (Size: 3.53 KB)

```
---
description: "Midjargon configuration documentation for folder structure."
globs: []
---

Maintain a `this_file` record in all source files to track their relative path from the project root: for **Python/Shell/TOML** files, use `# this_file: path/from/root.ext` as the first comment (after any shebang line `#!`), and for **Markdown** files, include `this_file: path/from/root.md` in the YAML front matter block at the document start. Update paths when moving files. Keep the entry as the first metadata element. Use Unix-style `/` path separators. Omit leading `./` in paths. *Example:* A Python file in `src/utils` would start with `#!/usr/bin/env python3\n# this_file: src/utils/helpers.py`.

# `midjargon`

`midjargon` is a hatch-managed Python library for parsing and manipulating Midjourney prompts using a specialized syntax. This tool helps you work with Midjourney prompts in a structured way, handling complex features like permutations, parameter validation, and image URL extraction.

<guidelines for python>
1. WHEN YOU WRITE PYTHON: 

a. CORE STYLE: Follow PEP 8 for consistent formatting & naming. Write clear, descriptive names for functions & variables. Keep code simple & explicit (PEP 20). Prioritize readability over cleverness. 
b. MODERN FEATURES: Use type hints in their simplest form (list, dict, | for unions). Write clear, imperative docstrings (PEP 257). Employ f-strings for string formatting. Use structural pattern matching where appropriate. 
c. CODE STRUCTURE: Extract repeated logic into focused functions. Handle errors explicitly and gracefully. Keep functions small and single-purpose. Prefer flat over nested structures. 
d. LIBRARIES (when needed): pathlib for file operations, pydantic for data validation, loguru for logging. Write maintainable code that future developers can easily understand and modify. 
e. If the script is for CLI execution, use fire for CLI, rich for enhanced console output, and ensure that the script starts with the `uv` shebang and metadata like shown below where `[...]` is a list of Python dependency specifiers, like `["fire", "rich"]`: 

```
#!/usr/bin/env -S uv run 
# /// script
# dependencies = [...]
# ///
```

f. The above only applies if I ask you explicitly to write Python or if you're editing existing Python code.
</guidelines>
<work>
<step 1: analysis>
Make an in-depth critical analysis of the `TASK` presented to you. Read the content of the @TODO.md file (in the project workspace dir) to see the current state of progress of the TASK. Then make an in-depth critical analysis of the inputs presented. 
</step>
<step 2: gather up-to-date insights>
Consult the @Web if you can. Consult the most up-to-date @Docs and run `hatch fmt; hatch test`. 
</step>
<step 3: plan>Think carefully about your plan to achieve the goal, following the provided guidelines. Write out general principles, then propose specific changes. 
</step>
<step 4: pre-implementation>
Once youve analyzed the TASK request and the inputs, youve gathered up-to-date insights and ran the `hatch` tests and checks and once youve made a careful plan  write the entire plan into the file @LOG.md (in the project workspace folder)  be very detailed and specific. 
</step>
<step 5: implementation>
You can start implementing the plan. Whenever youve made larger edits to Python files, run `hatch fmt; hatch test` to see how your changes impacted the @Codebase , then refine your plan. Keep progress documentation in @LOG.md (in the project workspace folder) , remove completed items. Work until you CLEAR the @TODO.md !     
</step>
</work>
```

## File: .github/copilot-instructions.md (Size: 3.43 KB)

```

Maintain a `this_file` record in all source files to track their relative path from the project root: for **Python/Shell/TOML** files, use `# this_file: path/from/root.ext` as the first comment (after any shebang line `#!`), and for **Markdown** files, include `this_file: path/from/root.md` in the YAML front matter block at the document start. Update paths when moving files. Keep the entry as the first metadata element. Use Unix-style `/` path separators. Omit leading `./` in paths. *Example:* A Python file in `src/utils` would start with `#!/usr/bin/env python3\n# this_file: src/utils/helpers.py`.

# `midjargon`

`midjargon` is a hatch-managed Python library for parsing and manipulating Midjourney prompts using a specialized syntax. This tool helps you work with Midjourney prompts in a structured way, handling complex features like permutations, parameter validation, and image URL extraction.

<guidelines for python>
1. WHEN YOU WRITE PYTHON: 

a. CORE STYLE: Follow PEP 8 for consistent formatting & naming. Write clear, descriptive names for functions & variables. Keep code simple & explicit (PEP 20). Prioritize readability over cleverness. 
b. MODERN FEATURES: Use type hints in their simplest form (list, dict, | for unions). Write clear, imperative docstrings (PEP 257). Employ f-strings for string formatting. Use structural pattern matching where appropriate. 
c. CODE STRUCTURE: Extract repeated logic into focused functions. Handle errors explicitly and gracefully. Keep functions small and single-purpose. Prefer flat over nested structures. 
d. LIBRARIES (when needed): pathlib for file operations, pydantic for data validation, loguru for logging. Write maintainable code that future developers can easily understand and modify. 
e. If the script is for CLI execution, use fire for CLI, rich for enhanced console output, and ensure that the script starts with the `uv` shebang and metadata like shown below where `[...]` is a list of Python dependency specifiers, like `["fire", "rich"]`: 

```
#!/usr/bin/env -S uv run 
# /// script
# dependencies = [...]
# ///
```

f. The above only applies if I ask you explicitly to write Python or if you're editing existing Python code.
</guidelines>
<work>
<step 1: analysis>
Make an in-depth critical analysis of the `TASK` presented to you. Read the content of the @TODO.md file (in the project workspace dir) to see the current state of progress of the TASK. Then make an in-depth critical analysis of the inputs presented. 
</step>
<step 2: gather up-to-date insights>
Consult the @Web if you can. Consult the most up-to-date @Docs and run `hatch fmt; hatch test`. 
</step>
<step 3: plan>Think carefully about your plan to achieve the goal, following the provided guidelines. Write out general principles, then propose specific changes. 
</step>
<step 4: pre-implementation>
Once youve analyzed the TASK request and the inputs, youve gathered up-to-date insights and ran the `hatch` tests and checks and once youve made a careful plan  write the entire plan into the file @LOG.md (in the project workspace folder)  be very detailed and specific. 
</step>
<step 5: implementation>
You can start implementing the plan. Whenever youve made larger edits to Python files, run `hatch fmt; hatch test` to see how your changes impacted the @Codebase , then refine your plan. Keep progress documentation in @LOG.md (in the project workspace folder) , remove completed items. Work until you CLEAR the @TODO.md !     
</step>
</work>
```

## File: .github/workflows/push.yml (Size: 2.70 KB)

```
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/midjargon --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
```

## File: .github/workflows/release.yml (Size: 1.41 KB)

```
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/midjargon
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## File: .gitignore (Size: 3.42 KB)

```
!**/[Pp]ackages/build/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!?*.[Cc]ache/
!Directory.Build.rsp
!dist/.gitkeep
$tf/
*$py.class
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
**/[Pp]ackages/*
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim.layout
*.bim_*.settings
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.cover
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.egg
*.egg-info/
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.py,cover
*.py[cod]
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.swo
*.swp
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
*_autogen/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*~
.*crunch*.local.xml
._*
.axoCover/*
.builds
.cache
.coverage
.coverage.*
.cr/personal
.DS_Store
.DS_Store?
.eggs/
.env
.fake/
.history/
.hypothesis/
.idea/
.installed.cfg
.ionide/
.localhistory/
.mfractor/
.mypy_cache/
.nox/
.ntvs_analysis.dat
.paket/paket.exe
.pytest_cache/
.Python
.ruff_cache/
.sass-cache/
.Spotlight-V100
.tox/
.Trashes
.venv
.vs/
.vscode
.vscode/
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
__pycache__/
__version__.py
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
build/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
cover/
coverage*.info
coverage*.json
coverage*.xml
coverage.xml
csx/
CTestTestfile.cmake
develop-eggs/
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
downloads/
ecf/
eggs/
ehthumbs.db
env.bak/
env/
ENV/
FakesAssemblies/
FodyWeavers.xsd
Generated\ Files/
Generated_Code/
healthchecksdb
htmlcov/
install_manifest.txt
ipch/
lib/
lib64/
Makefile
MANIFEST
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nosetests.xml
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
parts/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
sdist/
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
Thumbs.db
UpgradeLog*.htm
UpgradeLog*.XML
var/
venv.bak/
venv/
wheels/
x64/
x86/
~$*
.aider*
/_private

_private
```

## File: .pre-commit-config.yaml (Size: 0.52 KB)

```
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
```

## File: ERRORS.txt (Size: 185.85 KB)

```
cmd [1] | fd -e py -x pyupgrade --keep-runtime-typing --py310-plus
cmd [2] | ruff format .
32 files left unchanged
cmd [3] | ruff check --fix --unsafe-fixes .
src/midjargon/cli/main.py:39:33: FBT001 Boolean-typed positional argument in function definition
   |
37 |     """CLI interface for midjargon."""
38 |
39 |     def json(self, prompt: str, no_color: bool = False) -> None:
   |                                 ^^^^^^^^ FBT001
40 |         """Parse a prompt to MidjargonDict format.
   |

src/midjargon/cli/main.py:39:33: FBT002 Boolean default positional argument in function definition
   |
37 |     """CLI interface for midjargon."""
38 |
39 |     def json(self, prompt: str, no_color: bool = False) -> None:
   |                                 ^^^^^^^^ FBT002
40 |         """Parse a prompt to MidjargonDict format.
   |

src/midjargon/cli/main.py:54:28: FBT001 Boolean-typed positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT001
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:54:28: FBT002 Boolean default positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT002
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:54:55: FBT001 Boolean-typed positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT001
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:54:55: FBT002 Boolean default positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT002
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:92:28: FBT001 Boolean-typed positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT001
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:92:28: FBT002 Boolean default positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT002
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:92:55: FBT001 Boolean-typed positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT001
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:92:55: FBT002 Boolean default positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT002
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:124:28: FBT001 Boolean-typed positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                            ^^^^^^^^^^^ FBT001
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/cli/main.py:124:28: FBT002 Boolean default positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                            ^^^^^^^^^^^ FBT002
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/cli/main.py:124:55: FBT001 Boolean-typed positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                                                       ^^^^^^^^ FBT001
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/cli/main.py:124:55: FBT002 Boolean default positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                                                       ^^^^^^^^ FBT002
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/core/input.py:8:5: C901 `parse_weighted_prompt` is too complex (12 > 10)
  |
8 | def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
  |     ^^^^^^^^^^^^^^^^^^^^^ C901
9 |     """Parse a prompt with optional weights.
  |

src/midjargon/core/main.py:9:36: FBT001 Boolean-typed positional argument in function definition
   |
 8 | def format_json_output(
 9 |     variants: list[PromptVariant], include_parsed: bool = False
   |                                    ^^^^^^^^^^^^^^ FBT001
10 | ) -> dict[str, Any]:
11 |     """Format prompt variants as JSON output.
   |

src/midjargon/core/main.py:9:36: FBT002 Boolean default positional argument in function definition
   |
 8 | def format_json_output(
 9 |     variants: list[PromptVariant], include_parsed: bool = False
   |                                    ^^^^^^^^^^^^^^ FBT002
10 | ) -> dict[str, Any]:
11 |     """Format prompt variants as JSON output.
   |

src/midjargon/core/models.py:31:9: C901 `_missing_` is too complex (16 > 10)
   |
30 |     @classmethod
31 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ C901
32 |         """Handle missing values by trying to normalize the input."""
33 |         try:
   |

src/midjargon/core/models.py:31:9: PLR0911 Too many return statements (7 > 6)
   |
30 |     @classmethod
31 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ PLR0911
32 |         """Handle missing values by trying to normalize the input."""
33 |         try:
   |

src/midjargon/core/models.py:31:9: PLR0912 Too many branches (16 > 12)
   |
30 |     @classmethod
31 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ PLR0912
32 |         """Handle missing values by trying to normalize the input."""
33 |         try:
   |

src/midjargon/core/models.py:77:9: E722 Do not use bare `except`
   |
76 |             return None
77 |         except:
   |         ^^^^^^ E722
78 |             return None
   |

src/midjargon/core/models.py:140:9: E722 Do not use bare `except`
    |
138 |                 raise ValueError
139 |             return f"{w}:{h}"
140 |         except:
    |         ^^^^^^ E722
141 |             msg = "Invalid aspect ratio format. Expected W:H"
142 |             raise ValueError(msg)
    |

src/midjargon/core/models.py:142:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
140 |         except:
141 |             msg = "Invalid aspect ratio format. Expected W:H"
142 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
143 |
144 |     @field_validator("stylize")
    |

src/midjargon/core/models.py:216:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
214 |             except ValueError as e:
215 |                 msg = f"Invalid aspect ratio format: {e}"
216 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^ B904
217 |         return v
    |

src/midjargon/core/parameters.py:65:5: E722 Do not use bare `except`
   |
63 |         result = urlparse(value)
64 |         return all([result.scheme, result.netloc])
65 |     except:
   |     ^^^^^^ E722
66 |         return False
   |

src/midjargon/core/parameters.py:69:5: C901 `convert_parameter_value` is too complex (15 > 10)
   |
69 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ C901
70 |     """Convert a parameter value to the appropriate type."""
71 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:69:5: PLR0911 Too many return statements (10 > 6)
   |
69 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
70 |     """Convert a parameter value to the appropriate type."""
71 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:69:5: PLR0912 Too many branches (15 > 12)
   |
69 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
70 |     """Convert a parameter value to the appropriate type."""
71 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:89:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
87 |         except ValueError:
88 |             msg = f"Invalid version value: {value}"
89 |             raise ValueError(msg)
   |             ^^^^^^^^^^^^^^^^^^^^^ B904
90 |
91 |     # Handle integer parameters
   |

src/midjargon/core/parameters.py:97:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
95 |         except ValueError:
96 |             msg = f"Invalid integer value for {param}: {value}"
97 |             raise ValueError(msg)
   |             ^^^^^^^^^^^^^^^^^^^^^ B904
98 |
99 |     # Handle float parameters
   |

src/midjargon/core/parameters.py:114:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
112 |         except ValueError:
113 |             msg = f"Invalid numeric value for {param}: {value}"
114 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
115 |
116 |     # Handle style parameter
    |

src/midjargon/core/parameters.py:122:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
120 |         except ValueError:
121 |             msg = f"Invalid style value: {value}"
122 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
123 |
124 |     # Handle character and style references
    |

src/midjargon/core/parameters.py:139:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
137 |         except Exception:
138 |             msg = f"Invalid reference value for {param}: {value}"
139 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
140 |
141 |     # Default case: return as string
    |

src/midjargon/core/parameters.py:145:5: C901 `parse_parameters` is too complex (14 > 10)
    |
145 | def parse_parameters(param_str: str) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^ C901
146 |     """Parse parameters from a string into a dictionary."""
147 |     if not param_str:
    |

src/midjargon/core/parameters.py:145:5: PLR0912 Too many branches (18 > 12)
    |
145 | def parse_parameters(param_str: str) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^ PLR0912
146 |     """Parse parameters from a string into a dictionary."""
147 |     if not param_str:
    |

src/midjargon/core/parameters.py:155:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
153 |     except ValueError as e:
154 |         msg = f"Failed to parse parameters: {e}"
155 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
156 |
157 |     result: dict[str, Any] = {}
    |

src/midjargon/core/parameters.py:188:21: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
186 |                 except Exception as e:
187 |                     msg = f"Failed to parse parameter {current_param}: {e}"
188 |                     raise ValueError(msg)
    |                     ^^^^^^^^^^^^^^^^^^^^^ B904
189 |
190 |             # Start new parameter
    |

src/midjargon/core/parameters.py:221:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
219 |         except Exception as e:
220 |             msg = f"Failed to parse parameter {current_param}: {e}"
221 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
222 |
223 |     return result
    |

src/midjargon/core/parser.py:24:5: E722 Do not use bare `except`
   |
22 |             )
23 |         )
24 |     except:
   |     ^^^^^^ E722
25 |         return False
   |

src/midjargon/core/parser.py:60:5: C901 `parse_parameters` is too complex (12 > 10)
   |
60 | def parse_parameters(param_str: str) -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^ C901
61 |     """Parse parameter string into a dictionary.
   |

src/midjargon/core/parser.py:60:5: PLR0912 Too many branches (15 > 12)
   |
60 | def parse_parameters(param_str: str) -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^ PLR0912
61 |     """Parse parameter string into a dictionary.
   |

src/midjargon/core/parser.py:146:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
144 |         except Exception as e:
145 |             msg = f"Failed to parse parameters: {e!s}"
146 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
147 |     else:
148 |         text_part = remaining_text.strip()
    |

src/midjargon/core/parser.py:160:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
158 |     except Exception as e:
159 |         msg = f"Failed to create prompt object: {e!s}"
160 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
    |

src/midjargon/core/permutations.py:127:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
125 |     except Exception as e:
126 |         msg = f"Failed to parse options at position {start}: {e!s}"
127 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
128 |
129 |     if not options:
    |

src/midjargon/core/permutations.py:145:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
143 |         except Exception as e:
144 |             msg = f"Failed to expand option '{option}': {e!s}"
145 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
146 |
147 |     return results
    |

tests/core/test_parameters.py:134:5: PLR0915 Too many statements (58 > 50)
    |
134 | def test_parse_parameters():
    |     ^^^^^^^^^^^^^^^^^^^^^ PLR0915
135 |     """Test parse_parameters function to verify parameter parsing."""
136 |     param_str = "--ar 16:9 --stylize 100"
    |

Found 46 errors.
============================= test session starts ==============================
platform darwin -- Python 3.12.8, pytest-8.3.4, pluggy-1.5.0 -- /Users/adam/Library/Application Support/hatch/env/virtual/midjargon/XMQ91zt9/hatch-test.py3.12/bin/python3
cachedir: .pytest_cache
rootdir: /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/midjargon
configfile: pyproject.toml
plugins: rerunfailures-14.0, anyio-4.8.0, mock-3.14.0, xdist-3.6.1
collecting ... collected 92 items

tests/cli/test_main.py::test_basic_prompt FAILED                         [  1%]
tests/cli/test_main.py::test_permutations FAILED                         [  2%]
tests/cli/test_main.py::test_raw_output FAILED                           [  3%]
tests/cli/test_main.py::test_json_output_formatting FAILED               [  4%]
tests/cli/test_main.py::test_invalid_input FAILED                        [  5%]
tests/cli/test_main.py::test_parameter_validation FAILED                 [  6%]
tests/cli/test_main.py::test_image_url_handling FAILED                   [  7%]
tests/cli/test_main.py::test_no_color_output FAILED                      [  8%]
tests/cli/test_main.py::test_complex_prompt FAILED                       [  9%]
tests/cli/test_main.py::test_personalization_parameter FAILED            [ 10%]
tests/cli/test_main.py::test_numeric_range_permutations FAILED           [ 11%]
tests/cli/test_main.py::test_nested_parameter_permutations FAILED        [ 13%]
tests/cli/test_main.py::test_mj_command FAILED                           [ 14%]
tests/cli/test_main.py::test_fal_command FAILED                          [ 15%]
tests/cli/test_main.py::test_perm_command FAILED                         [ 16%]
tests/core/test_input.py::test_basic_input FAILED                        [ 17%]
tests/core/test_input.py::test_single_permutation FAILED                 [ 18%]
tests/core/test_input.py::test_empty_input FAILED                        [ 19%]
tests/core/test_input.py::test_multiple_permutations FAILED              [ 20%]
tests/core/test_input.py::test_nested_permutations FAILED                [ 21%]
tests/core/test_input.py::test_escaped_braces FAILED                     [ 22%]
tests/core/test_input.py::test_escaped_commas FAILED                     [ 23%]
tests/core/test_input.py::test_unmatched_braces FAILED                   [ 25%]
tests/core/test_input.py::test_empty_permutation FAILED                  [ 26%]
tests/core/test_input.py::test_whitespace_handling FAILED                [ 27%]
tests/core/test_input.py::test_expand_midjargon_input FAILED             [ 28%]
tests/core/test_input.py::test_handling_escaped_characters FAILED        [ 29%]
tests/core/test_parameters.py::test_basic_parameter_parsing FAILED       [ 30%]
tests/core/test_parameters.py::test_flag_parameters FAILED               [ 31%]
tests/core/test_parameters.py::test_parameter_with_multiple_values FAILED [ 32%]
tests/core/test_parameters.py::test_parameter_with_spaces FAILED         [ 33%]
tests/core/test_parameters.py::test_mixed_parameters FAILED              [ 34%]
tests/core/test_parameters.py::test_shorthand_parameters FAILED          [ 35%]
tests/core/test_parameters.py::test_niji_version_parameter FAILED        [ 36%]
tests/core/test_parameters.py::test_version_parameter FAILED             [ 38%]
tests/core/test_parameters.py::test_personalization_parameter FAILED     [ 39%]
tests/core/test_parameters.py::test_reference_parameters FAILED          [ 40%]
tests/core/test_parameters.py::test_parameter_order PASSED               [ 41%]
tests/core/test_parameters.py::test_invalid_parameters FAILED            [ 42%]
tests/core/test_parameters.py::test_parse_parameters FAILED              [ 43%]
tests/core/test_parameters.py::test_flag_parameters_handling FAILED      [ 44%]
tests/core/test_parameters.py::test_special_seed_values FAILED           [ 45%]
tests/core/test_parameters.py::test_reference_url_handling FAILED        [ 46%]
tests/core/test_parameters.py::test_niji_version_handling FAILED         [ 47%]
tests/core/test_parser.py::test_basic_prompt_parsing FAILED              [ 48%]
tests/core/test_parser.py::test_prompt_with_image_url FAILED             [ 50%]
tests/core/test_parser.py::test_prompt_with_multiple_image_urls FAILED   [ 51%]
tests/core/test_parser.py::test_prompt_with_parameters FAILED            [ 52%]
tests/core/test_parser.py::test_prompt_with_empty_parameters FAILED      [ 53%]
tests/core/test_parser.py::test_prompt_with_escaped_characters PASSED    [ 54%]
tests/core/test_parser.py::test_prompt_with_nested_permutations PASSED   [ 55%]
tests/core/test_parser.py::test_prompt_with_unmatched_braces PASSED      [ 56%]
tests/core/test_parser.py::test_prompt_with_empty_permutation PASSED     [ 57%]
tests/core/test_parser.py::test_prompt_with_whitespace_handling PASSED   [ 58%]
tests/engines/midjourney/test_midjourney_parser.py::test_numeric_parameters PASSED [ 59%]
tests/engines/midjourney/test_midjourney_parser.py::test_style_parameters PASSED [ 60%]
tests/engines/midjourney/test_midjourney_parser.py::test_aspect_ratio FAILED [ 61%]
tests/engines/midjourney/test_midjourney_parser.py::test_image_prompts PASSED [ 63%]
tests/engines/midjourney/test_midjourney_parser.py::test_extra_parameters PASSED [ 64%]
tests/engines/midjourney/test_midjourney_parser.py::test_parameter_conversion PASSED [ 65%]
tests/engines/midjourney/test_midjourney_parser.py::test_invalid_values FAILED [ 66%]
tests/engines/midjourney/test_midjourney_parser.py::test_empty_values FAILED [ 67%]
tests/engines/midjourney/test_midjourney_parser.py::test_version_parameter PASSED [ 68%]
tests/engines/midjourney/test_midjourney_parser.py::test_multiple_permutations PASSED [ 69%]
tests/engines/midjourney/test_midjourney_parser.py::test_personalization_parameter PASSED [ 70%]
tests/engines/midjourney/test_midjourney_parser.py::test_edge_cases PASSED [ 71%]
tests/integration/test_workflow.py::test_basic_workflow FAILED           [ 72%]
tests/integration/test_workflow.py::test_permutation_workflow FAILED     [ 73%]
tests/integration/test_workflow.py::test_image_workflow FAILED           [ 75%]
tests/integration/test_workflow.py::test_parameter_workflow FAILED       [ 76%]
tests/integration/test_workflow.py::test_new_parameters_workflow FAILED  [ 77%]
tests/integration/test_workflow.py::test_weighted_prompts_workflow FAILED [ 78%]
tests/integration/test_workflow.py::test_error_workflow FAILED           [ 79%]
tests/integration/test_workflow.py::test_complex_workflow FAILED         [ 80%]
tests/integration/test_workflow.py::test_permutations_with_parameters FAILED [ 81%]
tests/integration/test_workflow.py::test_permutations_with_flag_parameters FAILED [ 82%]
tests/integration/test_workflow.py::test_permutations_with_complex_parameters FAILED [ 83%]
tests/integration/test_workflow.py::test_cli_mj_command FAILED           [ 84%]
tests/integration/test_workflow.py::test_cli_fal_command FAILED          [ 85%]
tests/integration/test_workflow.py::test_cli_perm_command FAILED         [ 86%]
tests/test_core.py::test_basic_prompt_parsing PASSED                     [ 88%]
tests/test_core.py::test_prompt_with_parameters FAILED                   [ 89%]
tests/test_core.py::test_prompt_with_image PASSED                        [ 90%]
tests/test_core.py::test_invalid_parameters FAILED                       [ 91%]
tests/test_core.py::test_permutation_expansion PASSED                    [ 92%]
tests/test_core.py::test_escaped_permutations PASSED                     [ 93%]
tests/test_core.py::test_weighted_prompts FAILED                         [ 94%]
tests/test_core.py::test_combined_features FAILED                        [ 95%]
tests/test_core.py::test_style_reference PASSED                          [ 96%]
tests/test_core.py::test_character_reference FAILED                      [ 97%]
tests/test_core.py::test_prompt_to_string FAILED                         [ 98%]
tests/test_package.py::test_version PASSED                               [100%]

=================================== FAILURES ===================================
______________________________ test_basic_prompt _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e6600>

    def test_basic_prompt(cli):
        """Test basic prompt processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT}",
                json_output=True,
            )
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:58: TypeError
______________________________ test_permutations _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e65d0>

    def test_permutations(cli):
        """Test permutation processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10402c4c0>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_raw_output ________________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e6fc0>

    def test_raw_output(cli):
        """Test raw output mode."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"a photo --stylize {STYLIZE_VALUE}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:86: TypeError
_________________________ test_json_output_formatting __________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e47a0>

    def test_json_output_formatting(cli):
        """Test JSON output formatting."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:98: TypeError
______________________________ test_invalid_input ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10409f680>

    def test_invalid_input(cli):
        """Test handling of invalid input."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:110: TypeError
__________________________ test_parameter_validation ___________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10409f380>

    def test_parameter_validation(cli):
        """Test parameter validation."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a photo --stylize {STYLIZE_VALUE * 20}", json_output=True
            )  # Over max
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:120: TypeError
___________________________ test_image_url_handling ____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x103fdcfe0>

    def test_image_url_handling(cli):
        """Test handling of image URLs."""
        url = "https://example.com/image.jpg"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"{url} a fusion", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:133: TypeError
_____________________________ test_no_color_output _____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10407bfe0>

    def test_no_color_output(cli):
        """Test no-color output mode."""
        Console(force_terminal=False)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True, no_color=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:147: TypeError
_____________________________ test_complex_prompt ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x104078770>

    def test_complex_prompt(cli):
        """Test complex prompt with multiple features."""
        prompt = (
            "https://example.com/img1.jpg https://example.com/img2.jpg "
            "a {red, blue} bird on a {branch, rock} "
            f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
        )
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(prompt, json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:163: TypeError
________________________ test_personalization_parameter ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x104078da0>

    def test_personalization_parameter(cli):
        """Test personalization parameter handling in different forms."""
        # Test flag form (--p)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --p", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:180: TypeError
_______________________ test_numeric_range_permutations ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x104079610>

    def test_numeric_range_permutations(cli):
        """Test handling of numeric parameters in permutations."""
        # Test stylize parameter range
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:210: TypeError
______________________ test_nested_parameter_permutations ______________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x104079ee0>

    def test_nested_parameter_permutations(cli):
        """Test handling of nested permutations with parameters."""
        # Test personalization with nested options
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("smooth edges {, --p {, CODE1}} --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:237: TypeError
_______________________________ test_mj_command ________________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10409ff80>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
>               mj_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x1039e37a0>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/midjourney/midjourney.py:46: TypeError

During handling of the above exception, another exception occurred:

cli = <midjargon.cli.main.MidjargonCLI object at 0x10409ff80>

    def test_mj_command(cli):
        """Test Midjourney prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.mj("a serene landscape --ar 16:9 --stylize 100", json_output=True)

tests/cli/test_main.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10409ff80>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
                mj_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(mj_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    params = " ".join(
                        f"--{k} {v}"
                        for k, v in result.items()
                        if k not in {"text", "image_prompts", "extra_params"}
                        and v is not None
                    )
                    console.print(
                        f"{result['text']} {params}",
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:89: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword 
argument 'extra_params'
_______________________________ test_fal_command _______________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x1040e5430>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x1040e6960>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e5430>

    def test_fal_command(cli):
        """Test Fal.ai prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal("a serene landscape --ar 16:9 --stylize 100", json_output=True)

tests/cli/test_main.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x1040e5430>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
______________________________ test_perm_command _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e63c0>

    def test_perm_command(cli):
        """Test permutation expansion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird on a {branch, rock}", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10402f4c0>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_basic_input _______________________________

    def test_basic_input():
        """Test basic input without permutations."""
        result = expand_midjargon_input("a simple prompt")
        assert len(result) == 1
>       assert result[0] == "a simple prompt"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a simple prompt', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == 'a simple prompt'

tests/core/test_input.py:15: AssertionError
___________________________ test_single_permutation ____________________________

    def test_single_permutation():
        """Test input with a single permutation."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:22: AssertionError
_______________________________ test_empty_input _______________________________

    def test_empty_input():
        """Test empty input handling."""
        result = expand_midjargon_input("")
        assert len(result) == 1
>       assert result[0] == ""
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == ''

tests/core/test_input.py:30: AssertionError
__________________________ test_multiple_permutations __________________________

    def test_multiple_permutations():
        """Test input with multiple permutations."""
        result = expand_midjargon_input("a {red, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_3
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a green bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:37: AssertionError
___________________________ test_nested_permutations ___________________________

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
>               results.extend(expand_permutations(new_s))

src/midjargon/core/permutations.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a red {cat'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 6

src/midjargon/core/permutations.py:119: ValueError

During handling of the above exception, another exception occurred:

    def test_nested_permutations():
        """Test input with nested permutations."""
>       result = expand_midjargon_input("a {red {cat, dog}, blue bird}")

tests/core/test_input.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:84: in expand_midjargon_input
    permutation_options = expand_permutations(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
                results.extend(expand_permutations(new_s))
            except Exception as e:
                msg = f"Failed to expand option '{option}': {e!s}"
>               raise ValueError(msg)
E               ValueError: Failed to expand option 'red {cat': Unclosed brace at position 6

src/midjargon/core/permutations.py:145: ValueError
_____________________________ test_escaped_braces ______________________________

    def test_escaped_braces():
        """Test input with escaped braces."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:55: AssertionError
_____________________________ test_escaped_commas ______________________________

    def test_escaped_commas():
        """Test input with escaped commas."""
        result = expand_midjargon_input(r"a {red\, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red, blue bird" in result
E       AssertionError: assert 'a red, blue bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red, blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a green bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:62: AssertionError
____________________________ test_unmatched_braces _____________________________

    def test_unmatched_braces():
        """Test input with unmatched braces."""
>       result = expand_midjargon_input("a {red, blue bird")

tests/core/test_input.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:84: in expand_midjargon_input
    permutation_options = expand_permutations(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red, blue bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 2

src/midjargon/core/permutations.py:119: ValueError
____________________________ test_empty_permutation ____________________________

    def test_empty_permutation():
        """Test input with empty permutation options."""
>       result = expand_midjargon_input("a {} bird")

tests/core/test_input.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:84: in expand_midjargon_input
    permutation_options = expand_permutations(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {} bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
>           raise ValueError(msg)
E           ValueError: Empty permutation group at position 2

src/midjargon/core/permutations.py:131: ValueError
___________________________ test_whitespace_handling ___________________________

    def test_whitespace_handling():
        """Test input with various whitespace patterns."""
        result = expand_midjargon_input("a {  red  ,  blue  } bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:84: AssertionError
_________________________ test_expand_midjargon_input __________________________

    def test_expand_midjargon_input():
        """Test expand_midjargon_input function to verify prompt expansion."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == 2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:92: AssertionError
_______________________ test_handling_escaped_characters _______________________

    def test_handling_escaped_characters():
        """Test handling of escaped characters in expand_midjargon_input."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:112: AssertionError
_________________________ test_basic_parameter_parsing _________________________

    def test_basic_parameter_parsing():
        """Test parsing of basic parameters."""
        param_str = "--ar 16:9 --stylize 100"
        params = parse_parameters(param_str)
        assert params["aspect"] == "16:9"
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:14: AssertionError
_____________________________ test_flag_parameters _____________________________

    def test_flag_parameters():
        """Test parsing of flag parameters (without values)."""
        param_str = "--tile --turbo --relax"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:21: AssertionError
_____________________ test_parameter_with_multiple_values ______________________

    def test_parameter_with_multiple_values():
        """Test parsing parameters that accept multiple values."""
        param_str = "--no blur,cars,watermark"
        params = parse_parameters(param_str)
>       assert params["no"] == "blur,cars,watermark"
E       AssertionError: assert ['blur,cars,watermark'] == 'blur,cars,watermark'

tests/core/test_parameters.py:30: AssertionError
__________________________ test_parameter_with_spaces __________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
>                           value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )

src/midjargon/core/parameters.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:122: ValueError

During handling of the above exception, another exception occurred:

    def test_parameter_with_spaces():
        """Test parsing parameters with values containing spaces."""
        param_str = '--style "raw photo" --seed 123456'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
>                       raise ValueError(msg)
E                       ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:188: ValueError
____________________________ test_mixed_parameters _____________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
>                   value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )

src/midjargon/core/parameters.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:122: ValueError

During handling of the above exception, another exception occurred:

    def test_mixed_parameters():
        """Test parsing a mix of different parameter types."""
        param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
                    value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )
                    result[current_param] = value
            except Exception as e:
                msg = f"Failed to parse parameter {current_param}: {e}"
>               raise ValueError(msg)
E               ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:221: ValueError
__________________________ test_shorthand_parameters ___________________________

    def test_shorthand_parameters():
        """Test parsing of shorthand parameter names."""
        param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
        params = parse_parameters(param_str)
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:55: AssertionError
_________________________ test_niji_version_parameter __________________________

    def test_niji_version_parameter():
        """Test parsing of niji version parameter."""
        # Test basic niji
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:66: AssertionError
____________________________ test_version_parameter ____________________________

    def test_version_parameter():
        """Test parsing of version parameter."""
        # Test v parameter
        params = parse_parameters("--v 5.2")
>       assert params["version"] == "5.2"
E       AssertionError: assert <MidjourneyVe....V5_2: 'v5.2'> == '5.2'
E         
E         - 5.2
E         + v5.2
E         ? +

tests/core/test_parameters.py:77: AssertionError
________________________ test_personalization_parameter ________________________

    def test_personalization_parameter():
        """Test parsing of personalization parameter."""
        # Test basic p parameter
        params = parse_parameters("--p")
>       assert params["personalization"] is None  # Flag without value is None
E       assert True is None

tests/core/test_parameters.py:84: AssertionError
__________________________ test_reference_parameters ___________________________

    def test_reference_parameters():
        """Test parsing of reference parameters."""
        param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
        params = parse_parameters(param_str)
>       assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
E       AssertionError: assert [CharacterRef...e='img2.jpg')] == ['img1.jpg', 'img2.jpg']
E         
E         At index 0 diff: CharacterReference(url=HttpUrl('https://example.com/img1.jpg'), weight=1.0, code='img1.jpg') != 'img1.jpg'
E         
E         Full diff:
E           [
E         -     'img1.jpg',
E         -     'img2.jpg',...
E         
E         ...Full output truncated (3 lines hidden), use '-vv' to show

tests/core/test_parameters.py:107: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameter formats."""
>       with pytest.raises(ValueError, match="Empty parameter name"):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/core/test_parameters.py:121: Failed
____________________________ test_parse_parameters _____________________________

    def test_parse_parameters():
        """Test parse_parameters function to verify parameter parsing."""
        param_str = "--ar 16:9 --stylize 100"
        params = parse_parameters(param_str)
        assert params["aspect"] == "16:9"
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:139: AssertionError
________________________ test_flag_parameters_handling _________________________

    def test_flag_parameters_handling():
        """Test handling of flag parameters in parse_parameters."""
        param_str = "--tile --turbo --relax --video --remix"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:216: AssertionError
___________________________ test_special_seed_values ___________________________

param = 'seed', value = 'random'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
>               return int(value)
E               ValueError: invalid literal for int() with base 10: 'random'

src/midjargon/core/parameters.py:94: ValueError

During handling of the above exception, another exception occurred:

param_str = '--seed random'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
>                   value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )

src/midjargon/core/parameters.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'seed', value = 'random'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid integer value for seed: random

src/midjargon/core/parameters.py:97: ValueError

During handling of the above exception, another exception occurred:

    def test_special_seed_values():
        """Test handling of special seed values."""
        # Test random seed
>       params = parse_parameters("--seed random")

tests/core/test_parameters.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--seed random'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
                    value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )
                    result[current_param] = value
            except Exception as e:
                msg = f"Failed to parse parameter {current_param}: {e}"
>               raise ValueError(msg)
E               ValueError: Failed to parse parameter seed: Invalid integer value for seed: random

src/midjargon/core/parameters.py:221: ValueError
_________________________ test_reference_url_handling __________________________

    def test_reference_url_handling():
        """Test handling of URLs in reference parameters."""
        # Test character reference with quoted URL containing spaces
        params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
>       assert params["character_reference"] == [
            "https://example.com/image with spaces.jpg"
        ]
E       AssertionError: assert [CharacterRef...0, code=None)] == ['https://exa...h spaces.jpg']
E         
E         At index 0 diff: CharacterReference(url=HttpUrl('https://example.com/image%20with%20spaces.jpg'), weight=1.0, code=None) != 'https://example.com/image with spaces.jpg'
E         
E         Full diff:
E           [
E         -     'https://example.com/image with spaces.jpg',
E         +     CharacterReference(url=HttpUrl('https://example.com/image%20with%20spaces.jpg'), weight=1.0, code=None),
E           ]

tests/core/test_parameters.py:250: AssertionError
__________________________ test_niji_version_handling __________________________

    def test_niji_version_handling():
        """Test handling of niji version parameter."""
        # Test basic niji flag
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:271: AssertionError
__________________________ test_basic_prompt_parsing ___________________________

    def test_basic_prompt_parsing():
        """Test basic prompt parsing."""
        prompt = "a beautiful landscape --ar 16:9 --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a beautiful landscape"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:18: KeyError
__________________________ test_prompt_with_image_url __________________________

    def test_prompt_with_image_url():
        """Test prompt parsing with image URL."""
        prompt = f"{IMAGE_URL} a mystical forest --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a mystical forest"
>       assert result["images"] == [IMAGE_URL]
E       AssertionError: assert [HttpUrl('htt...m/image.jpg')] == ['https://exa...om/image.jpg']
E         
E         At index 0 diff: HttpUrl('https://example.com/image.jpg') != 'https://example.com/image.jpg'
E         
E         Full diff:
E           [
E         -     'https://example.com/image.jpg',
E         +     HttpUrl('https://example.com/image.jpg'),
E         ?     ++++++++                               +
E           ]

tests/core/test_parser.py:27: AssertionError
_____________________ test_prompt_with_multiple_image_urls _____________________

    def test_prompt_with_multiple_image_urls():
        """Test prompt parsing with multiple image URLs."""
        image_urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
        prompt = f"{image_urls[0]} {image_urls[1]} a serene landscape --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a serene landscape"
>       assert result["images"] == image_urls
E       AssertionError: assert [HttpUrl('htt.../image2.jpg')] == ['https://exa...m/image2.jpg']
E         
E         At index 0 diff: HttpUrl('https://example.com/image1.jpg') != 'https://example.com/image1.jpg'
E         
E         Full diff:
E           [
E         -     'https://example.com/image1.jpg',
E         +     HttpUrl('https://example.com/image1.jpg'),...
E         
E         ...Full output truncated (5 lines hidden), use '-vv' to show

tests/core/test_parser.py:40: AssertionError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a futuristic city --ar 16:9 --stylize 100 --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a futuristic city"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:49: KeyError
______________________ test_prompt_with_empty_parameters _______________________

    def test_prompt_with_empty_parameters():
        """Test prompt parsing with empty parameters."""
        prompt = "a landscape photo --tile --no blur,cars"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a landscape photo"
>       assert result["tile"] is None
E       assert True is None

tests/core/test_parser.py:59: AssertionError
______________________________ test_aspect_ratio _______________________________

    def test_aspect_ratio():
        """Test parsing of aspect ratio."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict({"text": "a photo", "ar": "16:9"})
    
        assert prompt.text == "a photo"
>       assert prompt.aspect_width == 16
E       AssertionError: assert None == 16
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={'ar': '16:9'}, images=[]).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:61: AssertionError
_____________________________ test_invalid_values ______________________________

    def test_invalid_values():
        """Test handling of invalid parameter values."""
        parser = MidjourneyParser()
    
        # Invalid aspect ratio - now accepts any value
        result = parser.parse_dict({"text": "a photo", "ar": "999:999"})
>       assert result.aspect_width == 999
E       AssertionError: assert None == 999
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={'ar': '999:999'}, images=[]).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:120: AssertionError
______________________________ test_empty_values _______________________________

    def test_empty_values():
        """Test handling of empty values."""
        parser = MidjourneyParser()
    
        # Empty text
        with pytest.raises(ValueError, match="Empty prompt"):
            parser.parse_dict({"text": ""})
    
        # Empty image list
        prompt = parser.parse_dict({"text": "a photo", "image_prompts": []})
        assert prompt.text == "a photo"
        assert not prompt.image_prompts
    
        # None values
>       prompt = parser.parse_dict({"text": "a photo", "stylize": None})

tests/engines/midjourney/test_midjourney_parser.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x10409f8f0>
prompt_dict = {'stylize': None}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for MidjourneyPrompt
E       stylize
E         Input should be a valid number [type=float_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.10/v/float_type

src/midjargon/engines/midjourney/midjourney.py:46: ValidationError
_____________________________ test_basic_workflow ______________________________

prompt = 'a beautiful landscape --ar 16:9 --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_basic_workflow():
        """Test basic prompt workflow without permutations."""
        prompt = f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'a beautiful landscape --ar 16:9 --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
__________________________ test_permutation_workflow ___________________________

prompt = 'a red bird on a branch --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutation_workflow():
        """Test workflow with permutations."""
        prompt = f"a {{red, blue}} bird on a {{branch, rock}} --stylize {STYLIZE_VALUE}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'a red bird on a branch --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_____________________________ test_image_workflow ______________________________

prompt = 'https://example.com/image1.jpg https://example.com/image2.jpg abstract fusion --iw 2.0 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_image_workflow():
        """Test workflow with image URLs."""
        urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
        prompt = f"{' '.join(urls)} abstract fusion --iw {IMAGE_WEIGHT_VALUE}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'https://example.com/image1.jpg https://example.com/image2.jpg abstract fusion --iw 2.0 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
___________________________ test_parameter_workflow ____________________________

prompt = 'cyberpunk city --v 5.2 --style raw --chaos 50 --weird 1000 --seed 12345 --stop 80 --turbo --tile --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_parameter_workflow():
        """Test workflow with various parameter types."""
        prompt = (
            "cyberpunk city --v 5.2 --style raw "
            f"--chaos {CHAOS_VALUE} --weird {WEIRD_VALUE} "
            f"--seed {SEED_VALUE} --stop {STOP_VALUE} "
            "--turbo --tile"
        )
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'cyberpunk city --v 5.2 --style raw --chaos 50 --weird 1000 --seed 12345 --stop 80 --turbo --tile --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_________________________ test_new_parameters_workflow _________________________

prompt = 'portrait photo --quality 1.0 --cw 100 --sw 200 --sv 2 --repeat 3 --cref ref1.jpg ref2.jpg --sref style1.jpg style2.jp... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_new_parameters_workflow():
        """Test workflow with new parameter types."""
        prompt = (
            "portrait photo "
            f"--quality {QUALITY_VALUE} "
            f"--cw {CHARACTER_WEIGHT_VALUE} "
            f"--sw {STYLE_WEIGHT_VALUE} "
            f"--sv {STYLE_VERSION_VALUE} "
            f"--repeat {REPEAT_VALUE} "
            "--cref ref1.jpg ref2.jpg "
            "--sref style1.jpg style2.jpg "
            "--p custom_profile1 custom_profile2"
        )
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'portrait photo --quality 1.0 --cw 100 --sw 200 --sv 2 --repeat 3 --cref ref1.jpg ref2.jpg --sref style1.jpg style2.jp... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
________________________ test_weighted_prompts_workflow ________________________

prompt = 'cyberpunk city::2 neon lights::1 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_weighted_prompts_workflow():
        """Test workflow with weighted prompts."""
        prompt = "cyberpunk city::2 neon lights::1"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'cyberpunk city::2 neon lights::1 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_____________________________ test_error_workflow ______________________________

prompt = ' --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_error_workflow():
        """Test error handling in workflow."""
        # Test empty prompt
        with pytest.raises(ValueError, match="Empty prompt"):
>           process_prompt("")

tests/integration/test_workflow.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = ' --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError

During handling of the above exception, another exception occurred:

    def test_error_workflow():
        """Test error handling in workflow."""
        # Test empty prompt
>       with pytest.raises(ValueError, match="Empty prompt"):
E       AssertionError: Regex pattern did not match.
E        Regex: 'Empty prompt'
E        Input: "Failed to create prompt object: 2 validation errors for MidjourneyPrompt\ncharacter_reference\n  Input should be a valid list [type=list_type, input_value='[]', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/list_type\nstyle_reference\n  Input should be a valid list [type=list_type, input_value='[]', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/list_type"

tests/integration/test_workflow.py:164: AssertionError
____________________________ test_complex_workflow _____________________________

prompt = 'https://example.com/img1.jpg https://example.com/img2.jpg a vintage portrait with warm tones --ar 16:9 --stylize 100 ... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_complex_workflow():
        """Test workflow with multiple features combined."""
        prompt = (
            "https://example.com/img1.jpg https://example.com/img2.jpg "
            "a {vintage, modern} {portrait, landscape} "
            "with {warm, cool} tones "
            f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} "
            f"--chaos {CHAOS_VALUE} --v 5.2 --style raw "
            f"--quality {QUALITY_VALUE} --cw {CHARACTER_WEIGHT_VALUE} "
            "--turbo"
        )
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'https://example.com/img1.jpg https://example.com/img2.jpg a vintage portrait with warm tones --ar 16:9 --stylize 100 ... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
______________________ test_permutations_with_parameters _______________________

prompt = 'smooth edges  --s 75 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutations_with_parameters():
        """Test permutations with parameters are handled correctly."""
        prompt = "smooth edges {, --p} --s {75, 300}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'smooth edges  --s 75 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
____________________ test_permutations_with_flag_parameters ____________________

prompt = 'photo   --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutations_with_flag_parameters():
        """Test permutations with flag parameters (no value) are handled correctly."""
        prompt = "photo {, --tile} {, --turbo}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'photo   --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
__________________ test_permutations_with_complex_parameters ___________________

prompt = 'portrait modern  --ar 1:1 --s 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutations_with_complex_parameters():
        """Test permutations with complex parameter combinations."""
        prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'portrait modern  --ar 1:1 --s 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_____________________________ test_cli_mj_command ______________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10460f350>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
>               mj_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x10460cd10>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/midjourney/midjourney.py:46: TypeError

During handling of the above exception, another exception occurred:

    def test_cli_mj_command():
        """Test Midjourney prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.mj(prompt, json_output=True)

tests/integration/test_workflow.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10460f350>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
                mj_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(mj_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    params = " ".join(
                        f"--{k} {v}"
                        for k, v in result.items()
                        if k not in {"text", "image_prompts", "extra_params"}
                        and v is not None
                    )
                    console.print(
                        f"{result['text']} {params}",
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:89: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword 
argument 'extra_params'
_____________________________ test_cli_fal_command _____________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10401ce30>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x10401d760>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

    def test_cli_fal_command():
        """Test Fal.ai prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal(prompt, json_output=True)

tests/integration/test_workflow.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10401ce30>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
____________________________ test_cli_perm_command _____________________________

    def test_cli_perm_command():
        """Test permutation expansion using CLI."""
        cli = MidjargonCLI()
        prompt = "a {red, blue} bird on a {branch, rock}"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm(prompt, json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/integration/test_workflow.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10402fa00>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
        result = parse_midjargon_prompt(prompt)
    
        assert result.text == "a portrait"
>       assert result.parameters.aspect == "16:9"
E       AssertionError: assert '1:1' == '16:9'
E         
E         - 16:9
E         + 1:1

tests/test_core.py:31: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameters."""
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_core.py:49: Failed
____________________________ test_weighted_prompts _____________________________

    def test_weighted_prompts():
        """Test handling of weighted prompts."""
        prompt = "first prompt::0.7 second prompt::0.3"
        results = expand_midjargon_input(prompt)
    
>       assert len(results) == 2
E       AssertionError: assert 1 == 2
E        +  where 1 = len([PromptVariant(prompt=MidjourneyPrompt(text='first prompt::0.7 second prompt::0.3', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)])

tests/test_core.py:80: AssertionError
____________________________ test_combined_features ____________________________

    def test_combined_features():
        """Test combination of multiple features."""
        prompt = "a {red, blue} bird::0.6 a {green, yellow} tree::0.4"
        results = expand_midjargon_input(prompt)
    
        assert len(results) == 4
        # Check first group
        red_blue = [r for r in results if "bird" in r.prompt.text]
>       assert len(red_blue) == 2
E       AssertionError: assert 4 == 2
E        +  where 4 = len([PromptVariant(prompt=MidjourneyPrompt(text='a red bird::0.6 a green tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a red bird::0.6 a yellow tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird::0.6 a green tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird::0.6 a yellow tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)])

tests/test_core.py:93: AssertionError
___________________________ test_character_reference ___________________________

    def test_character_reference():
        """Test handling of character references."""
        prompt = "test --cref https://example.com/char.jpg --cw 50"
        result = parse_midjargon_prompt(prompt)
    
        assert result.character_reference
        assert str(result.character_reference[0].url) == "https://example.com/char.jpg"
>       assert result.character_weight == 50
E       AssertionError: assert 100 == 50
E        +  where 100 = MidjourneyPrompt(text='test', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[CharacterReference(url=HttpUrl('https://example.com/char.jpg'), weight=1.0, code=None)], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]).character_weight

tests/test_core.py:126: AssertionError
____________________________ test_prompt_to_string _____________________________

prompt = 'a portrait --stylize 200 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_prompt_to_string():
        """Test conversion of prompt back to string format."""
        original = "a portrait --ar 16:9 --stylize 200"
        result = parse_midjargon_prompt(original)
    
        # Convert back to string
        output = result.to_string()
    
        # Parse again to verify equivalence
>       reparsed = parse_midjargon_prompt(output)

tests/test_core.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'a portrait --stylize 200 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
============================= slowest 10 durations =============================

(10 durations < 0.005s hidden.  Use -vv to show these durations.)
=========================== short test summary info ============================
FAILED tests/cli/test_main.py::test_basic_prompt - TypeError: MidjargonCLI.js...
FAILED tests/cli/test_main.py::test_permutations - ValueError: No JSON found ...
FAILED tests/cli/test_main.py::test_raw_output - TypeError: MidjargonCLI.json...
FAILED tests/cli/test_main.py::test_json_output_formatting - TypeError: Midja...
FAILED tests/cli/test_main.py::test_invalid_input - TypeError: MidjargonCLI.j...
FAILED tests/cli/test_main.py::test_parameter_validation - TypeError: Midjarg...
FAILED tests/cli/test_main.py::test_image_url_handling - TypeError: Midjargon...
FAILED tests/cli/test_main.py::test_no_color_output - TypeError: MidjargonCLI...
FAILED tests/cli/test_main.py::test_complex_prompt - TypeError: MidjargonCLI....
FAILED tests/cli/test_main.py::test_personalization_parameter - TypeError: Mi...
FAILED tests/cli/test_main.py::test_numeric_range_permutations - TypeError: M...
FAILED tests/cli/test_main.py::test_nested_parameter_permutations - TypeError...
FAILED tests/cli/test_main.py::test_mj_command - SystemExit: 1
FAILED tests/cli/test_main.py::test_fal_command - SystemExit: 1
FAILED tests/cli/test_main.py::test_perm_command - ValueError: No JSON found ...
FAILED tests/core/test_input.py::test_basic_input - AssertionError: assert Pr...
FAILED tests/core/test_input.py::test_single_permutation - AssertionError: as...
FAILED tests/core/test_input.py::test_empty_input - AssertionError: assert Pr...
FAILED tests/core/test_input.py::test_multiple_permutations - AssertionError:...
FAILED tests/core/test_input.py::test_nested_permutations - ValueError: Faile...
FAILED tests/core/test_input.py::test_escaped_braces - AssertionError: assert...
FAILED tests/core/test_input.py::test_escaped_commas - AssertionError: assert...
FAILED tests/core/test_input.py::test_unmatched_braces - ValueError: Unclosed...
FAILED tests/core/test_input.py::test_empty_permutation - ValueError: Empty p...
FAILED tests/core/test_input.py::test_whitespace_handling - AssertionError: a...
FAILED tests/core/test_input.py::test_expand_midjargon_input - AssertionError...
FAILED tests/core/test_input.py::test_handling_escaped_characters - Assertion...
FAILED tests/core/test_parameters.py::test_basic_parameter_parsing - Assertio...
FAILED tests/core/test_parameters.py::test_flag_parameters - assert True is None
FAILED tests/core/test_parameters.py::test_parameter_with_multiple_values - A...
FAILED tests/core/test_parameters.py::test_parameter_with_spaces - ValueError...
FAILED tests/core/test_parameters.py::test_mixed_parameters - ValueError: Fai...
FAILED tests/core/test_parameters.py::test_shorthand_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_niji_version_parameter - Assertion...
FAILED tests/core/test_parameters.py::test_version_parameter - AssertionError...
FAILED tests/core/test_parameters.py::test_personalization_parameter - assert...
FAILED tests/core/test_parameters.py::test_reference_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_invalid_parameters - Failed: DID N...
FAILED tests/core/test_parameters.py::test_parse_parameters - AssertionError:...
FAILED tests/core/test_parameters.py::test_flag_parameters_handling - assert ...
FAILED tests/core/test_parameters.py::test_special_seed_values - ValueError: ...
FAILED tests/core/test_parameters.py::test_reference_url_handling - Assertion...
FAILED tests/core/test_parameters.py::test_niji_version_handling - AssertionE...
FAILED tests/core/test_parser.py::test_basic_prompt_parsing - KeyError: 'aspect'
FAILED tests/core/test_parser.py::test_prompt_with_image_url - AssertionError...
FAILED tests/core/test_parser.py::test_prompt_with_multiple_image_urls - Asse...
FAILED tests/core/test_parser.py::test_prompt_with_parameters - KeyError: 'as...
FAILED tests/core/test_parser.py::test_prompt_with_empty_parameters - assert ...
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_aspect_ratio
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_invalid_values
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_empty_values
FAILED tests/integration/test_workflow.py::test_basic_workflow - ValueError: ...
FAILED tests/integration/test_workflow.py::test_permutation_workflow - ValueE...
FAILED tests/integration/test_workflow.py::test_image_workflow - ValueError: ...
FAILED tests/integration/test_workflow.py::test_parameter_workflow - ValueErr...
FAILED tests/integration/test_workflow.py::test_new_parameters_workflow - Val...
FAILED tests/integration/test_workflow.py::test_weighted_prompts_workflow - V...
FAILED tests/integration/test_workflow.py::test_error_workflow - AssertionErr...
FAILED tests/integration/test_workflow.py::test_complex_workflow - ValueError...
FAILED tests/integration/test_workflow.py::test_permutations_with_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_flag_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_complex_parameters
FAILED tests/integration/test_workflow.py::test_cli_mj_command - SystemExit: 1
FAILED tests/integration/test_workflow.py::test_cli_fal_command - SystemExit: 1
FAILED tests/integration/test_workflow.py::test_cli_perm_command - ValueError...
FAILED tests/test_core.py::test_prompt_with_parameters - AssertionError: asse...
FAILED tests/test_core.py::test_invalid_parameters - Failed: DID NOT RAISE <c...
FAILED tests/test_core.py::test_weighted_prompts - AssertionError: assert 1 == 2
FAILED tests/test_core.py::test_combined_features - AssertionError: assert 4 ...
FAILED tests/test_core.py::test_character_reference - AssertionError: assert ...
FAILED tests/test_core.py::test_prompt_to_string - ValueError: Failed to crea...
======================== 71 failed, 21 passed in 1.11s =========================
```

## File: LICENSE (Size: 1.04 KB)

```
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## File: LOG.md (Size: 5.23 KB)

```
---
this_file: LOG.md
---
# Implementation Log

## Overview

The midjargon package is a robust Python library for parsing and manipulating Midjourney-style prompts. The implementation follows a modular architecture with clear separation of concerns.

## Core Components Status

### 1. Core Modules [ FAILING]

#### 1.1 Parser (`src/midjargon/core/parser.py`) []

-  Main prompt parser failing with multiple issues:
  - Unclosed quotation errors in parameter parsing
  - Model validation errors
  - Type conversion issues
  - Missing attribute access
-  Needs complete overhaul of parameter parsing and model handling

#### 1.2 Parameters (`src/midjargon/core/parameters.py`) []

-  Multiple parameter handling issues:
  - Type conversion failures (numeric vs string)
  - Flag parameter handling broken
  - Reference parameter validation failing
  - Version parameter issues
-  Requires complete rework of parameter validation and type conversion

#### 1.3 Permutations (`src/midjargon/core/permutations.py`) []

-  Permutation expansion failing:
  - Weighted prompts not working
  - Nested groups failing
  - Escape character issues
  - Whitespace handling problems
-  Needs complete revision of permutation logic

#### 1.4 Input (`src/midjargon/core/input.py`) []

-  Input processing issues:
  - URL validation failing
  - Basic sanitization issues
  - Multi-prompt handling broken
  - Weight parsing failing
-  Requires complete rework of input processing

### 2. Engine-Specific Modules [ FAILING]

#### 2.1 Midjourney Engine (`src/midjargon/engines/midjourney/`) []

-  Multiple critical issues:
  - MidjourneyPrompt model attribute access failing
  - Parameter validation errors
  - Type conversion issues
  - Reference handling broken
-  Needs complete overhaul of model implementation

#### 2.2 Fal.ai Engine (`src/midjargon/engines/fal/`) []

-  Similar issues to Midjourney engine:
  - Model attribute access failing
  - Parameter mapping issues
  - Type conversion problems
  - Validation errors
-  Requires complete rework

### 3. CLI Interface (`src/midjargon/cli/`) [ FAILING]

-  Multiple command implementation issues:
  - JSON output formatting broken
  - Command parameter handling failing
  - Error handling inadequate
  - Missing functionality
-  Needs complete revision of command handling and output formatting

## Test Suite Status [ FAILING]

### Critical Issues (2024-03-21)

1. Model Implementation Issues
   - MidjourneyPrompt missing key attributes ('images', 'parameters')
   - Incorrect attribute access patterns
   - Type conversion failures
   - Validation errors in model fields

2. Parameter Handling Issues
   - Failed parameter parsing and validation
   - Incorrect type conversions
   - Problems with reference parameters
   - Flag parameter handling broken
   - Version parameter validation failing

3. CLI Implementation Issues
   - JSON output formatting broken
   - Missing command implementations
   - Incorrect parameter handling
   - Output formatting inconsistencies

4. Core Functionality Issues
   - Permutation expansion failing
   - Weighted prompt handling broken
   - Nested permutation issues
   - Escape character processing failing

5. Engine-Specific Issues
   - MidjourneyParser initialization failing
   - Parameter validation errors
   - Type conversion mismatches
   - Reference handling broken

## Next Steps

1. Fix Model Implementation
   - Implement proper attribute access
   - Fix type conversion
   - Add proper validation
   - Fix reference handling

2. Fix Parameter Handling
   - Rewrite parameter parsing
   - Fix type conversion
   - Implement proper validation
   - Add proper error handling

3. Fix CLI Implementation
   - Fix command handling
   - Fix output formatting
   - Add proper error handling
   - Implement missing functionality

4. Fix Core Functionality
   - Fix permutation expansion
   - Fix weighted prompts
   - Fix escape handling
   - Add proper validation

See TODO.md for detailed next steps and implementation plan.

## Dependencies []

All core dependencies are in place:
-  pydantic (>=2.0.0): Data validation
-  rich (>=13.0.0): CLI output formatting
-  fire (>=0.5.0): CLI interface
-  python-box (>=7.3.2): Dictionary operations
-  fal-client (>=0.5.8): Fal.ai integration

## Development Guidelines []

1. Type Safety []
   -  Full type hints
   -  Mypy validation
   -  Runtime type checking

2. Code Quality []
   -  Ruff for linting/formatting
   -  Pre-commit hooks
   -  Comprehensive docstrings

3. Testing []
   -  Pytest for testing
   -  Coverage reporting
   -  Fixing test failures
   - [ ] Benchmark tests

4. Documentation []
   -  Inline documentation
   - [ ] API documentation
   - [ ] Error handling guide

## Next Steps

See TODO.md for detailed next steps and future plans.

## Notes

- Core functionality is complete and working well
- CLI interface has been enhanced with no-color support and consistent formatting
- Need to focus on engine implementations next
- Consider adding more advanced features after engines
- Documentation needs expansion
- Performance optimization can wait until after engines
- Parameter handling has been improved with better type conversion and validation
```

## File: README.md (Size: 3.63 KB)

```
---
this_file: README.md
---

# Midjargon

`midjargon` is a powerful Python library designed to simplify the parsing and manipulation of Midjourney-style prompts. 

Midjourney uses a specialized syntax for prompts, which we call midjargon. It allows for `{}` permutation and for specifying of parameters using an `--` prefix. This syntax is useful for other applications, such as constructing prompts for Flux models. 

The `midjargon` package reads midjargon prompts, deconstructs them into manageable components, ensuring type-safe operations and comprehensive validation. It also converts midjargon prompts into other formats, such as Fal.ai, and serializes them back into the Midjourney format.

_Its work in progress, but already pretty usable._

## Features

- **Robust Prompt Parsing**:
  - Parses Midjourney prompts into structured components (text, parameters, image URLs)
  - Type-safe parsing with comprehensive validation
  - Supports complex prompt structures and syntax

- **Advanced Permutation Support**:
  - Handles nested permutations in curly braces `{option1, option2}`
  - Supports escaped characters in permutations (e.g., `\,` for literal commas)
  - Automatically expands all possible combinations

- **Comprehensive Parameter Handling**:
  - Validates parameter names and values
  - Supports numeric ranges and type conversion
  - Processes boolean flags and multi-value parameters

- **Image URL Processing**:
  - Extracts and validates image URLs
  - Supports multiple image inputs and file extensions

- **Multi-prompt Support**:
  - Handles weighted prompts using `::`
  - Processes multiple variations in a single input

- **Type Safety**:
  - Full type hints throughout the codebase
  - Pydantic models for robust validation

- **Rich CLI Interface**:
  - Fire-based command-line interface with rich output
  - CLI commands for converting prompts to different formats (Midjourney, Fal.ai)
  - JSON output option for automation

## Installation

```bash
pip install midjargon
```

## Quick Start

### Basic Usage

```python
from midjargon import parse_midjourney_dict, expand_midjargon_input

# Parse a simple prompt
prompt = "a serene landscape --ar 16:9 --stylize 100"
result = expand_midjargon_input(prompt)[0]
validated = parse_midjourney_dict(result)
```

### CLI Usage

Midjargon exposes a single CLI interface with multiple commands. Here are some examples:

```bash
# You can run the tool with uv without installing dependencies: 
uv run midjargon

# You can also run it directly: 
midjargon

# Or using your Python interpreter:
python -m midjargon
```

To get help on the commands: 

```bash
# Help for Fal.ai conversion (convert prompt to Fal.ai format)
midjargon fal --help

# Help for Midjourney conversion
midjargon mj --help

# Help for JSON parsing (MidjargonDict output)
midjargon json --help

# Help for permutation expansion
midjargon perm --help
```

You can also run commands directly:

```bash
# Convert prompt to Fal.ai format:
midjargon fal "a portrait of a cat --ar 1:1"

# Parse prompt to MidjargonDict:
midjargon json "a futuristic city --chaos 20 --stylize 200"

# Convert prompt to Midjourney format:
midjargon mj "a landscape --ar 16:9 --tile"

# Expand prompt permutations:
midjargon perm "a {red, blue} bird on a tree"
```

## Project Structure

TODO: Add a file tree

## Contributing

Contributions are welcome! Please submit a pull request with your changes.

### Development Setup

1. Clone the repository
2. Install dependencies:
   ```bash
   uv pip install --system --upgrade ".[all]"
   ```
3. Run tests:
   ```bash
   hatch test
   ```
4. Format code:
   ```bash
   hatch fmt
   ```

## License

MIT License - See LICENSE file for details
```

## File: TODO.md (Size: 4.34 KB)

```
---
this_file: TODO.md
---
# Midjargon Package Implementation Status

## Critical Issues (Priority 1)

1.  Fix Pydantic Model Implementation
   - [ ] Fix MidjourneyPrompt model
     - [ ] Add proper 'images' property getter/setter
     - [ ] Add proper 'parameters' property getter/setter
     - [ ] Fix model validation for all fields
     - [ ] Ensure proper type conversion in model fields
     - [ ] Fix character reference validation
     - [ ] Add proper model field documentation
   - [ ] Fix parameter type conversion
     - [ ] Ensure numeric parameters maintain correct types (int/float)
     - [ ] Fix version parameter validation (v4, v5, etc.)
     - [ ] Fix style reference parameter handling
     - [ ] Add proper validation for all parameter types
   - [ ] Fix model attribute access patterns
     - [ ] Implement proper __getattr__ handling
     - [ ] Fix model field access methods
     - [ ] Add proper validation error messages

2.  Fix Core Parser Issues
   - [ ] Fix parameter parsing
     - [ ] Fix quotation handling in parameters
     - [ ] Fix numeric parameter parsing
     - [ ] Fix flag parameter handling
     - [ ] Add proper error messages for parsing failures
   - [ ] Fix permutation expansion
     - [ ] Fix weighted prompt handling
     - [ ] Fix nested permutation groups
     - [ ] Fix whitespace handling in permutations
     - [ ] Add proper escape character handling
   - [ ] Fix input validation
     - [ ] Add proper input sanitization
     - [ ] Fix URL validation
     - [ ] Add proper error handling for invalid inputs

3.  Fix CLI Implementation
   - [ ] Fix command implementations
     - [ ] Fix 'json' command output formatting
     - [ ] Fix 'mj' command parameter handling
     - [ ] Fix 'fal' command implementation
     - [ ] Fix 'perm' command implementation
   - [ ] Fix output formatting
     - [ ] Fix JSON output structure
     - [ ] Fix permutation output format
     - [ ] Add proper error formatting
     - [ ] Ensure consistent output across all commands
   - [ ] Add proper error handling
     - [ ] Add descriptive error messages
     - [ ] Add proper error recovery
     - [ ] Add validation error formatting

## High Priority Tasks (Priority 2)

1.  Fix Engine Implementation
   - [ ] Fix MidjourneyParser
     - [ ] Fix initialization issues
     - [ ] Add proper parameter validation
     - [ ] Fix type conversion
     - [ ] Add proper reference handling
   - [ ] Fix FalParser
     - [ ] Fix initialization issues
     - [ ] Add proper parameter mapping
     - [ ] Fix type conversion
     - [ ] Add proper validation

2.  Fix Test Suite
   - [ ] Fix core functionality tests
     - [ ] Fix parameter parsing tests
     - [ ] Fix model validation tests
     - [ ] Fix permutation tests
     - [ ] Add missing edge cases
   - [ ] Fix CLI tests
     - [ ] Fix command tests
     - [ ] Fix output format tests
     - [ ] Add error handling tests
   - [ ] Fix integration tests
     - [ ] Fix workflow tests
     - [ ] Fix engine-specific tests
     - [ ] Add missing scenarios

## Medium Priority Tasks (Priority 3)

1.  Documentation Updates
   - [ ] Update API documentation
     - [ ] Document model attributes
     - [ ] Document parameter handling
     - [ ] Document CLI commands
   - [ ] Add error handling guide
     - [ ] Document common errors
     - [ ] Add troubleshooting steps
     - [ ] Add validation rules
   - [ ] Update examples
     - [ ] Add CLI usage examples
     - [ ] Add parameter examples
     - [ ] Add error handling examples

2.  Code Quality Improvements
   - [ ] Add proper type hints
   - [ ] Add proper docstrings
   - [ ] Fix linting issues
   - [ ] Add proper logging
   - [ ] Add proper error messages

## Low Priority Tasks (Priority 4)

1. Performance Optimization
   - [ ] Profile code for bottlenecks
   - [ ] Optimize permutation expansion
   - [ ] Improve memory usage
   - [ ] Add caching where beneficial

2. Additional Features
   - [ ] Add support for custom engines
   - [ ] Implement prompt templates
   - [ ] Add prompt validation rules
   - [ ] Create prompt optimization suggestions

## Dependencies
- pydantic (>=2.0.0)
- rich (>=13.0.0)
- fire (>=0.5.0)
- python-box (>=7.3.2)
- fal-client (>=0.5.8)

## Development Guidelines
1. Maintain type safety
2. Follow code quality standards
3. Add comprehensive tests
4. Keep documentation updated
5. Consider performance
6. Handle errors gracefully
```

## File: dist/.gitkeep (Size: 0.00 KB)

```

```

## File: docs/specification.md (Size: 15.07 KB)

```
---
this_file: docs/specification.md
---

# **Midjourney Prompt Format Specification**

_2025-02-06 by Adam Twardoch, not affiliated with Midjourney_

Midjourney prompts use midjargon, a structured syntax to instruct the Midjourney models to generate images. A prompt consists of three main sections, in order:

1. **Image Reference (Optional)**
2. **Text Description (Required if no image is provided)**
3. **Parameters (Optional)**

Each section has defined syntax and placement requirements. Advanced features such as multi-prompts with weights, permutation prompts, personalization, and style or character references are integrated into the text description and parameters.

Midjourney supports two distinct types of stylizations. The official Midjourney documentation often ambiguously calls both style: 

- Style reference
- Personalization

## Parameters

Parameters are modifiers appended at the end of the prompt that adjust various aspects of image generation. Parameters always begin with two hyphens `--` and may accept a value. The order of parameters (after the text description) is flexible.

Terms that follow a parameter `--a` are treated as its arguments (values). If `--a` is directly followed by another parameter `--b`, then `--a` is considered a boolean flag. 

---

## Choosing the model

### Midjourney series (`--v` or `--version`)

Uses the specified version of the general Midjourney model series. 

#### Syntax

```
--v <version_number>
```

#### Values

- `5`, `5.1`, `5.2`, `6`, `6.1`

> Example

```
--v 6
```

### Niji series (`--niji`)

Uses the specified version of the Niji model series, optimized for anime and illustrative styles.

#### Syntax

```
--niji <version_number>
```

- Values: `5`, `6`

> Example

```
--niji 6
```

### Model mode (`--style`)

Applies specific model mode. 

```
--style <mode_name>
```

- Mode name can be `raw`, it reduces automatic personalization.

> Example

```
--style raw
```

## Using images

### Image references

One or more direct image URLs or attachments used to influence the generated image's style, color, composition, and content.

Must appear at the very **start** of the prompt.

Each image can be:

- A direct image URL ending with `.png`, `.jpg`, `.jpeg`, `.gif`, or `.webp`.
- An attached image in Discord or uploaded via the Midjourney web interface.

Multiple images are separated by whitespace.

> Example

```
https://example.com/image1.jpg https://example.com/image2.png
```

#### Image weight (`--iw`)

`--iw <value>`

Adjusts the influence of all image references relative to the text prompt. 

- Value Range `0.0` to `3.0` (float)
- Default: `1.0` (varies by model)

> Example

```
--iw 1.5
```

As with other parameters, `--iw` must be placed after the text description, even though it refers to the image references that are placed at the very start of the prompt.

### Character reference (`--cref`)

`--cref <url1> [<url2> ...]`

Uses images as character references to maintain consistency.

#### Character weight (`--cw`)

Adjusts the strength of the character reference.

`--cw <value>`

- Value range: `0` to `100` (integer)
- Default: `100`

The character weight `0` typically only copies the face. 

> Example

```
--cref https://example.com/character.jpg --cw 50
```

### Style reference (`--sref`)

The `--sref` parameter uses images as style references without influencing content. It applies the visual characteristics of a specific images or stylization code. 

In effect, it pulls the generated image towards a specific look that is expressed explicitly (via the image) or less directly (via the stylization code).

```
--sref <url|code> [<url|code> ...]
```

One or more image URLs or a specific stylization CODE (the CODE acts as a shorthand for a predefined image reference)

#### Style weight (`--sw`)

Adjusts the strength of the style reference.

`--sw <value>`

- Value Range: `0` to `1000` (integer)

#### Style version (`--sv`)

Selects different style reference algorithms.

`--sv <value>`

- Values: `1`, `2`, `3`, `4`

> Example

```
--sref https://example.com/style.jpg --sw 200 --sv 2
```

#### Random style reference

`--sref random`

Generates a random style reference.

### Persona reference (`--p`)

References one or more personas, personalized style profiles, which pull the generated image towards the preferences or a general style of a particular user or moodboard, with the degree controlled by `--s`.

- Without specifying a persona code, `--p` uses your current personalization profile.
- Providing one or more persona codes of a personalization profile or moodboard (e.g., `--p p123456789`) applies a specific personalization.

#### Personalization weight (`--s`)

```
--stylize <value>
```

The `--s` (`--stylize`, or personalization weight) parameter controls the degree of personalization. 

- If a persona with a code is provided, the `--s` parameter controls how much the generated image will be pulled towards that persona.
- If the personalization switch is used (`--p`) without a code, the `--s` parameter controls how much the generated image will be pulled towards your current personalization profile.
- If the personalization switch is not used (no `--p` at all), the `--s` parameter controls how much the generated image will be pulled towards the models general persona (overall aesthetic preference).

- Value range: `0` to `1000` (integer)
- Default: `100`

The value of `0` applies minimal personalization, though certain influence of the model remains. To reduce the model influence, and have purer personalization use `--style raw` together with a low `--s` value.

> Example:

```
--p p123456789 --s 500 --style raw
```

## Describing the image

A natural language description of the desired image, specifying the subject, mood, style, and other artistic details.

### Clarity & specificity

Use specific adjectives, nouns, and phrases. Describe the subject, medium, environment, lighting, color, mood, and composition.

### Positive framing

Emphasize what should appear in the image rather than what should be excluded (exclusions are handled by the `--no` parameter).

### Tokenization

The text is internally tokenized; word order and precision are important.

### Text generation

Use double quotation marks `"` around words or phrases to specify exact text you want to appear in the image.

> Example

```
A neon sign that says "Open"
```

### Negative text description (`--no`)

Signals to the model elements or aspects that you dont want to see in the image. 

```
--no <item1, item2, ...>
```

- Value: Comma-separated list of terms

> Example:

```
--no cars, trees, watermarks
```

## Image layout

### Aspect ratio (`--ar`)

Sets the width-to-height ratio of the image

```
--ar <width>:<height>
```

- Value: Two integers separated by a colon
- Default: `1:1`

> Example:

```
--ar 16:9
```

### Tile (`--tile`)

Creates images that are seamlessly tileable

```
--tile
```

- Value: None (boolean flag)

> Example:

```
--tile
```

---

## Separating and prioritizing

Use a double colon `::` to separate concepts, optionally followed by a weight. If omitted, the weight defaults to 1.

```
concept1 ::<weight1> concept2 ::<weight2> ...
```

- Weight values can be floating-point numbers within the range `-10.0` to `10.0`.
- Negative weights (e.g., `::-0.5`) de-emphasize or exclude a concept.

### Purpose

This syntax allows you to balance and blend different concepts in one prompt. Weights are normalized internally to maintain their proportional relationships.

### Examples

```
futuristic city ::2 cyberpunk skyline ::1
beautiful landscape ::1.5 mountains ::-0.5 water
serene lake ::2 foggy mountains ::1
portrait ::1.5 dramatic lighting ::1 dark background ::0.8
still life painting ::1 fruit ::-0.5
```

---

## Variation

### Chaos (`--chaos` or `--c`)

Controls variation or unpredictability in the output

```
--chaos <value>
```

- Value range: `0` to `100` (integer)
- Default: `0`

> Example

```
--chaos 50
```

### Weird (`--weird` or `--w`)

Introduces unconventional aesthetics

```
--weird <value>
```

- Value range: `0` to `3000` (integer)
- Default: `0`

> Example

```
--weird 1000
```

---

## Generation process

### Seed (`--seed`)

Sets a specific seed to reproduce outcomes

```
--seed <value>
```

- Value range: `0` to `4294967295` (integer)

> Example:

```
--seed 123456789
```

### Prompt permutation

Prompt permutation allows you to quickly generate multiple prompts by including comma-separated options within curly braces `{}`. The surrounding fixed text is repeated with each provided option to create separate prompt variations.

Enclose a comma-separated list of options within curly braces. 

```
A {red, blue, green} car
```

This expands to 3 prompts:

- `A red car`
- `A blue car`
- `A green car`

Repeat permutations.

```
A {red, blue} {car, truck} with {chrome, matte} finish
```

This expands to 222=8 prompts. 

Permute parameters.

```
portrait --ar {1:1, 16:9} --s {100, 500, 1000}
```

This expands to 23=6 prompts. 

Nest permutations.

```
{realistic, artistic} scene --v {5.2, 6 {, --style raw}} 
```

This expands to 2(2+1)=6 prompts:

- `realistic scene --v 5.2`
- `realistic scene --v 6`
- `realistic scene --v 6 --style raw`
- `artistic scene --v 5.2`
- `artistic scene --v 6`
- `artistic scene --v 6 --style raw`

Within a permutation group, use commas to separate portions, prefix a comma with a backslash to actually have it in the expanded prompt.

```
A {bright\, vibrant, dark\, moody} atmosphere
```

This expands to 2 prompts:

- `A bright, vibrant atmosphere`
- `A dark, moody atmosphere`

The total number of permutations may be limited based on subscription tier. Permutation prompts are only available in Fast Mode.

Permutation is great for exploring various syntaxes and prompt structures: 

```
beautiful woman{::, ::2, ::0.3, \,} sports car
```

expands into

- `beautiful woman:: sports car`
- `beautiful woman::2 sports car`
- `beautiful woman::0.3 sports car`
- `beautiful woman, sports car`



### Repeat (`--repeat` or `--r`)

The `--r` parameter produces multiple prompts, similarly to prompt permutation, but the multiplication happens on the model side. It can be combined with permutation prompts.

If a prompt includes the `--r` parameter, the model runs the same prompt multiple times to generate variations. It can be used with `--sref random` to generate different style references each time. 

```
--repeat <number>
```

- Value range: Basic Subscribers: 24, Standard Subscribers: 210, Pro/Mega Subscribers: 240

> Example:

```
--repeat 5
```

## Quality and speed

### Quality (`--quality` or `--q`)

Controls the time spent generating an image; affects detail

```
--quality <value>
```

- Values: `0.25`, `0.5`, `1` (default)

> Example

```
--quality 0.5
```

#### Turbo Mode (`--turbo`)

Generates images faster using additional GPU resources

```
--turbo
```

- Value: None (boolean flag)

#### Relax Mode (`--relax`)

Generates images in relaxed mode without consuming GPU time

```
--relax
```

- Value: None (boolean flag)

### Stop (`--stop`)

Stops image generation at a specified percentage of completion for different artistic effects

```
--stop <value>
```

- Value range: `10` to `100` (integer)
- Default: `100`

> Example:

```
--stop 80
```

---

## Summary

- **Order matters**: Image prompts come first (if used), followed by the text description, and then all parameters.
- **Parameter prefix**: Every parameter starts with `--` and, if required, is followed by a space and its value.
- **Advanced techniques**: Use multi-prompts with `::` and permutation prompts with `{}` to fine-tune creative direction and generate multiple variations.
- **Personalization and references**: `--sw` controls the weight of the style reference (`--sref`). `--s` controls the weight of personalization (`--p`, or of the default persona when `--p` is not provided). Style reference and personalization operate independently: each pulls the image in a distinct stylistic direction. To test the full effect of style reference without personalization influence, use: `--style raw --s 0`.
- **Model and feature dependencies**: Some parameters (e.g., `--iw`, `--sv`, `--p`, permutation prompts) are model-specific or depend on the subscription tier or mode (e.g., Fast Mode).
- **Text generation**: Use double quotation marks `"` to specify exact text to appear in the image.

## Prompt examples

1. **Basic Text-Only Prompt:**

```
/imagine prompt: A serene sunset over the ocean
```

2. **Prompt with Image URLs, Text, and Parameters:**

```
/imagine prompt: https://example.com/inspiration.jpg A portrait of a wise old man --style raw --v 5.1
```

3. **Prompt with Character and Style References:**

```
/imagine prompt: A hero in battle --cref https://example.com/hero.png --cw 75 --sref https://example.com/style.jpg --sw 150
```

4. **Multi-Prompt with Weighting:**

```
/imagine prompt: futuristic city ::2 cyberpunk skyline ::1 --chaos 20
```

5. **Permutation Prompt for Multiple Variations:**

```
/imagine prompt: A {red, blue, green} bird on a {flower, leaf} --ar {16:9, 1:1}
```

6. **Prompt with Personalization and Parameters:**

```
/imagine prompt: A vibrant garden in spring --p p123456789 --stylize 500 --seed 987654321
```

7. **Complex Mixed Prompt:**

```
/imagine prompt: {realistic, artistic} portrait of a {young, old} {man, woman} --style {raw, expressive} --v 6 --ar 1:1 --stylize {100, 1000}
```

8. **Prompt with Exclusions and Turbo Mode:**

```
/imagine prompt: A futuristic landscape at dusk --ar 21:9 --stylize 300 --chaos 50 --seed 987654321 --no buildings, cars --turbo
```

---

## Notes for parser implementers

### Parsing order

1. **Permutation:**

- Process all permutation groups `{...}`.
- Handle nested permutations.
- Expand into individual prompts.
- `a{b, c}d` should expand to `abd` `acd`. The spaces right around the `{` and `}` should be treated as they are. Spaces around the separating commas can be collapsed fully, as if there is no space.
- `\{` `\}` `\,` must produce the literal `{` `}` `,` in the expanded permutations

2. **Image referece:**

- Identify and validate image URLs or attachments at the start.
- Check for supported file formats.
- Handle multiple images.

3. **Text description:**

- Extract main prompt text.
- Segment text by weight markers `::`.
- Handle escaped characters.
- Identify text in double quotes `"` for explicit text generation.

4. **Parameter Processing:**

- Extract parameters starting with `--`.
- Parse parameter values.
- Handle boolean flags.
- Validate parameter ranges.
- Values should be typically strings, unless its obviously an int or float. Version "number" should be kept a string.

### Boolean Parameters

- If a parameter is followed by another parameter (e.g., `--tile --ar 16:9`), it's treated as a boolean flag.

### Multi-Value Parameters

- Some parameters accept multiple values (e.g., `--no cars, trees`).

### Parameter Validation

- Numeric ranges are enforced.
- Aspect ratios must be valid integers.
- Version numbers must be supported.
- Style names and codes must be recognized.

### Error handling

The parser should handle common errors gracefully:

- Invalid URL formats.
- Malformed permutation syntax.
- Invalid parameter values.
- Missing required components.
- Unsupported parameter combinations.
```

## File: examples/basic_usage.py (Size: 2.75 KB)

```
#!/usr/bin/env python3
# this_file: examples/basic_usage.py

"""
Example script demonstrating basic usage of the midjargon package.
"""

from rich.console import Console
from rich.panel import Panel

from midjargon.core.input import expand_midjargon_input
from midjargon.core.parser import parse_midjargon_prompt

console = Console()


def main():
    # Example 1: Basic prompt parsing
    console.print("\n[bold blue]Example 1: Basic Prompt[/]")
    prompt = "a beautiful landscape --ar 16:9 --stylize 200"
    result = parse_midjargon_prompt(prompt)
    console.print(
        Panel(
            f"Text: {result.text}\n"
            f"Aspect Ratio: {result.parameters.aspect}\n"
            f"Stylize: {result.parameters.stylize}"
        )
    )

    # Example 2: Using image references
    console.print("\n[bold blue]Example 2: Image Reference[/]")
    prompt = "https://example.com/image.jpg a photo in this style --stylize 100"
    result = parse_midjargon_prompt(prompt)
    console.print(
        Panel(
            f"Text: {result.text}\n"
            f"Image URL: {result.images[0].url if result.images else 'None'}\n"
            f"Stylize: {result.parameters.stylize}"
        )
    )

    # Example 3: Permutations
    console.print("\n[bold blue]Example 3: Permutations[/]")
    prompt = "a {red, blue} bird on a {green, yellow} tree"
    variants = expand_midjargon_input(prompt)
    for i, variant in enumerate(variants, 1):
        console.print(f"Variant {i}: {variant.prompt.text}")

    # Example 4: Weighted prompts
    console.print("\n[bold blue]Example 4: Weighted Prompts[/]")
    prompt = "first style::0.7 second style::0.3"
    variants = expand_midjargon_input(prompt)
    for variant in variants:
        console.print(Panel(f"Text: {variant.prompt.text}\nWeight: {variant.weight}"))

    # Example 5: Style references
    console.print("\n[bold blue]Example 5: Style References[/]")
    prompt = "test --sref p123456 --sw 200"
    result = parse_midjargon_prompt(prompt)
    if result.parameters.style_reference:
        console.print(
            Panel(
                f"Text: {result.text}\n"
                f"Style Code: {result.parameters.style_reference.code}\n"
                f"Weight: {result.parameters.style_reference.weight}"
            )
        )

    # Example 6: Combined features
    console.print("\n[bold blue]Example 6: Combined Features[/]")
    prompt = "a {vintage, modern} {portrait, landscape}::0.6 another style::0.4"
    variants = expand_midjargon_input(prompt)
    console.print(f"Total variants: {len(variants)}")
    for i, variant in enumerate(variants, 1):
        console.print(
            Panel(
                f"Variant {i}:\nText: {variant.prompt.text}\nWeight: {variant.weight}"
            )
        )


if __name__ == "__main__":
    main()
```

## File: package.toml (Size: 0.43 KB)

```
# Package configuration
# this_file: package.toml
[package]
include_cli = true      # Include CLI boilerplate
include_logging = true  # Include logging setup
use_pydantic = true     # Use Pydantic for data validation
use_rich = true         # Use Rich for terminal output

[features]
mkdocs = false          # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows
```

## File: pyproject.toml (Size: 5.08 KB)

```
# this_file: pyproject.toml
[project]
classifiers = [
  "Development Status :: 4 - Beta",
  "Programming Language :: Python",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
  "Programming Language :: Python :: Implementation :: CPython",
  "Programming Language :: Python :: Implementation :: PyPy",
]
description = ""
dynamic = ["version"]
keywords = []
license = "MIT"
name = "midjargon"
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
  "pydantic>=2.0.0",
  "rich>=13.0.0",
  "fire>=0.5.0",
  "python-box>=7.3.2",
  "fal-client>=0.5.8",
]

[project.optional-dependencies]
all = [
  "pre-commit>=3.6.0",
  "ruff>=0.1.0",
  "mypy>=1.0.0",
  "pytest>=7.0.0",
  "pytest-cov>=4.0.0","pyupgrade>=3.19.0"
]
dev = ["pre-commit>=3.6.0", "ruff>=0.1.0", "mypy>=1.0.0", "pyupgrade>=3.19.0"]
test = ["pytest>=7.0.0", "pytest-cov>=4.0.0"]

[project.scripts]
midjargon = "midjargon.__main__:main"

[[project.authors]]
email = "adam+github@twardoch.com"
name = "Adam Twardoch"


[project.urls]
Documentation = "https://github.com/twardoch/midjargon#readme"
Issues = "https://github.com/twardoch/midjargon/issues"
Source = "https://github.com/twardoch/midjargon"

[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.21.0", "hatch-vcs>=0.3.0"
  ]


[tool.coverage.paths]
midjargon = ["src/midjargon", "*/midjargon/src/midjargon"]
tests = ["tests", "*/midjargon/tests"]


[tool.coverage.report]
exclude_lines = ["no cov", "if __name__ == .__main__.:", "if TYPE_CHECKING:"]


[tool.coverage.run]
branch = true
omit = ["src/midjargon/__about__.py"]
parallel = true
source_pkgs = ["midjargon", "tests"]


[tool.hatch.build.hooks.vcs]
version-file = "src/midjargon/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/midjargon"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.default]
dependencies = ["pytest", "pytest-cov", "mypy>=1.0.0", "ruff>=0.1.0"]

[tool.hatch.envs.default.scripts]
lint = ["ruff check src/midjargon tests", "ruff format src/midjargon tests"]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/midjargon --cov=tests {args:tests}"
type-check = "mypy src/midjargon tests"

[tool.hatch.envs.lint]
dependencies = ["mypy>=1.0.0", "ruff>=0.1.0"]
detached = true

[tool.hatch.envs.lint.scripts]
all = ["style", "typing"]
fmt = ["fd -e py -x pyupgrade --keep-runtime-typing --py310-plus", "ruff format {args:.}", "ruff check --fix --unsafe-fixes {args:.}"]
style = ["fd -e py -x pyupgrade --keep-runtime-typing --py310-plus", "ruff format {args:.}", "ruff check --fix --unsafe-fixes {args:.}", "ruff format {args:.}"]
typing = "mypy --install-types --non-interactive {args:src/midjargon tests}"

[tool.hatch.envs.test]
dependencies = [
  "pytest>=7.0.0",
  "pytest-cov>=4.0.0",
  "midjargon[test]",
]

[tool.hatch.envs.test.scripts]
test = "pytest --cov=src/midjargon --cov-report=term-missing --cov-branch --no-cov-on-fail {args:tests}"
test-cov = "pytest --cov=src/midjargon --cov-report=term-missing --cov-branch --no-cov-on-fail {args:tests}"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
python_version = "3.10"
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = ["ignore::DeprecationWarning", "ignore::UserWarning"]
log_cli = true
log_cli_level = "INFO"
markers = [
  "benchmark: marks tests as benchmarks (select with '-m benchmark')",
  "unit: mark a test as a unit test",
  "integration: mark a test as an integration test",
  "permutation: tests for permutation functionality",
  "parameter: tests for parameter parsing",
  "prompt: tests for prompt parsing",
]
norecursedirs = [
  ".*",
  "build",
  "dist",
  "venv",
  "__pycache__",
  "*.egg-info",
  "_private",
]

python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
] 

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
  "A",
  "ARG",
  "B",
  "C",
  "DTZ",
  "E",
  "EM",
  "F",
  "FBT",
  "I",
  "ICN",
  "ISC",
  "N",
  "PLC",
  "PLE",
  "PLR",
  "PLW",
  "Q",
  "RUF",
  "S",
  "T",
  "TID",
  "UP",
  "W",
  "YTT",
]
ignore = ["ARG001", "E501", "I001", "RUF001", "PLR2004", "EXE003", "ISC001"]

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101"]
```

## File: src/midjargon/__init__.py (Size: 0.58 KB)

```
# this_file: src/midjargon/__init__.py
"""
midjargon

A Python library for parsing and manipulating Midjourney prompts.
"""

__version__ = "0.1.0"

from midjargon.core.input import expand_midjargon_input
from midjargon.core.models import MidjourneyPrompt, PromptVariant
from midjargon.core.parser import parse_midjargon_prompt_to_dict
from midjargon.engines.midjourney import MidjourneyParser, parse_midjourney_dict

__all__ = [
    "MidjourneyParser",
    "MidjourneyPrompt",
    "PromptVariant",
    "expand_midjargon_input",
    "parse_midjargon_prompt_to_dict",
    "parse_midjourney_dict",
]
```

## File: src/midjargon/cli/__init__.py (Size: 0.04 KB)

```
# this_file: src/midjargon/cli/__init__.py
```

## File: src/midjargon/cli/main.py (Size: 4.90 KB)

```
#!/usr/bin/env -S uv run
# this_file: src/midjargon/cli/main.py
# /// script
# dependencies = ["fire", "rich"]
# ///

import sys
from typing import Any
from collections.abc import Sequence

import fire
from rich.console import Console

from midjargon.core.input import expand_midjargon_input
from midjargon.core.models import PromptVariant
from midjargon.engines.fal import FalParser
from midjargon.engines.midjourney import MidjourneyParser

# Set up console for output
console = Console()
error_console = Console(stderr=True)


def format_json_output(variants: Sequence[PromptVariant]) -> list[dict[str, Any]]:
    """Format variants as JSON output."""
    return [variant.prompt.model_dump() for variant in variants]


def format_rich_output(variants: Sequence[PromptVariant]) -> str:
    """Format variants as rich text output."""
    if len(variants) == 1:
        return variants[0].prompt.to_string()
    return "\n".join(f"{i + 1}. {v.prompt.to_string()}" for i, v in enumerate(variants))


class MidjargonCLI:
    """CLI interface for midjargon."""

    def json(self, prompt: str, no_color: bool = False) -> None:
        """Parse a prompt to MidjargonDict format.

        Args:
            prompt: The prompt to parse.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            format_json_output(variants)
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.

        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
                mj_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(mj_prompt.model_dump())

            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    params = " ".join(
                        f"--{k} {v}"
                        for k, v in result.items()
                        if k not in {"text", "image_prompts", "extra_params"}
                        and v is not None
                    )
                    console.print(
                        f"{result['text']} {params}",
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.

        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())

            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)

    def perm(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Expand permutations in a prompt.

        Args:
            prompt: The prompt to expand.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            if json_output:
                format_json_output(variants)
            else:
                pass
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)


def main() -> None:
    """Main entry point."""
    try:
        fire.Fire(MidjargonCLI)
    except Exception as e:
        error_console.print(f"[red]Error:[/red] {e!s}")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

## File: src/midjargon/core/__init__.py (Size: 0.04 KB)

```
# this_file: src/midjargon/core/__init__.py
```

## File: src/midjargon/core/input.py (Size: 2.59 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/input.py

from midjargon.core.models import MidjourneyPrompt, PromptVariant
from midjargon.core.permutations import expand_permutations


def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
    """Parse a prompt with optional weights.

    Args:
        prompt: Raw prompt string with optional weights.

    Returns:
        List of (prompt, weight) tuples.

    Raises:
        ValueError: If prompt is empty or invalid.
    """
    if not prompt or not prompt.strip():
        msg = "Empty prompt"
        raise ValueError(msg)

    # Split on double colon and parse weights
    result = []
    current_prompt = []
    i = 0

    while i < len(prompt):
        if prompt[i : i + 2] == "::" and (i == 0 or prompt[i - 1] != "\\"):
            # Found weight separator
            text = "".join(current_prompt).strip()
            if not text:
                msg = "Empty prompt before weight"
                raise ValueError(msg)

            # Parse weight
            i += 2
            weight_start = i
            while i < len(prompt) and (prompt[i].isdigit() or prompt[i] == "."):
                i += 1

            if i == weight_start:
                msg = f"Missing weight after :: at position {i - 2}"
                raise ValueError(msg)

            try:
                weight = float(prompt[weight_start:i])
                if weight <= 0:
                    msg = f"Weight must be positive at position {weight_start}"
                    raise ValueError(msg)
            except ValueError as e:
                msg = f"Invalid weight at position {weight_start}: {prompt[weight_start:i]}"
                raise ValueError(msg) from e

            result.append((text, weight))
            current_prompt = []
        else:
            current_prompt.append(prompt[i])
            i += 1

    # Handle last part
    if current_prompt:
        text = "".join(current_prompt).strip()
        if text:
            result.append((text, 1.0))  # Default weight

    if not result:
        msg = "Empty prompt"
        raise ValueError(msg)

    return result


def expand_midjargon_input(prompt: str) -> list[PromptVariant]:
    """Expand a midjourney prompt by processing permutations and returning a list of prompt variants.

    Args:
        prompt: The prompt string to expand.

    Returns:
        A list of PromptVariant objects, each containing an expanded prompt.
    """
    permutation_options = expand_permutations(prompt)
    return [
        PromptVariant(prompt=MidjourneyPrompt(text=opt), weight=1.0)
        for opt in permutation_options
    ]
```

## File: src/midjargon/core/main.py (Size: 1.50 KB)

```
# this_file: src/midjargon/core/main.py

from typing import Any

from midjargon.core.models import PromptVariant


def format_json_output(
    variants: list[PromptVariant], include_parsed: bool = False
) -> dict[str, Any]:
    """Format prompt variants as JSON output.

    Args:
        variants: List of prompt variants to format.
        include_parsed: Whether to include parsed data in output.

    Returns:
        Dictionary containing formatted output.
    """
    if not variants:
        return {}

    # For single variants without weights, return simple format
    if len(variants) == 1 and variants[0].weight == 1.0:
        variant = variants[0].prompt
        result = {
            "text": variant.text,
            "images": [str(img.url) for img in variant.images],
            "parameters": variant.parameters.model_dump(exclude_none=True),
        }
        if include_parsed:
            result["parsed"] = variant.model_dump(exclude_none=True)
        return result

    # For multiple variants or weighted variants, return array format
    results = []
    for variant in variants:
        prompt = variant.prompt
        result = {
            "text": prompt.text,
            "images": [str(img.url) for img in prompt.images],
            "parameters": prompt.parameters.model_dump(exclude_none=True),
            "weight": variant.weight,
        }
        if include_parsed:
            result["parsed"] = prompt.model_dump(exclude_none=True)
        results.append(result)
    return {"variants": results}
```

## File: src/midjargon/core/models.py (Size: 8.35 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/models.py

from enum import Enum
from typing import Any, Optional

from pydantic import (
    BaseModel,
    Field,
    HttpUrl,
    ValidationInfo,
    computed_field,
    field_validator,
)


class MidjourneyVersion(str, Enum):
    """Midjourney model version."""

    V4 = "v4"
    V5 = "v5"
    V5_1 = "v5.1"
    V5_2 = "v5.2"
    V6 = "v6"
    V6_1 = "v6.1"
    NIJI4 = "niji4"
    NIJI5 = "niji5"
    NIJI6 = "niji6"

    @classmethod
    def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
        """Handle missing values by trying to normalize the input."""
        try:
            # Try to normalize version string
            value = str(value).lower().strip()

            # Handle numeric versions (e.g., 4, 5, 6)
            if value.replace(".", "").isdigit():
                if "." not in value:
                    value = f"v{value}"
                else:
                    value = f"v{value}"

            # Handle niji versions
            if value == "niji":
                return cls.NIJI6
            if value.startswith("niji"):
                for member in cls:
                    if member.value == value:
                        return member
                return cls.NIJI6

            # Handle v prefix
            if not value.startswith("v") and not value.startswith("niji"):
                value = f"v{value}"

            # Try exact match first
            for member in cls:
                if member.value == value:
                    return member

            # Try prefix match for v* versions
            if value.startswith("v"):
                base_version = value.split(".")[0]
                latest_version = None
                for member in cls:
                    if member.value.startswith(base_version):
                        if (
                            latest_version is None
                            or member.value > latest_version.value
                        ):
                            latest_version = member
                if latest_version:
                    return latest_version

            return None
        except:
            return None


class StyleMode(str, Enum):
    """Available style modes."""

    RAW = "raw"
    CUTE = "cute"
    EXPRESSIVE = "expressive"
    SCENIC = "scenic"
    ORIGINAL = "original"


class ImageReference(BaseModel):
    """Reference to an image."""

    url: HttpUrl
    weight: float = 1.0


class CharacterReference(BaseModel):
    """Reference to a character."""

    url: HttpUrl | None = None
    weight: float = 1.0
    code: str | None = None


class StyleReference(BaseModel):
    """Reference to a style."""

    url: HttpUrl | None = None
    weight: float = 1.0
    code: str | None = None


class MidjourneyParameters(BaseModel):
    """Parameters for a Midjourney prompt."""

    version: MidjourneyVersion | None = None
    style: StyleMode | None = None
    stylize: int = 100
    chaos: int = 0
    weird: int = 0
    seed: int | str | None = None
    aspect: str = "1:1"
    tile: bool = False
    turbo: bool = False
    relax: bool = False
    no: list[str] = Field(default_factory=list)
    character_reference: list[CharacterReference] = Field(default_factory=list)
    style_reference: list[StyleReference] = Field(default_factory=list)

    @field_validator("aspect")
    @classmethod
    def validate_aspect(cls, v: str) -> str:
        """Validate aspect ratio format."""
        try:
            w, h = map(int, v.split(":"))
            if w <= 0 or h <= 0:
                raise ValueError
            return f"{w}:{h}"
        except:
            msg = "Invalid aspect ratio format. Expected W:H"
            raise ValueError(msg)

    @field_validator("stylize")
    @classmethod
    def validate_stylize(cls, v: int) -> int:
        """Validate stylize value."""
        if not 0 <= v <= 1000:
            msg = f"Stylize value must be between 0 and 1000, got {v}"
            raise ValueError(msg)
        return v

    @field_validator("chaos")
    @classmethod
    def validate_chaos(cls, v: int) -> int:
        """Validate chaos value."""
        if not 0 <= v <= 100:
            msg = f"Chaos value must be between 0 and 100, got {v}"
            raise ValueError(msg)
        return v

    @field_validator("weird")
    @classmethod
    def validate_weird(cls, v: int) -> int:
        """Validate weird value."""
        if not 0 <= v <= 3000:
            msg = f"Weird value must be between 0 and 3000, got {v}"
            raise ValueError(msg)
        return v


class MidjourneyPrompt(BaseModel):
    """A complete Midjourney prompt."""

    text: str
    image_prompts: list[HttpUrl] = Field(default_factory=list)
    stylize: float = Field(default=100, ge=0, le=1000)
    chaos: float = Field(default=0, ge=0, le=100)
    weird: float = Field(default=0, ge=0, le=3000)
    image_weight: float = Field(default=1.0, ge=0, le=2.0)
    seed: int | None = None
    stop: float = Field(default=100, ge=0, le=100)
    aspect_width: int | None = None
    aspect_height: int | None = None
    aspect_ratio: str | None = None
    style: StyleMode | None = None
    version: MidjourneyVersion | None = None
    personalization: bool = False
    quality: float = Field(default=1.0, ge=0.25, le=2.0)
    character_reference: list[CharacterReference] = Field(default_factory=list)
    character_weight: float = Field(default=100, ge=0, le=100)
    style_reference: list[StyleReference] = Field(default_factory=list)
    style_weight: float | None = Field(default=None, ge=0, le=100)
    style_version: int = Field(default=2, ge=1, le=3)
    repeat: int | None = None
    turbo: bool = False
    relax: bool = False
    tile: bool = False
    negative_prompt: str | None = None
    extra_params: dict[str, Any] = Field(default_factory=dict)

    @field_validator("aspect_ratio")
    @classmethod
    def validate_aspect_ratio(cls, v: str | None, info: ValidationInfo) -> str | None:
        """Validate aspect ratio format."""
        if v is not None:
            try:
                w, h = map(int, v.split(":"))
                if w <= 0 or h <= 0:
                    msg = "Invalid aspect ratio: values must be positive"
                    raise ValueError(msg)
                info.data["aspect_width"] = w
                info.data["aspect_height"] = h
            except ValueError as e:
                msg = f"Invalid aspect ratio format: {e}"
                raise ValueError(msg)
        return v

    @computed_field
    def images(self) -> list[HttpUrl]:
        """Get image URLs."""
        return self.image_prompts

    @property
    def parameters(self) -> MidjourneyParameters:
        """Get all parameters as a MidjourneyParameters object."""
        exclude = {"text", "image_prompts", "extra_params", "images", "parameters"}
        params = {}
        for field_name, field in self.model_fields.items():
            if field_name not in exclude:
                value = getattr(self, field_name)
                if value is not None and value != field.default:
                    if field_name == "character_reference" and not value:
                        continue
                    if field_name == "style_reference" and not value:
                        continue
                    params[field_name] = value
        return MidjourneyParameters(**params)

    def to_string(self) -> str:
        """Convert prompt to string format."""
        parts = [self.text]

        # Add image prompts
        for url in self.image_prompts:
            parts.append(str(url))

        # Add parameters
        params = []
        for field, value in self.parameters.model_dump().items():
            if value is None:
                continue
            if isinstance(value, bool) and value:
                params.append(f"--{field}")
            elif isinstance(value, list) and value:
                for v in value:
                    params.append(f"--{field} {v}")
            else:
                params.append(f"--{field} {value}")

        # Add extra parameters
        for key, value in self.extra_params.items():
            if value is None:
                params.append(f"--{key}")
            else:
                params.append(f"--{key} {value}")

        if params:
            parts.append(" ".join(params))

        return " ".join(parts)


class PromptVariant(BaseModel):
    """A variant of a prompt with weight."""

    prompt: MidjourneyPrompt
    weight: float = 1.0
```

## File: src/midjargon/core/parameters.py (Size: 6.60 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/parameters.py

import shlex
from typing import Any
from urllib.parse import urlparse

from pydantic import HttpUrl

from midjargon.core.models import (
    CharacterReference,
    MidjourneyVersion,
    StyleMode,
    StyleReference,
)

# Parameter aliases mapping
ALIASES = {
    # Version aliases
    "v": "version",
    "ver": "version",
    "niji": "version",
    # Style aliases
    "s": "stylize",
    # Chaos aliases
    "c": "chaos",
    # Weird aliases
    "w": "weird",
    # Seed aliases
    "sameseed": "seed",
    # Aspect ratio aliases
    "ar": "aspect",
    # Character reference aliases
    "cref": "character_reference",
    # Style reference aliases
    "sref": "style_reference",
    # Character weight aliases
    "cw": "character_weight",
    # Style weight aliases
    "sw": "style_weight",
    # Style version aliases
    "sv": "style_version",
    # Personalization aliases
    "p": "personalization",
}

# Parameters that can have multiple values
MULTI_VALUE_PARAMS = {"no", "character_reference", "style_reference"}

# Parameters that are flags (no value needed)
FLAG_PARAMS = {"tile", "turbo", "relax", "fast", "video", "personalization"}

# Parameters that should remain as strings
STRING_PARAMS = {"aspect", "negative_prompt"}

# Parameters that should be integers
INT_PARAMS = {"seed", "style_version", "repeat"}


def is_url(value: str) -> bool:
    """Check if a string is a valid URL."""
    try:
        result = urlparse(value)
        return all([result.scheme, result.netloc])
    except:
        return False


def convert_parameter_value(param: str, value: str | None) -> Any:
    """Convert a parameter value to the appropriate type."""
    # Handle flag parameters
    if param in FLAG_PARAMS:
        return True if value is None else value.lower() == "true"

    # Handle empty values
    if value is None:
        return None

    # Handle string parameters
    if param in STRING_PARAMS:
        return str(value)

    # Handle version parameter
    if param == "version":
        try:
            return MidjourneyVersion(value)
        except ValueError:
            msg = f"Invalid version value: {value}"
            raise ValueError(msg)

    # Handle integer parameters
    if param in INT_PARAMS:
        try:
            return int(value)
        except ValueError:
            msg = f"Invalid integer value for {param}: {value}"
            raise ValueError(msg)

    # Handle float parameters
    if param in {
        "stylize",
        "chaos",
        "weird",
        "quality",
        "character_weight",
        "style_weight",
        "image_weight",
        "stop",
    }:
        try:
            return float(value)
        except ValueError:
            msg = f"Invalid numeric value for {param}: {value}"
            raise ValueError(msg)

    # Handle style parameter
    if param == "style":
        try:
            return StyleMode(value)
        except ValueError:
            msg = f"Invalid style value: {value}"
            raise ValueError(msg)

    # Handle character and style references
    if param in {"character_reference", "style_reference"}:
        ref_class = (
            CharacterReference if param == "character_reference" else StyleReference
        )
        try:
            if is_url(value):
                return ref_class(url=HttpUrl(value), weight=1.0)
            else:
                # Handle reference codes (e.g., p123456)
                return ref_class(
                    url=HttpUrl(f"https://example.com/{value}"), code=value, weight=1.0
                )
        except Exception:
            msg = f"Invalid reference value for {param}: {value}"
            raise ValueError(msg)

    # Default case: return as string
    return value


def parse_parameters(param_str: str) -> dict[str, Any]:
    """Parse parameters from a string into a dictionary."""
    if not param_str:
        return {}

    # Split parameters while preserving quoted strings
    try:
        parts = shlex.split(param_str)
    except ValueError as e:
        msg = f"Failed to parse parameters: {e}"
        raise ValueError(msg)

    result: dict[str, Any] = {}
    current_param = None
    current_values = []

    for part in parts:
        if part.startswith("--"):
            # Store previous parameter if exists
            if current_param:
                try:
                    if current_param in MULTI_VALUE_PARAMS:
                        # Handle multi-value parameters
                        values = (
                            [
                                convert_parameter_value(current_param, v)
                                for v in current_values
                            ]
                            if current_values
                            else [True]
                        )
                        if current_param in result:
                            result[current_param].extend(values)
                        else:
                            result[current_param] = values
                    else:
                        # Handle single value parameters
                        value = convert_parameter_value(
                            current_param, current_values[0] if current_values else None
                        )
                        result[current_param] = value
                except Exception as e:
                    msg = f"Failed to parse parameter {current_param}: {e}"
                    raise ValueError(msg)

            # Start new parameter
            current_param = ALIASES.get(
                part[2:], part[2:]
            )  # Remove -- and resolve alias
            current_values = []
        elif current_param:
            current_values.append(part)
        else:
            msg = f"Unexpected value without parameter: {part}"
            raise ValueError(msg)

    # Handle last parameter
    if current_param:
        try:
            if current_param in MULTI_VALUE_PARAMS:
                values = (
                    [convert_parameter_value(current_param, v) for v in current_values]
                    if current_values
                    else [True]
                )
                if current_param in result:
                    result[current_param].extend(values)
                else:
                    result[current_param] = values
            else:
                value = convert_parameter_value(
                    current_param, current_values[0] if current_values else None
                )
                result[current_param] = value
        except Exception as e:
            msg = f"Failed to parse parameter {current_param}: {e}"
            raise ValueError(msg)

    return result
```

## File: src/midjargon/core/parser.py (Size: 4.92 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/parser.py

from typing import Any
from urllib.parse import urlparse

from pydantic import HttpUrl

from midjargon.core.models import CharacterReference, MidjourneyPrompt, StyleReference


def is_valid_image_url(url: str) -> bool:
    """Check if a URL is a valid image URL."""
    try:
        result = urlparse(url)
        return bool(
            result.scheme
            and result.netloc
            and any(
                result.path.lower().endswith(ext)
                for ext in [".jpg", ".jpeg", ".png", ".gif", ".webp"]
            )
        )
    except:
        return False


def is_url(text: str) -> bool:
    """Check if text is a URL."""
    try:
        result = urlparse(text)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False


def extract_image_urls(prompt: str) -> tuple[list[HttpUrl], str]:
    """Extract image URLs from the start of a prompt.

    Args:
        prompt: The raw prompt string.

    Returns:
        A tuple of (list of image URLs, remaining text).
    """
    parts = prompt.strip().split()
    urls = []
    text_start = 0

    for i, part in enumerate(parts):
        if is_url(part):
            urls.append(HttpUrl(part))
            text_start = i + 1
        else:
            break

    return urls, " ".join(parts[text_start:])


def parse_parameters(param_str: str) -> dict[str, Any]:
    """Parse parameter string into a dictionary.

    Args:
        param_str: The parameter string to parse.

    Returns:
        Dictionary of parameter names and values.

    Raises:
        ValueError: If parameter parsing fails.
    """
    params: dict[str, Any] = {}

    # Split into individual parameters
    parts = param_str.split("--")
    for part in parts[1:]:  # Skip empty first part
        if not part.strip():
            continue

        # Split parameter name and value
        param_parts = part.strip().split(maxsplit=1)
        param_name = param_parts[0]
        param_value = param_parts[1] if len(param_parts) > 1 else None

        # Handle special parameters
        if param_name == "cref":
            if param_value:
                if is_url(param_value):
                    params.setdefault("character_reference", []).append(
                        CharacterReference(url=HttpUrl(param_value), code=None)
                    )
                else:
                    params.setdefault("character_reference", []).append(
                        CharacterReference(url=None, code=param_value)
                    )
        elif param_name == "sref":
            if param_value:
                if is_url(param_value):
                    params.setdefault("style_reference", []).append(
                        StyleReference(url=HttpUrl(param_value), code=None)
                    )
                else:
                    params.setdefault("style_reference", []).append(
                        StyleReference(url=None, code=param_value)
                    )
        # Handle regular parameters
        elif param_value is None:
            params[param_name] = True
        else:
            try:
                # Try to convert to number
                if "." in param_value:
                    params[param_name] = float(param_value)
                else:
                    params[param_name] = int(param_value)
            except ValueError:
                params[param_name] = param_value

    return params


def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
    """Parse a Midjourney prompt into a validated MidjourneyPrompt object.

    Args:
        prompt: The raw prompt string to parse.

    Returns:
        A validated MidjourneyPrompt object.

    Raises:
        ValueError: If the prompt is invalid or missing required components.
    """
    # Extract image URLs
    images, remaining_text = extract_image_urls(prompt)

    # Split into text and parameters
    if " --" in remaining_text:
        text_part, param_part = remaining_text.split(" --", 1)
        text_part = text_part.strip()
        param_str = "--" + param_part.strip()
        try:
            parameters = parse_parameters(param_str)
        except Exception as e:
            msg = f"Failed to parse parameters: {e!s}"
            raise ValueError(msg)
    else:
        text_part = remaining_text.strip()
        parameters = {}

    # Create and validate the prompt object
    try:
        return MidjourneyPrompt(
            text=text_part,
            image_prompts=images,
            **parameters,
        )
    except Exception as e:
        msg = f"Failed to create prompt object: {e!s}"
        raise ValueError(msg)


def parse_midjargon_prompt_to_dict(prompt: str) -> dict[str, Any]:
    """Parse a Midjourney prompt into a dictionary.

    Args:
        prompt: The raw prompt string to parse.

    Returns:
        Dictionary representation of the prompt.
    """
    parsed = parse_midjargon_prompt(prompt)
    return parsed.model_dump()
```

## File: src/midjargon/core/permutations.py (Size: 3.63 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/permutations.py


def find_unescaped(s: str, char: str, start: int = 0) -> int:
    """Find the next unescaped occurrence of a character.

    Args:
        s: String to search in.
        char: Character to find.
        start: Starting position for search.

    Returns:
        Index of the first unescaped occurrence, or -1 if not found.
    """
    i = start
    while i < len(s):
        if s[i] == "\\":
            i += 2  # Skip escaped character
            continue
        if s[i] == char:
            return i
        i += 1
    return -1


def split_unescaped(s: str, delimiter: str = ",") -> list[str]:
    """Split string on unescaped delimiters and handle escapes.

    Args:
        s: String to split.
        delimiter: Character to split on.

    Returns:
        List of substrings.
    """
    parts = []
    current = []
    i = 0

    while i < len(s):
        if s[i] == "\\":
            if i + 1 < len(s):
                current.append(s[i + 1])  # Keep escaped character
                i += 2
            else:
                current.append(s[i])  # Keep trailing backslash
                i += 1
        elif s[i] == delimiter:
            parts.append("".join(current).strip())
            current = []
            i += 1
        else:
            current.append(s[i])
            i += 1

    if current:
        parts.append("".join(current).strip())

    return parts


def find_matching_brace(s: str, start: int) -> tuple[int, str]:
    """Find matching closing brace and extract error message if any.

    Args:
        s: String to search in.
        start: Position of opening brace.

    Returns:
        Tuple of (position of closing brace, error message).
        Position will be -1 if no match found.
    """
    count = 1
    i = start + 1

    while i < len(s):
        if s[i] == "\\":
            i += 2
            continue
        if s[i] == "{":
            count += 1
        elif s[i] == "}":
            count -= 1
            if count == 0:
                return i, ""
        i += 1

    if count > 0:
        return -1, f"Unclosed brace at position {start}"
    return -1, "Invalid brace structure"


def expand_permutations(s: str) -> list[str]:
    """Recursively expand permutations in the prompt string using {a, b, ...} syntax.

    Handles:
    - Nested permutation groups
    - Escaped characters (\\, \\{, \\}, \\,)
    - Proper error reporting

    Args:
        s: String containing permutation groups.

    Returns:
        List of all possible permutations.

    Raises:
        ValueError: If the permutation syntax is invalid.
    """
    # Find first unescaped opening brace
    start = find_unescaped(s, "{")
    if start == -1:
        return [s]

    # Find matching closing brace
    end, error = find_matching_brace(s, start)
    if end == -1:
        raise ValueError(error)

    # Extract and split options
    options_str = s[start + 1 : end]
    try:
        options = split_unescaped(options_str)
    except Exception as e:
        msg = f"Failed to parse options at position {start}: {e!s}"
        raise ValueError(msg)

    if not options:
        msg = f"Empty permutation group at position {start}"
        raise ValueError(msg)

    # Recursively expand each option
    results = []
    prefix = s[:start]
    suffix = s[end + 1 :]

    for option in options:
        # Replace the entire '{...}' with the option
        new_s = prefix + option + suffix
        try:
            results.extend(expand_permutations(new_s))
        except Exception as e:
            msg = f"Failed to expand option '{option}': {e!s}"
            raise ValueError(msg)

    return results
```

## File: src/midjargon/engines/__init__.py (Size: 0.05 KB)

```
# this_file: src/midjargon/engines/__init__.py
```

## File: src/midjargon/engines/fal/__init__.py (Size: 0.20 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/fal/__init__.py

from midjargon.engines.fal.fal import FalParser, FalPrompt, parse_fal_dict

__all__ = ["FalParser", "FalPrompt", "parse_fal_dict"]
```

## File: src/midjargon/engines/fal/fal.py (Size: 3.27 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/fal/fal.py

from typing import Any

from pydantic import BaseModel, HttpUrl, computed_field


class FalPrompt(BaseModel):
    """Fal.ai prompt model with all parameters."""

    text: str
    image_prompts: list[HttpUrl] = []
    negative_prompt: str | None = None
    num_inference_steps: int | None = 50
    guidance_scale: float | None = 7.5
    width: int | None = 1024
    height: int | None = 1024
    seed: int | None = None
    scheduler: str | None = None
    extra_params: dict[str, Any] = {}

    @computed_field
    def images(self) -> list[HttpUrl]:
        """Get image URLs."""
        return self.image_prompts

    @computed_field
    def parameters(self) -> dict[str, Any]:
        """Get all parameters as a dictionary."""
        params = self.model_dump(exclude={"text", "image_prompts", "extra_params"})
        return {k: v for k, v in params.items() if v is not None}

    def to_string(self) -> str:
        """Convert prompt to string format."""
        parts = [self.text]

        # Add image prompts
        for url in self.image_prompts:
            parts.append(str(url))

        # Add parameters
        params = []
        for field, value in self.model_dump(exclude_unset=True).items():
            if field in {"text", "image_prompts", "extra_params"} or value is None:
                continue
            if isinstance(value, bool) and value:
                params.append(f"--{field}")
            elif isinstance(value, list) and value:
                for v in value:
                    params.append(f"--{field} {v}")
            else:
                params.append(f"--{field} {value}")

        # Add extra parameters
        for key, value in self.extra_params.items():
            if value is None:
                params.append(f"--{key}")
            else:
                params.append(f"--{key} {value}")

        if params:
            parts.append(" ".join(params))

        return " ".join(parts)


class FalParser:
    """Parser for converting between Fal.ai prompt formats."""

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.

        Args:
            prompt_dict: Dictionary containing prompt data.

        Returns:
            FalPrompt instance.

        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)

        # Extract known fields
        known_fields = set(FalPrompt.model_fields)

        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value

        # Create prompt with all parameters
        return FalPrompt(text=text, **params, extra_params=extra_params)


def parse_fal_dict(prompt_dict: dict[str, Any]) -> FalPrompt:
    """Convert a dictionary to a FalPrompt.

    Args:
        prompt_dict: Dictionary containing prompt data.

    Returns:
        FalPrompt instance.
    """
    parser = FalParser()
    return parser.parse_dict(prompt_dict)
```

## File: src/midjargon/engines/midjourney/__init__.py (Size: 0.28 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/__init__.py

from midjargon.engines.midjourney.midjourney import (
    MidjourneyParser,
    MidjourneyPrompt,
    parse_midjourney_dict,
)

__all__ = ["MidjourneyParser", "MidjourneyPrompt", "parse_midjourney_dict"]
```

## File: src/midjargon/engines/midjourney/midjourney.py (Size: 1.55 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/midjourney.py

from typing import Any


from midjargon.core.models import (
    MidjourneyPrompt,
)


class MidjourneyParser:
    """Parser for converting between Midjourney prompt formats."""

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.

        Args:
            prompt_dict: Dictionary containing prompt data.

        Returns:
            MidjourneyPrompt instance.

        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)

        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)

        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value

        # Create prompt with all parameters
        return MidjourneyPrompt(text=text, **params, extra_params=extra_params)


def parse_midjourney_dict(prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
    """Convert a dictionary to a MidjourneyPrompt.

    Args:
        prompt_dict: Dictionary containing prompt data.

    Returns:
        MidjourneyPrompt instance.
    """
    parser = MidjourneyParser()
    return parser.parse_dict(prompt_dict)
```

## File: src/midjargon/engines/midjourney/parser.py (Size: 2.02 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/parser.py

from typing import Any

from midjargon.core.models import MidjourneyParameters, MidjourneyPrompt
from midjargon.core.parameters import parse_parameters


class MidjourneyParser:
    """Parser for Midjourney prompts."""

    def __init__(self, prompt_dict: dict[str, Any] | None = None):
        """Initialize the parser.

        Args:
            prompt_dict: Optional dictionary containing prompt data.
        """
        self.prompt_dict = prompt_dict or {}
        self.prompt = MidjourneyPrompt(
            text=self.prompt_dict.get("text", ""),
            images=self.prompt_dict.get("images", []),
            parameters=MidjourneyParameters(**self.prompt_dict.get("parameters", {})),
        )

    def parse(self) -> MidjourneyPrompt:
        """Parse the prompt data into a MidjourneyPrompt object.

        Returns:
            A validated MidjourneyPrompt object.
        """
        return self.prompt

    @staticmethod
    def from_string(prompt_str: str) -> "MidjourneyParser":
        """Create a parser from a prompt string.

        Args:
            prompt_str: The raw prompt string to parse.

        Returns:
            A MidjourneyParser instance.

        Raises:
            ValueError: If prompt parsing fails.
        """
        # Split into text and parameters
        if " --" in prompt_str:
            text_part, param_part = prompt_str.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg) from e
        else:
            text_part = prompt_str.strip()
            parameters = {}

        # Create prompt dictionary
        prompt_dict = {
            "text": text_part,
            "images": [],
            "parameters": parameters,
        }

        return MidjourneyParser(prompt_dict)
```

## File: test-cases/prompts-fal.txt (Size: 32.46 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "images": [],
    "version": 6,
    "stylize": 250,
    "seed": 12345,
    "prompt": "\"Do not enter\" sign in Elvish script, overgrown with vines"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 250,
    "seed": 67890,
    "prompt": "\"Do not enter\" sign in Elvish script, overgrown with vines"
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "images": [],
  "version": 6.1,
  "stylize": 750,
  "weird": 250,
  "prompt": "\"Lost in translation\" neon sign in a Tokyo alleyway"
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "images": [],
  "version": 6.1,
  "stylize": 1000,
  "zoom": 1.5,
  "aspect_ratio": "1:2",
  "prompt": "\"Made in Midjourney\" stamp on a vintage postage stamp"
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
[
  {
    "images": [],
    "style": "raw",
    "stylize": 0,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "raw",
    "stylize": 0,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "raw",
    "stylize": 1000,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "raw",
    "stylize": 1000,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 0,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 0,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 1000,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 1000,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  }
]======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "images": [],
    "video": null,
    "version": 5.2,
    "chaos": 30,
    "aspect_ratio": "1:1",
    "prompt": "A botanical sketch of fern fronds"
  },
  {
    "images": [],
    "video": null,
    "version": 5.2,
    "chaos": 30,
    "aspect_ratio": "16:9",
    "prompt": "A botanical sketch of fern fronds"
  },
  {
    "images": [],
    "video": null,
    "version": 6,
    "chaos": 30,
    "aspect_ratio": "1:1",
    "prompt": "A botanical sketch of fern fronds"
  },
  {
    "images": [],
    "video": null,
    "version": 6,
    "chaos": 30,
    "aspect_ratio": "16:9",
    "prompt": "A botanical sketch of fern fronds"
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "images": [],
  "version": 6,
  "stylize": 100,
  "aspect_ratio": "2:3",
  "prompt": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages"
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "images": [],
    "stop": 80,
    "weird": 2000,
    "aspect_ratio": "3:2",
    "prompt": "A cat in a Tundra environment"
  },
  {
    "images": [],
    "stop": 80,
    "weird": 2000,
    "aspect_ratio": "3:2",
    "prompt": "A cat in a Jungle environment"
  },
  {
    "images": [],
    "stop": 80,
    "weird": 2000,
    "aspect_ratio": "3:2",
    "prompt": "A cat in a City environment"
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 50,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 50,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 750,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 750,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 50,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 50,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 750,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 750,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "images": [],
  "version": 6,
  "stylize": 500,
  "aspect_ratio": "1:1",
  "prompt": "A cyberpunk cat with a neon sign that says \"Midjourney\""
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "images": [],
  "version": 6.1,
  "stylize": 250,
  "aspect_ratio": "16:9",
  "prompt": "A pastel watercolor landscape with \"/imagine\" written in the clouds"
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "images": [],
    "tile": null,
    "chaos": 25,
    "prompt": "A pattern of pink and blue striped river stones"
  },
  {
    "images": [],
    "tile": null,
    "chaos": 75,
    "prompt": "A pattern of pink and blue striped river stones"
  },
  {
    "images": [],
    "tile": null,
    "chaos": 25,
    "prompt": "A pattern of colorful watercolor fall leaves"
  },
  {
    "images": [],
    "tile": null,
    "chaos": 75,
    "prompt": "A pattern of colorful watercolor fall leaves"
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "images": [],
  "style": "random-64",
  "no": "color, shading",
  "aspect_ratio": "2:3",
  "prompt": "A pencil sketch of a dragon made of constellations"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "prompt": "A portrait of a melancholic robot butler"
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "stop": 30,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "stop": 70,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "stop": 30,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "stop": 70,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
[
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  }
]======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "images": [],
    "stop": 50,
    "quality": 0.5,
    "prompt": "A continuous line charcoal drawing of a value study of a cyborg geisha"
  },
  {
    "images": [],
    "stop": 50,
    "quality": 0.5,
    "prompt": "A loose gestural charcoal drawing of a value study of a cyborg geisha"
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
[
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  }
]======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
[
  {
    "images": [],
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome",
    "prompt": "A Millennial Pink colored cat"
  },
  {
    "images": [],
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome",
    "prompt": "A Acid Green colored cat"
  },
  {
    "images": [],
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome",
    "prompt": "A Ebony colored cat"
  }
]======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a determined sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a determined sloth riding a unicorn through a salt flat"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a determined sloth riding a unicorn through a salt flat"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat"
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
[
  {
    "images": [],
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers",
    "prompt": "A pixel art style cat"
  },
  {
    "images": [],
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers",
    "prompt": "A acrylic pour style cat"
  }
]======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "images": [],
  "stylize": 50,
  "no": "board, pieces",
  "style": "raw",
  "aspect_ratio": "4:3",
  "prompt": "An impressionistic watercolor of a cat playing chess with a dog"
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "images": [],
  "negative": "weight fruit::-.5",
  "version": 4,
  "chaos": 60,
  "prompt": "cheese:: cake:: painting multi-prompt"
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "images": [],
    "weird": 750,
    "stylize": 200,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 200,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 600,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 600,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 900,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 900,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 200,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 200,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 600,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 600,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 900,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 900,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 200,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 200,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 600,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 600,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 900,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 900,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "images": [],
    "weird": 250,
    "stylize": 100,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 100,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 100,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 500,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 500,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 500,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 1000,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 1000,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 1000,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 100,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 100,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 100,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 500,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 500,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 500,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 1000,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 1000,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 1000,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 100,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 100,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 100,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 500,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 500,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 500,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 1000,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 1000,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 1000,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  }
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "images": [],
  "remix": null,
  "prompt": "image of a robot holding flowers",
  "zoom": "2x"
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1400s cat"
  },
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1400s cat"
  },
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1990s cat"
  },
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1990s cat"
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "images": [],
    "weird": 500,
    "chaos": 20,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 20,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 60,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 60,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 20,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 20,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 60,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 60,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 20,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 20,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 60,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 60,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 80,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 80,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "images": [],
    "stylize": 250,
    "weird": 500,
    "prompt": "space:: ship multi-prompt"
  },
  {
    "images": [],
    "stylize": 750,
    "weird": 500,
    "prompt": "space:: ship multi-prompt"
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "images": [],
  "vary": "region",
  "selection": "sky area",
  "prompt": "stream running through a redwood forest",
  "pan": "up"
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "images": [],
    "version": 5.2,
    "stylize": 100,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 5.2,
    "stylize": 100,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 5.2,
    "stylize": 500,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 5.2,
    "stylize": 500,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 100,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 100,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 500,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 500,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 100,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 100,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 500,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 500,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  }
]
```

## File: test-cases/prompts-in.txt (Size: 3.16 KB)

```
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
space:: ship multi-prompt  --stylize {250, 750} --weird 500
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
{Happy, Angry, Shy} cat --style raw --chaos 60 --quality 1 --repeat 3
```

## File: test-cases/prompts-json.txt (Size: 31.71 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "images": [],
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "version": "6",
    "stylize": 250,
    "seed": 12345
  },
  {
    "images": [],
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "version": "6",
    "stylize": 250,
    "seed": 67890
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "images": [],
  "text": "\"Lost in translation\" neon sign in a Tokyo alleyway",
  "version": "6.1",
  "stylize": 750,
  "weird": 250
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "images": [],
  "text": "\"Made in Midjourney\" stamp on a vintage postage stamp",
  "version": "6.1",
  "stylize": 1000,
  "zoom": "1.5",
  "aspect": "1:2"
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
[
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 0,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 0,
    "weird": 3000
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 1000,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 1000,
    "weird": 3000
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 0,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 0,
    "weird": 3000
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 1000,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 1000,
    "weird": 3000
  }
]======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "5.2",
    "aspect": "1:1",
    "chaos": 30
  },
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "5.2",
    "aspect": "16:9",
    "chaos": 30
  },
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "6",
    "aspect": "1:1",
    "chaos": 30
  },
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "6",
    "aspect": "16:9",
    "chaos": 30
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "images": [],
  "text": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages",
  "version": "6",
  "stylize": 100,
  "aspect": "2:3"
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "images": [],
    "text": "A cat in a Tundra environment",
    "aspect": "3:2",
    "stop": 80,
    "weird": 2000
  },
  {
    "images": [],
    "text": "A cat in a Jungle environment",
    "aspect": "3:2",
    "stop": 80,
    "weird": 2000
  },
  {
    "images": [],
    "text": "A cat in a City environment",
    "aspect": "3:2",
    "stop": 80,
    "weird": 2000
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 50,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 50,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 750,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 750,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 50,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 50,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 750,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 750,
    "quality": 1.0
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "images": [],
  "text": "A cyberpunk cat with a neon sign that says \"Midjourney\"",
  "version": "6",
  "stylize": 500,
  "aspect": "1:1"
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "images": [],
  "text": "A pastel watercolor landscape with \"/imagine\" written in the clouds",
  "version": "6.1",
  "stylize": 250,
  "aspect": "16:9"
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "images": [],
    "text": "A pattern of pink and blue striped river stones",
    "tile": null,
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pattern of pink and blue striped river stones",
    "tile": null,
    "chaos": 75
  },
  {
    "images": [],
    "text": "A pattern of colorful watercolor fall leaves",
    "tile": null,
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pattern of colorful watercolor fall leaves",
    "tile": null,
    "chaos": 75
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "images": [],
  "text": "A pencil sketch of a dragon made of constellations",
  "aspect": "2:3",
  "style": "random-64",
  "no": "color, shading"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 500,
    "chaos": 80,
    "stop": 30
  },
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 500,
    "chaos": 80,
    "stop": 70
  },
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 1500,
    "chaos": 80,
    "stop": 30
  },
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 1500,
    "chaos": 80,
    "stop": 70
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
[
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295
  }
]======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "images": [],
    "text": "A continuous line charcoal drawing of a value study of a cyborg geisha",
    "stop": 50,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "A loose gestural charcoal drawing of a value study of a cyborg geisha",
    "stop": 50,
    "quality": 0.5
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
[
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 100
  }
]======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
[
  {
    "images": [],
    "text": "A Millennial Pink colored cat",
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome"
  },
  {
    "images": [],
    "text": "A Acid Green colored cat",
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome"
  },
  {
    "images": [],
    "text": "A Ebony colored cat",
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome"
  }
]======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "images": [],
    "text": "A pastel painting of a determined sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pastel painting of a determined sloth riding a unicorn through a salt flat",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a determined sloth riding a unicorn through a salt flat",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat",
    "chaos": 25
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
[
  {
    "images": [],
    "text": "A pixel art style cat",
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers"
  },
  {
    "images": [],
    "text": "A acrylic pour style cat",
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers"
  }
]======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "images": [],
  "text": "An impressionistic watercolor of a cat playing chess with a dog",
  "aspect": "4:3",
  "stylize": 50,
  "no": "board, pieces",
  "style": "raw"
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "images": [],
  "text": "cheese:: cake:: painting multi-prompt",
  "negative": "weight fruit::-.5",
  "version": "4",
  "chaos": 60
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 200,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 200,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 600,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 600,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 900,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 900,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 200,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 200,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 600,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 600,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 900,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 900,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 200,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 200,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 600,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 600,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 900,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 900,
    "aspect": "3:2"
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 100,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 100,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 100,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 500,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 500,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 500,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 1000,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 1000,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 1000,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 100,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 100,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 100,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 500,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 500,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 500,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 1000,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 1000,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 1000,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 100,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 100,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 100,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 500,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 500,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 500,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 1000,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 1000,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 1000,
    "chaos": 90
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect": "2:3"
  }
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "images": [],
  "text": "image of a robot holding flowers",
  "remix": null,
  "prompt": "A cyborg holding cybernetic orchids",
  "zoom": "2x"
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "images": [],
    "text": "Imagine a 1400s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect": "5:4"
  },
  {
    "images": [],
    "text": "Imagine a 1400s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect": "5:4"
  },
  {
    "images": [],
    "text": "Imagine a 1990s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect": "5:4"
  },
  {
    "images": [],
    "text": "Imagine a 1990s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect": "5:4"
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 20,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 20,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 60,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 60,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 80,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 80,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 20,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 20,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 60,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 60,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 80,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 80,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 20,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 20,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 60,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 60,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 80,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 80,
    "quality": 1.0
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "images": [],
    "text": "space:: ship multi-prompt",
    "stylize": 250,
    "weird": 500
  },
  {
    "images": [],
    "text": "space:: ship multi-prompt",
    "stylize": 750,
    "weird": 500
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "images": [],
  "text": "stream running through a redwood forest",
  "vary": "region",
  "selection": "sky area",
  "prompt": "aurora borealis",
  "pan": "up"
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 100,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 100,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 500,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 500,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 100,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 100,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 500,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 500,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 100,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 100,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 500,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 500,
    "quality": 2.0
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 5
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 5
  }
]
```

## File: test-cases/prompts-mj.txt (Size: 105.65 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 12345,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 67890,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "text": "\"Lost in translation\" neon sign in a Tokyo alleyway",
  "image_prompts": [],
  "stylize": 750,
  "chaos": 0,
  "weird": 250,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "text": "\"Made in Midjourney\" stamp on a vintage postage stamp",
  "image_prompts": [],
  "stylize": 1000,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 2,
  "aspect_ratio": "1:2",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "zoom": "1.5"
  }
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'expressive', 'raw', 'scenic', 'original'} [type=value_error, input_value='default', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 16,
    "aspect_height": 9,
    "aspect_ratio": "16:9",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 16,
    "aspect_height": 9,
    "aspect_ratio": "16:9",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "text": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 2,
  "aspect_height": 3,
  "aspect_ratio": "2:3",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "text": "A cat in a Tundra environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a Jungle environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a City environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "text": "A cyberpunk cat with a neon sign that says \"Midjourney\"",
  "image_prompts": [],
  "stylize": 500,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "text": "A pastel watercolor landscape with \"/imagine\" written in the clouds",
  "image_prompts": [],
  "stylize": 250,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 16,
  "aspect_height": 9,
  "aspect_ratio": "16:9",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'cute', 'original', 'raw', 'expressive'} [type=value_error, input_value='random-64', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
{
  "error": "Invalid value for seed: random - Invalid numeric value: could not convert string to float: 'random'"
}======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "text": "A continuous line charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A loose gestural charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'raw', 'cute', 'original', 'expressive'} [type=value_error, input_value='random', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'expressive', 'original', 'raw', 'scenic'} [type=value_error, input_value='random-16', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'scenic', 'raw', 'expressive', 'original'} [type=value_error, input_value='random-128', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "text": "An impressionistic watercolor of a cat playing chess with a dog",
  "image_prompts": [],
  "stylize": 50,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 4,
  "aspect_height": 3,
  "aspect_ratio": "4:3",
  "style": "raw",
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": "board, pieces",
  "extra_params": {}
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "text": "cheese:: cake:: painting multi-prompt",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 60,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v4",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "negative": "weight fruit::-.5"
  }
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "text": "image of a robot holding flowers",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "remix": null,
    "prompt": "A cyborg holding cybernetic orchids",
    "zoom": "2x"
  }
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "text": "stream running through a redwood forest",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "vary": "region",
    "selection": "sky area",
    "prompt": "aurora borealis",
    "pan": "up"
  }
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]
```

## File: test-cases/prompts-out.txt (Size: 13.41 KB)

```
> mj '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> fal '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> json '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> perm '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> mj '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> fal '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> json '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> perm '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> mj '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> fal '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> json '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> perm '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> mj 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> fal 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> json 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> perm 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> mj 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> fal 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> json 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> perm 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> mj 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> fal 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> json 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> perm 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> mj 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> fal 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> json 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> perm 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> mj 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> fal 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> json 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> perm 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> mj 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> fal 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> json 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> perm 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> mj 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> fal 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> json 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> perm 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> mj 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> fal 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> json 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> perm 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> mj 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> fal 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> json 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> perm 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> mj 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> fal 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> json 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> perm 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> mj 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> fal 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> json 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> perm 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> mj 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> fal 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> json 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> perm 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> mj 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> fal 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> json 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> perm 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> mj 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> fal 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> json 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> perm 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> mj 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> fal 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> json 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> perm 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> mj 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> fal 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> json 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> perm 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> mj 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> fal 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> json 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> perm 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> mj 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> fal 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> json 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> perm 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> mj 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> fal 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> json 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> perm 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> mj 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> fal 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> json 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> perm 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> mj 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> fal 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> json 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> perm 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> mj 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> fal 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> json 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> perm 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> mj 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> fal 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> json 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> perm 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> mj 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> fal 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> json 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> perm 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> mj 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> fal 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> json 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> perm 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> mj 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> fal 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> json 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> perm 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> mj 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> fal 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> json 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> perm 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> mj 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> fal 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> json 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> perm 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> mj '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
> fal '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
> json '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
> perm '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
```

## File: test-cases/prompts-perm.txt (Size: 19.07 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  "\"Do not enter\" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed 12345",
  "\"Do not enter\" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed 67890"
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
[
  "\"Lost in translation\" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250"
]======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
[
  "\"Made in Midjourney\" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2"
]======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
[
  "A black and white oak tree icon --style raw --stylize 0 --weird 0",
  "A black and white oak tree icon --style raw --stylize 0 --weird 3000",
  "A black and white oak tree icon --style raw --stylize 1000 --weird 0",
  "A black and white oak tree icon --style raw --stylize 1000 --weird 3000",
  "A black and white oak tree icon --style default --stylize 0 --weird 0",
  "A black and white oak tree icon --style default --stylize 0 --weird 3000",
  "A black and white oak tree icon --style default --stylize 1000 --weird 0",
  "A black and white oak tree icon --style default --stylize 1000 --weird 3000"
]======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  "A botanical sketch of fern fronds --video --version 5.2 --ar 1:1 --chaos 30",
  "A botanical sketch of fern fronds --video --version 5.2 --ar 16:9 --chaos 30",
  "A botanical sketch of fern fronds --video --version 6 --ar 1:1 --chaos 30",
  "A botanical sketch of fern fronds --video --version 6 --ar 16:9 --chaos 30"
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
[
  "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages --v 6 --stylize 100 --ar 2:3"
]======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  "A cat in a Tundra environment --ar 3:2 --stop 80 --weird 2000",
  "A cat in a Jungle environment --ar 3:2 --stop 80 --weird 2000",
  "A cat in a City environment --ar 3:2 --stop 80 --weird 2000"
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 50 --quality .25",
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 50 --quality 1",
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 750 --quality .25",
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 750 --quality 1",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 50 --quality .25",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 50 --quality 1",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 750 --quality .25",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 750 --quality 1"
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
[
  "A cyberpunk cat with a neon sign that says \"Midjourney\" --v 6 --stylize 500 --ar 1:1"
]======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
[
  "A pastel watercolor landscape with \"/imagine\" written in the clouds --v 6.1 --stylize 250 --ar 16:9"
]======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  "A pattern of pink and blue striped river stones --tile --chaos 25",
  "A pattern of pink and blue striped river stones --tile --chaos 75",
  "A pattern of colorful watercolor fall leaves --tile --chaos 25",
  "A pattern of colorful watercolor fall leaves --tile --chaos 75"
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
[
  "A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading"
]======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 0 --sref <image URL of sad painting> --sw 100",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 0 --sref <image URL of sad painting> --sw 800",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 50 --sref <image URL of sad painting> --sw 100",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 50 --sref <image URL of sad painting> --sw 800",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 100 --sref <image URL of sad painting> --sw 100",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 100 --sref <image URL of sad painting> --sw 800"
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 500 --chaos 80 --stop 30",
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 500 --chaos 80 --stop 70",
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 1500 --chaos 80 --stop 30",
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 1500 --chaos 80 --stop 70"
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
[
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality 1 --seed 4294967295",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality 1 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality 1 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality 1 --seed 4294967295"
]======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  "A continuous line charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5",
  "A loose gestural charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5"
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
[
  "A dreary cyberpunk cityscape --ar 16:9 --style raw --chaos 0",
  "A dreary cyberpunk cityscape --ar 16:9 --style raw --chaos 100",
  "A dreary cyberpunk cityscape --ar 16:9 --style random --chaos 0",
  "A dreary cyberpunk cityscape --ar 16:9 --style random --chaos 100",
  "A dreary cyberpunk cityscape --ar 1:1 --style raw --chaos 0",
  "A dreary cyberpunk cityscape --ar 1:1 --style raw --chaos 100",
  "A dreary cyberpunk cityscape --ar 1:1 --style random --chaos 0",
  "A dreary cyberpunk cityscape --ar 1:1 --style random --chaos 100",
  "A vibrant cyberpunk cityscape --ar 16:9 --style raw --chaos 0",
  "A vibrant cyberpunk cityscape --ar 16:9 --style raw --chaos 100",
  "A vibrant cyberpunk cityscape --ar 16:9 --style random --chaos 0",
  "A vibrant cyberpunk cityscape --ar 16:9 --style random --chaos 100",
  "A vibrant cyberpunk cityscape --ar 1:1 --style raw --chaos 0",
  "A vibrant cyberpunk cityscape --ar 1:1 --style raw --chaos 100",
  "A vibrant cyberpunk cityscape --ar 1:1 --style random --chaos 0",
  "A vibrant cyberpunk cityscape --ar 1:1 --style random --chaos 100"
]======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
[
  "A Millennial Pink colored cat --s 250 --style random-16 --no monochrome",
  "A Acid Green colored cat --s 250 --style random-16 --no monochrome",
  "A Ebony colored cat --s 250 --style random-16 --no monochrome"
]======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  "A pastel painting of a determined sloth riding a unicorn through a crystal forest --chaos 25",
  "A pastel painting of a determined sloth riding a unicorn through a salt flat --chaos 25",
  "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest --chaos 25",
  "A pastel painting of a sleepy sloth riding a unicorn through a salt flat --chaos 25",
  "A blacklight painting of a determined sloth riding a unicorn through a crystal forest --chaos 25",
  "A blacklight painting of a determined sloth riding a unicorn through a salt flat --chaos 25",
  "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest --chaos 25",
  "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat --chaos 25"
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
[
  "A pixel art style cat --style random-128 --weird 1000 --no fur, whiskers",
  "A acrylic pour style cat --style random-128 --weird 1000 --no fur, whiskers"
]======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
[
  "An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw"
]======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
[
  "cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60"
]======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  "Clockwork chicken --weird 750 --stylize 200 --ar 2:3",
  "Clockwork chicken --weird 750 --stylize 200 --ar 3:2",
  "Clockwork chicken --weird 750 --stylize 600 --ar 2:3",
  "Clockwork chicken --weird 750 --stylize 600 --ar 3:2",
  "Clockwork chicken --weird 750 --stylize 900 --ar 2:3",
  "Clockwork chicken --weird 750 --stylize 900 --ar 3:2",
  "Clockwork chicken --weird 1750 --stylize 200 --ar 2:3",
  "Clockwork chicken --weird 1750 --stylize 200 --ar 3:2",
  "Clockwork chicken --weird 1750 --stylize 600 --ar 2:3",
  "Clockwork chicken --weird 1750 --stylize 600 --ar 3:2",
  "Clockwork chicken --weird 1750 --stylize 900 --ar 2:3",
  "Clockwork chicken --weird 1750 --stylize 900 --ar 3:2",
  "Clockwork chicken --weird 2750 --stylize 200 --ar 2:3",
  "Clockwork chicken --weird 2750 --stylize 200 --ar 3:2",
  "Clockwork chicken --weird 2750 --stylize 600 --ar 2:3",
  "Clockwork chicken --weird 2750 --stylize 600 --ar 3:2",
  "Clockwork chicken --weird 2750 --stylize 900 --ar 2:3",
  "Clockwork chicken --weird 2750 --stylize 900 --ar 3:2"
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  "Cyanotype cat --weird 250 --stylize 100 --chaos 10",
  "Cyanotype cat --weird 250 --stylize 100 --chaos 50",
  "Cyanotype cat --weird 250 --stylize 100 --chaos 90",
  "Cyanotype cat --weird 250 --stylize 500 --chaos 10",
  "Cyanotype cat --weird 250 --stylize 500 --chaos 50",
  "Cyanotype cat --weird 250 --stylize 500 --chaos 90",
  "Cyanotype cat --weird 250 --stylize 1000 --chaos 10",
  "Cyanotype cat --weird 250 --stylize 1000 --chaos 50",
  "Cyanotype cat --weird 250 --stylize 1000 --chaos 90",
  "Cyanotype cat --weird 1000 --stylize 100 --chaos 10",
  "Cyanotype cat --weird 1000 --stylize 100 --chaos 50",
  "Cyanotype cat --weird 1000 --stylize 100 --chaos 90",
  "Cyanotype cat --weird 1000 --stylize 500 --chaos 10",
  "Cyanotype cat --weird 1000 --stylize 500 --chaos 50",
  "Cyanotype cat --weird 1000 --stylize 500 --chaos 90",
  "Cyanotype cat --weird 1000 --stylize 1000 --chaos 10",
  "Cyanotype cat --weird 1000 --stylize 1000 --chaos 50",
  "Cyanotype cat --weird 1000 --stylize 1000 --chaos 90",
  "Cyanotype cat --weird 2000 --stylize 100 --chaos 10",
  "Cyanotype cat --weird 2000 --stylize 100 --chaos 50",
  "Cyanotype cat --weird 2000 --stylize 100 --chaos 90",
  "Cyanotype cat --weird 2000 --stylize 500 --chaos 10",
  "Cyanotype cat --weird 2000 --stylize 500 --chaos 50",
  "Cyanotype cat --weird 2000 --stylize 500 --chaos 90",
  "Cyanotype cat --weird 2000 --stylize 1000 --chaos 10",
  "Cyanotype cat --weird 2000 --stylize 1000 --chaos 50",
  "Cyanotype cat --weird 2000 --stylize 1000 --chaos 90"
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  "Ice cream icon --niji 5 --style cute --weird 250 --ar 1:1",
  "Ice cream icon --niji 5 --style cute --weird 250 --ar 2:3",
  "Ice cream icon --niji 5 --style cute --weird 1000 --ar 1:1",
  "Ice cream icon --niji 5 --style cute --weird 1000 --ar 2:3",
  "Ice cream icon --niji 5 --style expressive --weird 250 --ar 1:1",
  "Ice cream icon --niji 5 --style expressive --weird 250 --ar 2:3",
  "Ice cream icon --niji 5 --style expressive --weird 1000 --ar 1:1",
  "Ice cream icon --niji 5 --style expressive --weird 1000 --ar 2:3",
  "Ice cream icon --niji 6 --style cute --weird 250 --ar 1:1",
  "Ice cream icon --niji 6 --style cute --weird 250 --ar 2:3",
  "Ice cream icon --niji 6 --style cute --weird 1000 --ar 1:1",
  "Ice cream icon --niji 6 --style cute --weird 1000 --ar 2:3",
  "Ice cream icon --niji 6 --style expressive --weird 250 --ar 1:1",
  "Ice cream icon --niji 6 --style expressive --weird 250 --ar 2:3",
  "Ice cream icon --niji 6 --style expressive --weird 1000 --ar 1:1",
  "Ice cream icon --niji 6 --style expressive --weird 1000 --ar 2:3"
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
[
  "image of a robot holding flowers --remix --prompt \"A cyborg holding cybernetic orchids\" --zoom 2x"
]======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  "Imagine a 1400s cat --sref <image URL of medieval tapestry> --sv 1 --ar 5:4",
  "Imagine a 1400s cat --sref <image URL of medieval tapestry> --sv 4 --ar 5:4",
  "Imagine a 1990s cat --sref <image URL of medieval tapestry> --sv 1 --ar 5:4",
  "Imagine a 1990s cat --sref <image URL of medieval tapestry> --sv 4 --ar 5:4"
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  "Lithograph potato --weird 500 --chaos 20 --quality .5",
  "Lithograph potato --weird 500 --chaos 20 --quality 1",
  "Lithograph potato --weird 500 --chaos 60 --quality .5",
  "Lithograph potato --weird 500 --chaos 60 --quality 1",
  "Lithograph potato --weird 500 --chaos 80 --quality .5",
  "Lithograph potato --weird 500 --chaos 80 --quality 1",
  "Lithograph potato --weird 1500 --chaos 20 --quality .5",
  "Lithograph potato --weird 1500 --chaos 20 --quality 1",
  "Lithograph potato --weird 1500 --chaos 60 --quality .5",
  "Lithograph potato --weird 1500 --chaos 60 --quality 1",
  "Lithograph potato --weird 1500 --chaos 80 --quality .5",
  "Lithograph potato --weird 1500 --chaos 80 --quality 1",
  "Lithograph potato --weird 2500 --chaos 20 --quality .5",
  "Lithograph potato --weird 2500 --chaos 20 --quality 1",
  "Lithograph potato --weird 2500 --chaos 60 --quality .5",
  "Lithograph potato --weird 2500 --chaos 60 --quality 1",
  "Lithograph potato --weird 2500 --chaos 80 --quality .5",
  "Lithograph potato --weird 2500 --chaos 80 --quality 1"
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  "space:: ship multi-prompt  --stylize 250 --weird 500",
  "space:: ship multi-prompt  --stylize 750 --weird 500"
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
[
  "stream running through a redwood forest --vary region --selection \"sky area\" --prompt \"aurora borealis\" --pan up"
]======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  "Vibrant California poppies --version 5.2 --stylize 100 --quality 1",
  "Vibrant California poppies --version 5.2 --stylize 100 --quality 2",
  "Vibrant California poppies --version 5.2 --stylize 500 --quality 1",
  "Vibrant California poppies --version 5.2 --stylize 500 --quality 2",
  "Vibrant California poppies --version 6 --stylize 100 --quality 1",
  "Vibrant California poppies --version 6 --stylize 100 --quality 2",
  "Vibrant California poppies --version 6 --stylize 500 --quality 1",
  "Vibrant California poppies --version 6 --stylize 500 --quality 2",
  "Vibrant California poppies --version 6.1 --stylize 100 --quality 1",
  "Vibrant California poppies --version 6.1 --stylize 100 --quality 2",
  "Vibrant California poppies --version 6.1 --stylize 500 --quality 1",
  "Vibrant California poppies --version 6.1 --stylize 500 --quality 2"
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 5",
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 5",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 5",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 5"
]
```

## File: test-cases/prompts.sh (Size: 0.44 KB)

```
#!/usr/bin/env bash
# this_file: test-cases/prompts.sh

# THIS READS PROMPTS FROM prompts-in.txt
# THE ERRORS are in prompts-out.txt
# THE OUTPUT OF THE midjargon commands are in the -mj -fal -json -perm files

cat ./prompts-in.txt | while read p; do
    for o in mj fal json perm; do
        echo "> $o '$p'"
        echo "======" >>prompts-$o.txt
        echo "$p" >>prompts-$o.txt
        midjargon "$o" "$p" --json >>prompts-$o.txt
    done
done
```

## File: tests/__init__.py (Size: 0.03 KB)

```
# this_file: tests/__init__.py
```

## File: tests/cli/__init__.py (Size: 0.03 KB)

```
# this_file: tests/cli/__init__.py
```

## File: tests/cli/test_main.py (Size: 10.77 KB)

```
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pytest", "rich"]
# ///
# this_file: tests/cli/test_main.py

"""Tests for CLI functionality."""

import json
import re
import sys
from io import StringIO
from typing import Any

import pytest
from rich.console import Console

from midjargon.cli.main import MidjargonCLI

# Test constants
ASPECT_WIDTH = 16
ASPECT_HEIGHT = 9
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
IMAGE_PROMPTS_COUNT = 2
PERMUTATION_COUNT_2X2 = 4  # 2 options x 2 options

ANSI_ESCAPE = re.compile(r"\x1B[@-_][0-?]*[ -/]*[@-~]")


def parse_json_output(output_stream: StringIO) -> Any:
    """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
    output_stream.seek(0)
    output = output_stream.getvalue()
    # Remove ANSI escape sequences
    output = ANSI_ESCAPE.sub("", output)
    output = output.strip()
    if not output:
        msg = "No JSON found in output"
        raise ValueError(msg)
    try:
        return json.loads(output)
    except json.JSONDecodeError as e:
        msg = "No JSON found in output"
        raise ValueError(msg) from e


@pytest.fixture
def cli():
    """Fixture to provide CLI instance."""
    return MidjargonCLI()


def test_basic_prompt(cli):
    """Test basic prompt processing."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(
            f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT}",
            json_output=True,
        )
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a beautiful landscape"
    assert data["aspect"] == f"{ASPECT_WIDTH}:{ASPECT_HEIGHT}"


def test_permutations(cli):
    """Test permutation processing."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm("a {red, blue} bird", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 2
    texts = set(data)
    assert texts == {"a red bird", "a blue bird"}


def test_raw_output(cli):
    """Test raw output mode."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(f"a photo --stylize {STYLIZE_VALUE}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"
    assert data["stylize"] == STYLIZE_VALUE


def test_json_output_formatting(cli):
    """Test JSON output formatting."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"
    assert "images" in data


def test_invalid_input(cli):
    """Test handling of invalid input."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
        assert data["text"] == ""


def test_parameter_validation(cli):
    """Test parameter validation."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(
            f"a photo --stylize {STYLIZE_VALUE * 20}", json_output=True
        )  # Over max
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
        assert data["stylize"] == STYLIZE_VALUE * 20  # Now accepts any value


def test_image_url_handling(cli):
    """Test handling of image URLs."""
    url = "https://example.com/image.jpg"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(f"{url} a fusion", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a fusion"
    assert len(data["images"]) == 1
    assert data["images"][0] == url


def test_no_color_output(cli):
    """Test no-color output mode."""
    Console(force_terminal=False)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo", json_output=True, no_color=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"


def test_complex_prompt(cli):
    """Test complex prompt with multiple features."""
    prompt = (
        "https://example.com/img1.jpg https://example.com/img2.jpg "
        "a {red, blue} bird on a {branch, rock} "
        f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
    )
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == PERMUTATION_COUNT_2X2
    for prompt in data:
        assert len(prompt["images"]) == IMAGE_PROMPTS_COUNT
        assert prompt["stylize"] == STYLIZE_VALUE
        assert prompt["chaos"] == CHAOS_VALUE
        assert prompt["aspect"] == f"{ASPECT_WIDTH}:{ASPECT_HEIGHT}"


def test_personalization_parameter(cli):
    """Test personalization parameter handling in different forms."""
    # Test flag form (--p)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --p", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] is None  # Flag parameters should be None

    # Test with code (--p CODE1)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --p CODE1", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] == ["CODE1"]

    # Test with multiple codes (--p "CODE1 CODE2")
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json('a photo --p "CODE1 CODE2"', json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] == ["CODE1", "CODE2"]


def test_numeric_range_permutations(cli):
    """Test handling of numeric parameters in permutations."""
    # Test stylize parameter range
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 2
    stylize_values = {prompt["stylize"] for prompt in data}
    assert stylize_values == {75, 300}

    # Test multiple numeric parameters
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --s {75, 300} --c {0, 50}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4  # 2x2 combinations
    stylize_values = {prompt["stylize"] for prompt in data}
    chaos_values = {prompt["chaos"] for prompt in data}
    assert stylize_values == {75, 300}
    assert chaos_values == {0, 50}


def test_nested_parameter_permutations(cli):
    """Test handling of nested permutations with parameters."""
    # Test personalization with nested options
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("smooth edges {, --p {, CODE1}} --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 6  # 3x2 combinations (no --p, empty --p, --p CODE1) x (75, 300)

    # Verify all combinations
    variants = [
        (None, 75),  # No --p, stylize 75
        (None, 300),  # No --p, stylize 300
        (True, 75),  # Empty --p, stylize 75
        (True, 300),  # Empty --p, stylize 300
        (["CODE1"], 75),  # --p with code, stylize 75
        (["CODE1"], 300),  # --p with code, stylize 300
    ]
    for prompt in data:
        assert prompt["text"] == "smooth edges"
        assert (prompt.get("personalization"), prompt["stylize"]) in variants

    # Test more complex nested permutations
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("smooth edges {, --p {, CODE1 CODE2}} --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 6  # 3x2 combinations

    # Verify all combinations
    variants = [
        (None, 75),  # No --p, stylize 75
        (None, 300),  # No --p, stylize 300
        (True, 75),  # Empty --p, stylize 75
        (True, 300),  # Empty --p, stylize 300
        (["CODE1", "CODE2"], 75),  # --p with codes, stylize 75
        (["CODE1", "CODE2"], 300),  # --p with codes, stylize 300
    ]
    for prompt in data:
        assert prompt["text"] == "smooth edges"
        assert (prompt.get("personalization"), prompt["stylize"]) in variants


def test_mj_command(cli):
    """Test Midjourney prompt conversion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.mj("a serene landscape --ar 16:9 --stylize 100", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)  # Changed from list to dict
    assert data["text"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_fal_command(cli):
    """Test Fal.ai prompt conversion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.fal("a serene landscape --ar 16:9 --stylize 100", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["prompt"] == "a serene landscape"
    assert data["aspect_ratio"] == "16:9"
    assert data["stylize"] == 100


def test_perm_command(cli):
    """Test permutation expansion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm("a {red, blue} bird on a {branch, rock}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4
    expected = [
        "a red bird on a branch",
        "a red bird on a rock",
        "a blue bird on a branch",
        "a blue bird on a rock",
    ]
    assert set(data) == set(expected)
```

## File: tests/conftest.py (Size: 1.04 KB)

```
# this_file: tests/conftest.py
"""Pytest configuration and shared fixtures."""

import pytest


@pytest.fixture
def sample_prompts():
    """Return a dictionary of sample prompts for testing."""
    return {
        "basic": "a serene landscape --ar 16:9 --stylize 100",
        "with_image": "https://example.com/image.jpg mystical forest --chaos 20",
        "permutation": "a {red, blue} bird on a {flower, leaf} --ar 16:9",
        "multi_prompt": "mystical forest ::2 foggy mountains ::1 --chaos 20",
        "with_flags": "landscape photo --tile --no blur,cars",
        "escaped_commas": "a {red\\, blue, green} bird",
        "nested": "a {big {red, blue}, small green} bird",
        "multiple_images": "https://example.com/1.jpg https://example.com/2.jpg forest --iw 2",
    }


@pytest.fixture
def invalid_prompts():
    """Return a dictionary of invalid prompts for testing."""
    return {
        "empty": "",
        "only_params": "--ar 16:9",
        "unclosed_brace": "a {red, blue bird",
        "invalid_weight": "forest ::x mountains",
    }
```

## File: tests/core/__init__.py (Size: 0.04 KB)

```
# this_file: tests/core/__init__.py
```

## File: tests/core/test_input.py (Size: 3.74 KB)

```
# this_file: tests/core/test_input.py
"""Tests for input handling."""

from midjargon.core.input import expand_midjargon_input

# Test constants
PERMUTATION_COUNT_2 = 2  # Single permutation with 2 options
PERMUTATION_COUNT_3 = 3  # Single permutation with 3 options


def test_basic_input():
    """Test basic input without permutations."""
    result = expand_midjargon_input("a simple prompt")
    assert len(result) == 1
    assert result[0] == "a simple prompt"


def test_single_permutation():
    """Test input with a single permutation."""
    result = expand_midjargon_input("a {red, blue} bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red bird" in result
    assert "a blue bird" in result


def test_empty_input():
    """Test empty input handling."""
    result = expand_midjargon_input("")
    assert len(result) == 1
    assert result[0] == ""


def test_multiple_permutations():
    """Test input with multiple permutations."""
    result = expand_midjargon_input("a {red, blue, green} bird")
    assert len(result) == PERMUTATION_COUNT_3
    assert "a red bird" in result
    assert "a blue bird" in result
    assert "a green bird" in result


def test_nested_permutations():
    """Test input with nested permutations."""
    result = expand_midjargon_input("a {red {cat, dog}, blue bird}")
    assert len(result) == PERMUTATION_COUNT_3
    assert "a red cat" in result
    assert "a red dog" in result
    assert "a blue bird" in result


def test_escaped_braces():
    """Test input with escaped braces."""
    result = expand_midjargon_input(r"a \{red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"


def test_escaped_commas():
    """Test input with escaped commas."""
    result = expand_midjargon_input(r"a {red\, blue, green} bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red, blue bird" in result
    assert "a green bird" in result


def test_unmatched_braces():
    """Test input with unmatched braces."""
    result = expand_midjargon_input("a {red, blue bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue bird"


def test_empty_permutation():
    """Test input with empty permutation options."""
    result = expand_midjargon_input("a {} bird")
    assert len(result) == 1
    assert result[0] == "a bird"


def test_whitespace_handling():
    """Test input with various whitespace patterns."""
    result = expand_midjargon_input("a {  red  ,  blue  } bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red bird" in result
    assert "a blue bird" in result


def test_expand_midjargon_input():
    """Test expand_midjargon_input function to verify prompt expansion."""
    result = expand_midjargon_input("a {red, blue} bird")
    assert len(result) == 2
    assert "a red bird" in result
    assert "a blue bird" in result

    result = expand_midjargon_input("a {red, blue, green} bird")
    assert len(result) == 3
    assert "a red bird" in result
    assert "a blue bird" in result
    assert "a green bird" in result

    result = expand_midjargon_input("a {red {cat, dog}, blue bird}")
    assert len(result) == 3
    assert "a red cat" in result
    assert "a red dog" in result
    assert "a blue bird" in result


def test_handling_escaped_characters():
    """Test handling of escaped characters in expand_midjargon_input."""
    result = expand_midjargon_input(r"a \{red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"

    result = expand_midjargon_input(r"a {red\, blue, green} bird")
    assert len(result) == 2
    assert "a red, blue bird" in result
    assert "a green bird" in result

    result = expand_midjargon_input(r"a {red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"
```

## File: tests/core/test_parameters.py (Size: 9.75 KB)

```
# this_file: tests/core/test_parameters.py
"""Tests for parameter parsing functionality."""

import pytest

from midjargon.core.parameters import parse_parameters


def test_basic_parameter_parsing():
    """Test parsing of basic parameters."""
    param_str = "--ar 16:9 --stylize 100"
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["stylize"] == "100"


def test_flag_parameters():
    """Test parsing of flag parameters (without values)."""
    param_str = "--tile --turbo --relax"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None


def test_parameter_with_multiple_values():
    """Test parsing parameters that accept multiple values."""
    param_str = "--no blur,cars,watermark"
    params = parse_parameters(param_str)
    assert params["no"] == "blur,cars,watermark"


def test_parameter_with_spaces():
    """Test parsing parameters with values containing spaces."""
    param_str = '--style "raw photo" --seed 123456'
    params = parse_parameters(param_str)
    assert params["style"] == "raw photo"
    assert params["seed"] == "123456"


def test_mixed_parameters():
    """Test parsing a mix of different parameter types."""
    param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["tile"] is None
    assert params["no"] == "blur,cars"
    assert params["style"] == "raw photo"


def test_shorthand_parameters():
    """Test parsing of shorthand parameter names."""
    param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
    params = parse_parameters(param_str)
    assert params["stylize"] == "100"
    assert params["chaos"] == "50"
    assert params["weird"] == "1000"
    assert params["image_weight"] == "2.0"
    assert params["quality"] == "1.0"


def test_niji_version_parameter():
    """Test parsing of niji version parameter."""
    # Test basic niji
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"


def test_version_parameter():
    """Test parsing of version parameter."""
    # Test v parameter
    params = parse_parameters("--v 5.2")
    assert params["version"] == "5.2"


def test_personalization_parameter():
    """Test parsing of personalization parameter."""
    # Test basic p parameter
    params = parse_parameters("--p")
    assert params["personalization"] is None  # Flag without value is None

    # Test p parameter with value
    params = parse_parameters("--p custom")
    assert params["personalization"] == ["custom"]

    # Test p parameter with multiple values
    params = parse_parameters("--p custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]

    # Test personalization parameter with value
    params = parse_parameters("--personalization custom")
    assert params["personalization"] == ["custom"]

    # Test personalization parameter with multiple values
    params = parse_parameters("--personalization custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]


def test_reference_parameters():
    """Test parsing of reference parameters."""
    param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
    params = parse_parameters(param_str)
    assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
    assert params["style_reference"] == ["style1.jpg", "style2.jpg"]


def test_parameter_order():
    """Test that parameter order is preserved in output."""
    param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
    params = parse_parameters(param_str)
    keys = list(params.keys())
    assert keys == ["seed", "aspect", "chaos", "tile"]


def test_invalid_parameters():
    """Test handling of invalid parameter formats."""
    with pytest.raises(ValueError, match="Empty parameter name"):
        parse_parameters("--")  # Empty parameter name

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--ar")  # Missing required value

    with pytest.raises(ValueError, match="Parameter name cannot start with dash"):
        parse_parameters("ar 16:9")  # Missing -- prefix

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--v")  # Missing version value


def test_parse_parameters():
    """Test parse_parameters function to verify parameter parsing."""
    param_str = "--ar 16:9 --stylize 100"
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["stylize"] == "100"

    param_str = "--tile --turbo --relax"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None

    param_str = "--no blur,cars,watermark"
    params = parse_parameters(param_str)
    assert params["no"] == "blur,cars,watermark"

    param_str = '--style "raw photo" --seed 123456'
    params = parse_parameters(param_str)
    assert params["style"] == "raw photo"
    assert params["seed"] == "123456"

    param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["tile"] is None
    assert params["no"] == "blur,cars"
    assert params["style"] == "raw photo"

    param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
    params = parse_parameters(param_str)
    assert params["stylize"] == "100"
    assert params["chaos"] == "50"
    assert params["weird"] == "1000"
    assert params["image_weight"] == "2.0"
    assert params["quality"] == "1.0"

    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"

    params = parse_parameters("--v 5.2")
    assert params["version"] == "5.2"

    params = parse_parameters("--p")
    assert params["personalization"] is None  # Flag without value is None

    params = parse_parameters("--p custom")
    assert params["personalization"] == ["custom"]

    params = parse_parameters("--personalization custom")
    assert params["personalization"] == ["custom"]

    param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
    params = parse_parameters(param_str)
    assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
    assert params["style_reference"] == ["style1.jpg", "style2.jpg"]

    param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
    params = parse_parameters(param_str)
    keys = list(params.keys())
    assert keys == ["seed", "aspect", "chaos", "tile"]

    with pytest.raises(ValueError, match="Empty parameter name"):
        parse_parameters("--")  # Empty parameter name

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--ar")  # Missing required value

    with pytest.raises(ValueError, match="Parameter name cannot start with dash"):
        parse_parameters("ar 16:9")  # Missing -- prefix

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--v")  # Missing version value


def test_flag_parameters_handling():
    """Test handling of flag parameters in parse_parameters."""
    param_str = "--tile --turbo --relax --video --remix"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None
    assert params["video"] is None
    assert params["remix"] is None

    param_str = "--p"
    params = parse_parameters(param_str)
    assert params["personalization"] is None  # Flag without value is None

    param_str = "--p custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]

    param_str = "--personalization custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]


def test_special_seed_values():
    """Test handling of special seed values."""
    # Test random seed
    params = parse_parameters("--seed random")
    assert params["seed"] == "random"

    # Test numeric seed
    params = parse_parameters("--seed 12345")
    assert params["seed"] == "12345"


def test_reference_url_handling():
    """Test handling of URLs in reference parameters."""
    # Test character reference with quoted URL containing spaces
    params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
    assert params["character_reference"] == [
        "https://example.com/image with spaces.jpg"
    ]

    # Test style reference with quoted URL containing spaces
    params = parse_parameters('--sref "https://example.com/style with spaces.jpg"')
    assert params["style_reference"] == ["https://example.com/style with spaces.jpg"]

    # Test character reference with single URL (no quotes)
    params = parse_parameters("--cref https://example.com/image.jpg")
    assert params["character_reference"] == ["https://example.com/image.jpg"]

    # Test style reference with single URL (no quotes)
    params = parse_parameters("--sref https://example.com/style.jpg")
    assert params["style_reference"] == ["https://example.com/style.jpg"]


def test_niji_version_handling():
    """Test handling of niji version parameter."""
    # Test basic niji flag
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 5")
    assert params["version"] == "niji 5"

    # Test niji with version in permutation
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"

    # Ensure no 'v' prefix is added
    version = str(params["version"])  # Convert to string to use startswith
    assert not version.startswith("v")
```

## File: tests/core/test_parser.py (Size: 3.27 KB)

```
# this_file: tests/core/test_parser.py
"""Tests for prompt parsing functionality."""

from midjargon.core.parser import parse_midjargon_prompt_to_dict

# Test constants
ASPECT_RATIO = "16:9"
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
IMAGE_URL = "https://example.com/image.jpg"


def test_basic_prompt_parsing():
    """Test basic prompt parsing."""
    prompt = "a beautiful landscape --ar 16:9 --stylize 100"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a beautiful landscape"
    assert result["aspect"] == ASPECT_RATIO
    assert result["stylize"] == STYLIZE_VALUE


def test_prompt_with_image_url():
    """Test prompt parsing with image URL."""
    prompt = f"{IMAGE_URL} a mystical forest --chaos 50"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a mystical forest"
    assert result["images"] == [IMAGE_URL]
    assert result["chaos"] == CHAOS_VALUE


def test_prompt_with_multiple_image_urls():
    """Test prompt parsing with multiple image URLs."""
    image_urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = f"{image_urls[0]} {image_urls[1]} a serene landscape --stylize 100"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a serene landscape"
    assert result["images"] == image_urls
    assert result["stylize"] == STYLIZE_VALUE


def test_prompt_with_parameters():
    """Test prompt parsing with various parameters."""
    prompt = "a futuristic city --ar 16:9 --stylize 100 --chaos 50"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a futuristic city"
    assert result["aspect"] == ASPECT_RATIO
    assert result["stylize"] == STYLIZE_VALUE
    assert result["chaos"] == CHAOS_VALUE


def test_prompt_with_empty_parameters():
    """Test prompt parsing with empty parameters."""
    prompt = "a landscape photo --tile --no blur,cars"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a landscape photo"
    assert result["tile"] is None
    assert result["no"] == "blur,cars"


def test_prompt_with_escaped_characters():
    """Test prompt parsing with escaped characters."""
    prompt = r"a \{red, blue\} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == r"a \{red, blue\} bird"


def test_prompt_with_nested_permutations():
    """Test prompt parsing with nested permutations."""
    prompt = "a {big {red, blue}, small green} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {big {red, blue}, small green} bird"


def test_prompt_with_unmatched_braces():
    """Test prompt parsing with unmatched braces."""
    prompt = "a {red, blue bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {red, blue bird"


def test_prompt_with_empty_permutation():
    """Test prompt parsing with empty permutation options."""
    prompt = "a {} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {} bird"


def test_prompt_with_whitespace_handling():
    """Test prompt parsing with various whitespace patterns."""
    prompt = "a {  red  ,  blue  } bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a { red , blue } bird"
```

## File: tests/engines/__init__.py (Size: 0.04 KB)

```
# this_file: tests/engines/__init__.py
```

## File: tests/engines/midjourney/__init__.py (Size: 0.05 KB)

```
# this_file: tests/engines/midjourney/__init__.py
```

## File: tests/engines/midjourney/test_midjourney_parser.py (Size: 7.50 KB)

```
# this_file: tests/engines/midjourney/test_midjourney_parser.py
"""Tests for Midjourney parser."""

import pytest
from pydantic import HttpUrl

from midjargon.engines.midjourney import MidjourneyParser

# Test constants
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
WEIRD_VALUE = 1000
SEED_VALUE = 12345
STOP_VALUE = 80
IMAGE_WEIGHT_VALUE = 2.0
VERSION_NUMBER = "5.2"
DEFAULT_STYLIZE = 100
QUALITY_VALUE = 1.5
CHARACTER_WEIGHT_VALUE = 50
STYLE_WEIGHT_VALUE = 500
STYLE_VERSION_VALUE = 3
REPEAT_VALUE = 5


def test_numeric_parameters():
    """Test parsing of numeric parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "stylize": str(STYLIZE_VALUE),
            "seed": str(SEED_VALUE),
            "chaos": str(CHAOS_VALUE),
        }
    )

    assert prompt.text == "a photo"
    assert prompt.stylize == float(STYLIZE_VALUE)
    assert prompt.seed == SEED_VALUE
    assert prompt.chaos == float(CHAOS_VALUE)


def test_style_parameters():
    """Test parsing of style parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {"text": "a photo", "style": "raw", "version": VERSION_NUMBER}
    )

    assert prompt.text == "a photo"
    assert prompt.style == "raw"
    assert prompt.version == f"v{VERSION_NUMBER}"


def test_aspect_ratio():
    """Test parsing of aspect ratio."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict({"text": "a photo", "ar": "16:9"})

    assert prompt.text == "a photo"
    assert prompt.aspect_width == 16
    assert prompt.aspect_height == 9
    assert prompt.aspect_ratio == "16:9"


def test_image_prompts():
    """Test parsing of image prompts."""
    parser = MidjourneyParser()
    urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = parser.parse_dict({"text": "a fusion", "image_prompts": urls})

    assert prompt.text == "a fusion"
    assert len(prompt.image_prompts) == 2
    assert all(isinstance(url, HttpUrl) for url in prompt.image_prompts)
    assert [str(url) for url in prompt.image_prompts] == urls


def test_extra_parameters():
    """Test handling of unknown parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "unknown": "value",
            "flag": None,
        }
    )

    assert prompt.text == "a photo"
    assert prompt.extra_params == {"unknown": "value", "flag": None}


def test_parameter_conversion():
    """Test parameter value conversion."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "stylize": str(STYLIZE_VALUE),
            "seed": str(SEED_VALUE),
            "image_weight": str(IMAGE_WEIGHT_VALUE),
        }
    )

    assert prompt.text == "a photo"
    assert prompt.stylize == float(STYLIZE_VALUE)
    assert prompt.seed == SEED_VALUE
    assert prompt.image_weight == float(IMAGE_WEIGHT_VALUE)


def test_invalid_values():
    """Test handling of invalid parameter values."""
    parser = MidjourneyParser()

    # Invalid aspect ratio - now accepts any value
    result = parser.parse_dict({"text": "a photo", "ar": "999:999"})
    assert result.aspect_width == 999
    assert result.aspect_height == 999
    assert result.aspect_ratio == "999:999"

    # Invalid image URL - treated as extra parameter
    result = parser.parse_dict({"text": "a photo", "image": "not_a_url"})
    assert len(result.image_prompts) == 0
    assert result.extra_params.get("image") == "not_a_url"


def test_empty_values():
    """Test handling of empty values."""
    parser = MidjourneyParser()

    # Empty text
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": ""})

    # Empty image list
    prompt = parser.parse_dict({"text": "a photo", "image_prompts": []})
    assert prompt.text == "a photo"
    assert not prompt.image_prompts

    # None values
    prompt = parser.parse_dict({"text": "a photo", "stylize": None})
    assert prompt.text == "a photo"
    assert prompt.stylize == DEFAULT_STYLIZE  # Default value


def test_version_parameter():
    """Test parsing of version parameter."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "version": "6",
        }
    )

    assert prompt.text == "a photo"
    assert prompt.version == "v6"


def test_multiple_permutations():
    """Test handling of multiple permutations."""
    parser = MidjourneyParser()

    # Test with parameter permutations
    input_dicts = [
        {"text": "smooth edges", "stylize": "75"},
        {"text": "smooth edges", "stylize": "300"},
        {"text": "smooth edges", "stylize": "75", "personalization": True},
        {"text": "smooth edges", "stylize": "300", "personalization": True},
    ]

    results = [parser.parse_dict(d) for d in input_dicts]
    assert len(results) == 4

    # Verify each permutation is handled correctly
    result_tuples = {(r.text.strip(), r.stylize, r.personalization) for r in results}

    expected = {
        ("smooth edges", 75.0, False),
        ("smooth edges", 300.0, False),
        ("smooth edges", 75.0, True),
        ("smooth edges", 300.0, True),
    }

    assert result_tuples == expected

    # Test with flag permutations
    input_dicts = [
        {"text": "photo"},
        {"text": "photo", "tile": True},
        {"text": "photo", "turbo": True},
        {"text": "photo", "tile": True, "turbo": True},
    ]

    results = [parser.parse_dict(d) for d in input_dicts]
    assert len(results) == 4

    # Verify each permutation is handled correctly
    result_tuples = {(r.text.strip(), r.tile, r.turbo) for r in results}

    expected = {
        ("photo", False, False),
        ("photo", True, False),
        ("photo", False, True),
        ("photo", True, True),
    }

    assert result_tuples == expected


def test_personalization_parameter():
    """Test parsing of personalization parameter."""
    parser = MidjourneyParser()

    # Test flag with True value
    prompt = parser.parse_dict({"text": "a photo", "personalization": True})
    assert prompt.personalization is True

    # Test flag with False value
    prompt = parser.parse_dict({"text": "a photo", "personalization": False})
    assert prompt.personalization is False


def test_edge_cases():
    """Test handling of edge cases in Midjourney parser."""
    parser = MidjourneyParser()

    # Test empty prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": ""})

    # Test prompt with only spaces
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": "   "})

    # Test prompt with special characters
    prompt = parser.parse_dict({"text": "a photo with special characters !@#$%^&*()"})
    assert prompt.text == "a photo with special characters !@#$%^&*()"

    # Test prompt with long text
    long_text = "a" * 1000
    prompt = parser.parse_dict({"text": long_text})
    assert prompt.text == long_text

    # Test prompt with mixed types in extra parameters
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "extra1": "123",
            "extra2": "45.67",
            "extra3": "true",
            "extra4": None,
            "extra5": "item1",
        }
    )
    assert prompt.extra_params["extra1"] == "123"
    assert prompt.extra_params["extra2"] == "45.67"
    assert prompt.extra_params["extra3"] == "true"
    assert prompt.extra_params["extra4"] is None
    assert prompt.extra_params["extra5"] == "item1"
```

## File: tests/integration/__init__.py (Size: 0.04 KB)

```
# this_file: tests/integration/__init__.py
```

## File: tests/integration/test_workflow.py (Size: 10.86 KB)

```
#!/usr/bin/env python3
# this_file: tests/integration/test_workflow.py
"""Integration tests for complete midjargon workflow."""

import sys
from io import StringIO

import pytest

from midjargon import expand_midjargon_input, parse_midjargon_prompt_to_dict
from midjargon.cli.main import MidjargonCLI
from midjargon.core.models import MidjourneyPrompt
from midjargon.engines.midjourney import parse_midjourney_dict
from tests.cli.test_main import parse_json_output  # Added import for JSON parsing

# Test constants
ASPECT_WIDTH = 16
ASPECT_HEIGHT = 9
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
WEIRD_VALUE = 1000
SEED_VALUE = 12345
STOP_VALUE = 80
IMAGE_WEIGHT_VALUE = 2.0
QUALITY_VALUE = 1.0
CHARACTER_WEIGHT_VALUE = 100
STYLE_WEIGHT_VALUE = 200
STYLE_VERSION_VALUE = 2
REPEAT_VALUE = 3
PERMUTATION_COUNT_2X2 = 4  # 2 options x 2 options
PERMUTATION_COUNT_2X2X2 = 8  # 2 options x 2 options x 2 options


def process_prompt(prompt: str) -> list[MidjourneyPrompt]:
    """Process a prompt through the complete workflow."""
    # Step 1: Expand permutations
    expanded = expand_midjargon_input(prompt)

    # Step 2: Parse each expanded prompt to a dictionary
    midjargon_dicts = [
        parse_midjargon_prompt_to_dict(variant.prompt.to_string())
        for variant in expanded
    ]

    # Step 3: Convert each dictionary to a MidjourneyPrompt
    return [parse_midjourney_dict(d) for d in midjargon_dicts]


def test_basic_workflow():
    """Test basic prompt workflow without permutations."""
    prompt = f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "a beautiful landscape"
    assert result.aspect_width == ASPECT_WIDTH
    assert result.aspect_height == ASPECT_HEIGHT
    assert result.stylize == STYLIZE_VALUE


def test_permutation_workflow():
    """Test workflow with permutations."""
    prompt = f"a {{red, blue}} bird on a {{branch, rock}} --stylize {STYLIZE_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == PERMUTATION_COUNT_2X2  # 2x2 permutations
    texts = {r.text for r in results}
    expected = {
        "a red bird on a branch",
        "a red bird on a rock",
        "a blue bird on a branch",
        "a blue bird on a rock",
    }
    assert texts == expected
    assert all(r.stylize == STYLIZE_VALUE for r in results)


def test_image_workflow():
    """Test workflow with image URLs."""
    urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = f"{' '.join(urls)} abstract fusion --iw {IMAGE_WEIGHT_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "abstract fusion"
    assert len(result.image_prompts) == 2
    assert [str(p) for p in result.image_prompts] == urls
    assert result.image_weight == IMAGE_WEIGHT_VALUE


def test_parameter_workflow():
    """Test workflow with various parameter types."""
    prompt = (
        "cyberpunk city --v 5.2 --style raw "
        f"--chaos {CHAOS_VALUE} --weird {WEIRD_VALUE} "
        f"--seed {SEED_VALUE} --stop {STOP_VALUE} "
        "--turbo --tile"
    )
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "cyberpunk city"
    assert result.version == "v5.2"
    assert result.style == "raw"
    assert result.chaos == CHAOS_VALUE
    assert result.weird == WEIRD_VALUE
    assert result.seed == SEED_VALUE
    assert result.stop == STOP_VALUE
    assert result.turbo is True
    assert result.tile is True


def test_new_parameters_workflow():
    """Test workflow with new parameter types."""
    prompt = (
        "portrait photo "
        f"--quality {QUALITY_VALUE} "
        f"--cw {CHARACTER_WEIGHT_VALUE} "
        f"--sw {STYLE_WEIGHT_VALUE} "
        f"--sv {STYLE_VERSION_VALUE} "
        f"--repeat {REPEAT_VALUE} "
        "--cref ref1.jpg ref2.jpg "
        "--sref style1.jpg style2.jpg "
        "--p custom_profile1 custom_profile2"
    )
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "portrait photo"
    assert result.quality == QUALITY_VALUE
    assert result.character_weight == CHARACTER_WEIGHT_VALUE
    assert result.style_weight == STYLE_WEIGHT_VALUE
    assert result.style_version == STYLE_VERSION_VALUE
    assert result.repeat == REPEAT_VALUE
    assert result.character_reference == ["ref1.jpg", "ref2.jpg"]
    assert result.style_reference == ["style1.jpg", "style2.jpg"]
    assert result.personalization == ["custom_profile1", "custom_profile2"]


def test_weighted_prompts_workflow():
    """Test workflow with weighted prompts."""
    prompt = "cyberpunk city::2 neon lights::1"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]
    assert result.text == "cyberpunk city::2 neon lights::1"


def test_error_workflow():
    """Test error handling in workflow."""
    # Test empty prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        process_prompt("")

    # Test whitespace-only prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        process_prompt("   ")

    # Test invalid parameter value - raises ValueError
    with pytest.raises(ValueError, match=r"Invalid numeric value for stylize: 2000"):
        process_prompt(f"photo --stylize {STYLIZE_VALUE * 20}")

    # Test invalid image URL - treated as extra parameter
    results = process_prompt("photo --image not_a_url")
    assert len(results) == 1
    assert len(results[0].image_prompts) == 0
    assert results[0].extra_params.get("image") == "not_a_url"


def test_complex_workflow():
    """Test workflow with multiple features combined."""
    prompt = (
        "https://example.com/img1.jpg https://example.com/img2.jpg "
        "a {vintage, modern} {portrait, landscape} "
        "with {warm, cool} tones "
        f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} "
        f"--chaos {CHAOS_VALUE} --v 5.2 --style raw "
        f"--quality {QUALITY_VALUE} --cw {CHARACTER_WEIGHT_VALUE} "
        "--turbo"
    )
    results = process_prompt(prompt)

    # 2x2x2 = 8 permutations
    assert len(results) == PERMUTATION_COUNT_2X2X2

    # Check common attributes
    for result in results:
        assert len(result.image_prompts) == 2
        assert result.aspect_width == ASPECT_WIDTH
        assert result.aspect_height == ASPECT_HEIGHT
        assert result.stylize == STYLIZE_VALUE
        assert result.chaos == CHAOS_VALUE
        assert result.version == "v5.2"
        assert result.style == "raw"
        assert result.quality == QUALITY_VALUE
        assert result.character_weight == CHARACTER_WEIGHT_VALUE
        assert result.turbo is True

    # Check text variations
    texts = {r.text for r in results}
    assert len(texts) == PERMUTATION_COUNT_2X2X2  # All combinations are unique


def test_permutations_with_parameters():
    """Test permutations with parameters are handled correctly."""
    prompt = "smooth edges {, --p} --s {75, 300}"
    results = process_prompt(prompt)

    assert len(results) == 4  # Should have 4 permutations

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (r.text.strip(), bool(r.personalization), r.stylize) for r in results
    }

    # Expected combinations
    expected = {
        ("smooth edges", False, 75),
        ("smooth edges", False, 300),
        ("smooth edges", True, 75),
        ("smooth edges", True, 300),
    }

    assert result_tuples == expected


def test_permutations_with_flag_parameters():
    """Test permutations with flag parameters (no value) are handled correctly."""
    prompt = "photo {, --tile} {, --turbo}"
    results = process_prompt(prompt)

    assert len(results) == 4  # Should have 4 permutations

    # Convert results to set of tuples for easier comparison
    result_tuples = {(r.text.strip(), r.tile is True, r.turbo is True) for r in results}

    # Expected combinations
    expected = {
        ("photo", False, False),
        ("photo", False, True),
        ("photo", True, False),
        ("photo", True, True),
    }

    assert result_tuples == expected


def test_permutations_with_complex_parameters():
    """Test permutations with complex parameter combinations."""
    prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
    results = process_prompt(prompt)

    assert len(results) == 8  # Should have 8 permutations (2 x 2 x 2)

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (
            r.text.strip(),
            r.personalization[0]
            if isinstance(r.personalization, list)
            else r.personalization,
            f"{r.aspect_width}:{r.aspect_height}",
            r.stylize,
        )
        for r in results
    }

    expected = {
        ("portrait modern", False, "1:1", 100),
        ("portrait modern", False, "16:9", 100),
        ("portrait modern", "custom", "1:1", 100),
        ("portrait modern", "custom", "16:9", 100),
        ("portrait vintage", False, "1:1", 100),
        ("portrait vintage", False, "16:9", 100),
        ("portrait vintage", "custom", "1:1", 100),
        ("portrait vintage", "custom", "16:9", 100),
    }

    assert result_tuples == expected


def test_cli_mj_command():
    """Test Midjourney prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.mj(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_cli_fal_command():
    """Test Fal.ai prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.fal(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["prompt"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_cli_perm_command():
    """Test permutation expansion using CLI."""
    cli = MidjargonCLI()
    prompt = "a {red, blue} bird on a {branch, rock}"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4
    assert "a red bird on a branch" in data
    assert "a red bird on a rock" in data
    assert "a blue bird on a branch" in data
    assert "a blue bird on a rock" in data
```

## File: tests/test_core.py (Size: 4.50 KB)

```
#!/usr/bin/env python3
# this_file: tests/test_core.py

import pytest

from midjargon import expand_midjargon_input
from midjargon.core.models import (
    MidjourneyParameters,
    MidjourneyPrompt,
)
from midjargon.core.parser import parse_midjargon_prompt
from midjargon.core.permutations import expand_permutations


def test_basic_prompt_parsing():
    """Test basic prompt parsing without parameters."""
    prompt = "a beautiful landscape"
    result = parse_midjargon_prompt(prompt)
    assert isinstance(result, MidjourneyPrompt)
    assert result.text == "a beautiful landscape"
    assert not result.image_prompts
    assert result.parameters == MidjourneyParameters()


def test_prompt_with_parameters():
    """Test prompt parsing with various parameters."""
    prompt = "a portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
    result = parse_midjargon_prompt(prompt)

    assert result.text == "a portrait"
    assert result.parameters.aspect == "16:9"
    assert result.parameters.stylize == 200
    assert result.parameters.chaos == 50
    assert result.parameters.version == "v6"


def test_prompt_with_image():
    """Test prompt parsing with image URLs."""
    prompt = "https://example.com/image.jpg a photo in this style"
    result = parse_midjargon_prompt(prompt)

    assert result.text == "a photo in this style"
    assert len(result.image_prompts) == 1
    assert str(result.image_prompts[0]) == "https://example.com/image.jpg"


def test_invalid_parameters():
    """Test handling of invalid parameters."""
    with pytest.raises(ValueError):
        parse_midjargon_prompt("test --invalid value")


def test_permutation_expansion():
    """Test permutation expansion."""
    prompt = "a {red, blue} bird on a {green, yellow} tree"
    results = expand_permutations(prompt)

    assert len(results) == 4
    assert "a red bird on a green tree" in results
    assert "a red bird on a yellow tree" in results
    assert "a blue bird on a green tree" in results
    assert "a blue bird on a yellow tree" in results


def test_escaped_permutations():
    """Test handling of escaped characters in permutations."""
    prompt = r"a {red\, orange, blue} bird"
    results = expand_permutations(prompt)

    assert len(results) == 2
    assert "a red, orange bird" in results
    assert "a blue bird" in results


def test_weighted_prompts():
    """Test handling of weighted prompts."""
    prompt = "first prompt::0.7 second prompt::0.3"
    results = expand_midjargon_input(prompt)

    assert len(results) == 2
    assert results[0].weight == 0.7
    assert results[1].weight == 0.3


def test_combined_features():
    """Test combination of multiple features."""
    prompt = "a {red, blue} bird::0.6 a {green, yellow} tree::0.4"
    results = expand_midjargon_input(prompt)

    assert len(results) == 4
    # Check first group
    red_blue = [r for r in results if "bird" in r.prompt.text]
    assert len(red_blue) == 2
    assert all("bird" in r.prompt.text for r in red_blue)
    assert all(r.weight == 0.6 for r in red_blue)

    # Check second group
    green_yellow = [r for r in results if "tree" in r.prompt.text]
    assert len(green_yellow) == 2
    assert all("tree" in r.prompt.text for r in green_yellow)
    assert all(r.weight == 0.4 for r in green_yellow)


def test_style_reference():
    """Test handling of style references."""
    # Test with code
    prompt = "test --sref p123456"
    result = parse_midjargon_prompt(prompt)
    assert result.style_reference
    assert result.style_reference[0].code == "p123456"

    # Test with URL
    prompt = "test --sref https://example.com/style.jpg"
    result = parse_midjargon_prompt(prompt)
    assert result.style_reference
    assert str(result.style_reference[0].url) == "https://example.com/style.jpg"


def test_character_reference():
    """Test handling of character references."""
    prompt = "test --cref https://example.com/char.jpg --cw 50"
    result = parse_midjargon_prompt(prompt)

    assert result.character_reference
    assert str(result.character_reference[0].url) == "https://example.com/char.jpg"
    assert result.character_weight == 50


def test_prompt_to_string():
    """Test conversion of prompt back to string format."""
    original = "a portrait --ar 16:9 --stylize 200"
    result = parse_midjargon_prompt(original)

    # Convert back to string
    output = result.to_string()

    # Parse again to verify equivalence
    reparsed = parse_midjargon_prompt(output)
    assert reparsed.text == result.text
    assert reparsed.parameters.model_dump() == result.parameters.model_dump()
```

## File: tests/test_package.py (Size: 0.18 KB)

```
# this_file: tests/test_package.py
"""Test suite for midjargon."""


def test_version():
    """Verify package exposes version."""
    import midjargon

    assert midjargon.__version__
```

## File: updateme.sh (Size: 0.45 KB)

```
#!/usr/bin/env bash
# this_file: midjargon/printme.sh
if [ -e ./midjargon.txt ]; then
    rm ./midjargon.txt
fi
if [ -z "$VIRTUAL_ENV" ]; then
    uv pip install --system gitignore-find
else
    uv pip install gitignore-find
fi
printfolder . ../midjargon.txt && mv ../midjargon.txt .

hatch run lint:style >ERRORS.txt
hatch test >>ERRORS.txt

cat midjargon.txt ERRORS.txt

echo ">> The codebase is in @midjargon.txt and the recent errors are in @ERRORS.txt"
```
</file>

<file path="_previous/test_parameters.py">
# this_file: tests/core/test_parameters.py
"""Tests for parameter parsing functionality."""

import pytest

from midjargon.core.parameters import parse_parameters


def test_basic_parameter_parsing():
    """Test parsing of basic parameters."""
    param_str = "--ar 16:9 --stylize 100"
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["stylize"] == "100"


def test_flag_parameters():
    """Test parsing of flag parameters (without values)."""
    param_str = "--tile --turbo --relax"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None


def test_parameter_with_multiple_values():
    """Test parsing parameters that accept multiple values."""
    param_str = "--no blur,cars,watermark"
    params = parse_parameters(param_str)
    assert params["no"] == "blur,cars,watermark"


def test_parameter_with_spaces():
    """Test parsing parameters with values containing spaces."""
    param_str = '--style "raw photo" --seed 123456'
    params = parse_parameters(param_str)
    assert params["style"] == "raw photo"
    assert params["seed"] == "123456"


def test_mixed_parameters():
    """Test parsing a mix of different parameter types."""
    param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["tile"] is None
    assert params["no"] == "blur,cars"
    assert params["style"] == "raw photo"


def test_shorthand_parameters():
    """Test parsing of shorthand parameter names."""
    param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
    params = parse_parameters(param_str)
    assert params["stylize"] == "100"
    assert params["chaos"] == "50"
    assert params["weird"] == "1000"
    assert params["image_weight"] == "2.0"
    assert params["quality"] == "1.0"


def test_niji_version_parameter():
    """Test parsing of niji version parameter."""
    # Test basic niji
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"


def test_version_parameter():
    """Test parsing of version parameter."""
    # Test v parameter
    params = parse_parameters("--v 5.2")
    assert params["version"] == "5.2"


def test_personalization_parameter():
    """Test parsing of personalization parameter."""
    # Test basic p parameter
    params = parse_parameters("--p")
    assert params["personalization"] is None  # Flag without value is None

    # Test p parameter with value
    params = parse_parameters("--p custom")
    assert params["personalization"] == ["custom"]

    # Test p parameter with multiple values
    params = parse_parameters("--p custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]

    # Test personalization parameter with value
    params = parse_parameters("--personalization custom")
    assert params["personalization"] == ["custom"]

    # Test personalization parameter with multiple values
    params = parse_parameters("--personalization custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]


def test_reference_parameters():
    """Test parsing of reference parameters."""
    param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
    params = parse_parameters(param_str)
    assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
    assert params["style_reference"] == ["style1.jpg", "style2.jpg"]


def test_parameter_order():
    """Test that parameter order is preserved in output."""
    param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
    params = parse_parameters(param_str)
    keys = list(params.keys())
    assert keys == ["seed", "aspect", "chaos", "tile"]


def test_invalid_parameters():
    """Test handling of invalid parameter formats."""
    with pytest.raises(ValueError, match="Empty parameter name"):
        parse_parameters("--")  # Empty parameter name

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--ar")  # Missing required value

    with pytest.raises(ValueError, match="Parameter name cannot start with dash"):
        parse_parameters("ar 16:9")  # Missing -- prefix

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--v")  # Missing version value


def test_parse_parameters():
    """Test parse_parameters function to verify parameter parsing."""
    param_str = "--ar 16:9 --stylize 100"
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["stylize"] == "100"

    param_str = "--tile --turbo --relax"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None

    param_str = "--no blur,cars,watermark"
    params = parse_parameters(param_str)
    assert params["no"] == "blur,cars,watermark"

    param_str = '--style "raw photo" --seed 123456'
    params = parse_parameters(param_str)
    assert params["style"] == "raw photo"
    assert params["seed"] == "123456"

    param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["tile"] is None
    assert params["no"] == "blur,cars"
    assert params["style"] == "raw photo"

    param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
    params = parse_parameters(param_str)
    assert params["stylize"] == "100"
    assert params["chaos"] == "50"
    assert params["weird"] == "1000"
    assert params["image_weight"] == "2.0"
    assert params["quality"] == "1.0"

    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"

    params = parse_parameters("--v 5.2")
    assert params["version"] == "5.2"

    params = parse_parameters("--p")
    assert params["personalization"] is None  # Flag without value is None

    params = parse_parameters("--p custom")
    assert params["personalization"] == ["custom"]

    params = parse_parameters("--personalization custom")
    assert params["personalization"] == ["custom"]

    param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
    params = parse_parameters(param_str)
    assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
    assert params["style_reference"] == ["style1.jpg", "style2.jpg"]

    param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
    params = parse_parameters(param_str)
    keys = list(params.keys())
    assert keys == ["seed", "aspect", "chaos", "tile"]

    with pytest.raises(ValueError, match="Empty parameter name"):
        parse_parameters("--")  # Empty parameter name

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--ar")  # Missing required value

    with pytest.raises(ValueError, match="Parameter name cannot start with dash"):
        parse_parameters("ar 16:9")  # Missing -- prefix

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--v")  # Missing version value


def test_flag_parameters_handling():
    """Test handling of flag parameters in parse_parameters."""
    param_str = "--tile --turbo --relax --video --remix"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None
    assert params["video"] is None
    assert params["remix"] is None

    param_str = "--p"
    params = parse_parameters(param_str)
    assert params["personalization"] is None  # Flag without value is None

    param_str = "--p custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]

    param_str = "--personalization custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]


def test_special_seed_values():
    """Test handling of special seed values."""
    # Test random seed
    params = parse_parameters("--seed random")
    assert params["seed"] == "random"

    # Test numeric seed
    params = parse_parameters("--seed 12345")
    assert params["seed"] == "12345"


def test_reference_url_handling():
    """Test handling of URLs in reference parameters."""
    # Test character reference with quoted URL containing spaces
    params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
    assert params["character_reference"] == [
        "https://example.com/image with spaces.jpg"
    ]

    # Test style reference with quoted URL containing spaces
    params = parse_parameters('--sref "https://example.com/style with spaces.jpg"')
    assert params["style_reference"] == ["https://example.com/style with spaces.jpg"]

    # Test character reference with single URL (no quotes)
    params = parse_parameters("--cref https://example.com/image.jpg")
    assert params["character_reference"] == ["https://example.com/image.jpg"]

    # Test style reference with single URL (no quotes)
    params = parse_parameters("--sref https://example.com/style.jpg")
    assert params["style_reference"] == ["https://example.com/style.jpg"]


def test_niji_version_handling():
    """Test handling of niji version parameter."""
    # Test basic niji flag
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 5")
    assert params["version"] == "niji 5"

    # Test niji with version in permutation
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"

    # Ensure no 'v' prefix is added
    version = str(params["version"])  # Convert to string to use startswith
    assert not version.startswith("v")
</file>

<file path="_previous/test_workflow.py">
#!/usr/bin/env python3
# this_file: tests/integration/test_workflow.py
"""Integration tests for complete midjargon workflow."""

import sys
from io import StringIO

import pytest

from midjargon import expand_midjargon_input, parse_midjargon_prompt_to_dict
from midjargon.cli.main import MidjargonCLI
from midjargon.core.models import MidjourneyPrompt
from midjargon.engines.midjourney import parse_midjourney_dict
from tests.cli.test_main import parse_json_output  # Added import for JSON parsing

# Test constants
ASPECT_WIDTH = 16
ASPECT_HEIGHT = 9
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
WEIRD_VALUE = 1000
SEED_VALUE = 12345
STOP_VALUE = 80
IMAGE_WEIGHT_VALUE = 2.0
QUALITY_VALUE = 1.0
CHARACTER_WEIGHT_VALUE = 100
STYLE_WEIGHT_VALUE = 200
STYLE_VERSION_VALUE = 2
REPEAT_VALUE = 3
PERMUTATION_COUNT_2X2 = 4  # 2 options x 2 options
PERMUTATION_COUNT_2X2X2 = 8  # 2 options x 2 options x 2 options


def process_prompt(prompt: str) -> list[MidjourneyPrompt]:
    """Process a prompt through the complete workflow."""
    # Step 1: Expand permutations
    expanded = expand_midjargon_input(prompt)

    # Step 2: Parse each expanded prompt to a dictionary
    midjargon_dicts = [
        parse_midjargon_prompt_to_dict(variant.prompt.to_string())
        for variant in expanded
    ]

    # Step 3: Convert each dictionary to a MidjourneyPrompt
    return [parse_midjourney_dict(d) for d in midjargon_dicts]


def test_basic_workflow():
    """Test basic prompt workflow without permutations."""
    prompt = f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "a beautiful landscape"
    assert result.aspect_width == ASPECT_WIDTH
    assert result.aspect_height == ASPECT_HEIGHT
    assert result.stylize == STYLIZE_VALUE


def test_permutation_workflow():
    """Test workflow with permutations."""
    prompt = f"a {{red, blue}} bird on a {{branch, rock}} --stylize {STYLIZE_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == PERMUTATION_COUNT_2X2  # 2x2 permutations
    texts = {r.text for r in results}
    expected = {
        "a red bird on a branch",
        "a red bird on a rock",
        "a blue bird on a branch",
        "a blue bird on a rock",
    }
    assert texts == expected
    assert all(r.stylize == STYLIZE_VALUE for r in results)


def test_image_workflow():
    """Test workflow with image URLs."""
    urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = f"{' '.join(urls)} abstract fusion --iw {IMAGE_WEIGHT_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "abstract fusion"
    assert len(result.image_prompts) == 2
    assert [str(p) for p in result.image_prompts] == urls
    assert result.image_weight == IMAGE_WEIGHT_VALUE


def test_parameter_workflow():
    """Test workflow with various parameter types."""
    prompt = (
        "cyberpunk city --v 5.2 --style raw "
        f"--chaos {CHAOS_VALUE} --weird {WEIRD_VALUE} "
        f"--seed {SEED_VALUE} --stop {STOP_VALUE} "
        "--turbo --tile"
    )
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "cyberpunk city"
    assert result.version == "v5.2"
    assert result.style == "raw"
    assert result.chaos == CHAOS_VALUE
    assert result.weird == WEIRD_VALUE
    assert result.seed == SEED_VALUE
    assert result.stop == STOP_VALUE
    assert result.turbo is True
    assert result.tile is True


def test_new_parameters_workflow():
    """Test workflow with new parameter types."""
    prompt = (
        "portrait photo "
        f"--quality {QUALITY_VALUE} "
        f"--cw {CHARACTER_WEIGHT_VALUE} "
        f"--sw {STYLE_WEIGHT_VALUE} "
        f"--sv {STYLE_VERSION_VALUE} "
        f"--repeat {REPEAT_VALUE} "
        "--cref ref1.jpg ref2.jpg "
        "--sref style1.jpg style2.jpg "
        "--p custom_profile1 custom_profile2"
    )
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "portrait photo"
    assert result.quality == QUALITY_VALUE
    assert result.character_weight == CHARACTER_WEIGHT_VALUE
    assert result.style_weight == STYLE_WEIGHT_VALUE
    assert result.style_version == STYLE_VERSION_VALUE
    assert result.repeat == REPEAT_VALUE
    assert result.character_reference == ["ref1.jpg", "ref2.jpg"]
    assert result.style_reference == ["style1.jpg", "style2.jpg"]
    assert result.personalization == ["custom_profile1", "custom_profile2"]


def test_weighted_prompts_workflow():
    """Test workflow with weighted prompts."""
    prompt = "cyberpunk city::2 neon lights::1"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]
    assert result.text == "cyberpunk city::2 neon lights::1"


def test_error_workflow():
    """Test error handling in workflow."""
    # Test empty prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        process_prompt("")

    # Test whitespace-only prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        process_prompt("   ")

    # Test invalid parameter value - raises ValueError
    with pytest.raises(ValueError, match=r"Invalid numeric value for stylize: 2000"):
        process_prompt(f"photo --stylize {STYLIZE_VALUE * 20}")

    # Test invalid image URL - treated as extra parameter
    results = process_prompt("photo --image not_a_url")
    assert len(results) == 1
    assert len(results[0].image_prompts) == 0
    assert results[0].extra_params.get("image") == "not_a_url"


def test_complex_workflow():
    """Test workflow with multiple features combined."""
    prompt = (
        "https://example.com/img1.jpg https://example.com/img2.jpg "
        "a {vintage, modern} {portrait, landscape} "
        "with {warm, cool} tones "
        f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} "
        f"--chaos {CHAOS_VALUE} --v 5.2 --style raw "
        f"--quality {QUALITY_VALUE} --cw {CHARACTER_WEIGHT_VALUE} "
        "--turbo"
    )
    results = process_prompt(prompt)

    # 2x2x2 = 8 permutations
    assert len(results) == PERMUTATION_COUNT_2X2X2

    # Check common attributes
    for result in results:
        assert len(result.image_prompts) == 2
        assert result.aspect_width == ASPECT_WIDTH
        assert result.aspect_height == ASPECT_HEIGHT
        assert result.stylize == STYLIZE_VALUE
        assert result.chaos == CHAOS_VALUE
        assert result.version == "v5.2"
        assert result.style == "raw"
        assert result.quality == QUALITY_VALUE
        assert result.character_weight == CHARACTER_WEIGHT_VALUE
        assert result.turbo is True

    # Check text variations
    texts = {r.text for r in results}
    assert len(texts) == PERMUTATION_COUNT_2X2X2  # All combinations are unique


def test_permutations_with_parameters():
    """Test permutations with parameters are handled correctly."""
    prompt = "smooth edges {, --p} --s {75, 300}"
    results = process_prompt(prompt)

    assert len(results) == 4  # Should have 4 permutations

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (r.text.strip(), bool(r.personalization), r.stylize) for r in results
    }

    # Expected combinations
    expected = {
        ("smooth edges", False, 75),
        ("smooth edges", False, 300),
        ("smooth edges", True, 75),
        ("smooth edges", True, 300),
    }

    assert result_tuples == expected


def test_permutations_with_flag_parameters():
    """Test permutations with flag parameters (no value) are handled correctly."""
    prompt = "photo {, --tile} {, --turbo}"
    results = process_prompt(prompt)

    assert len(results) == 4  # Should have 4 permutations

    # Convert results to set of tuples for easier comparison
    result_tuples = {(r.text.strip(), r.tile is True, r.turbo is True) for r in results}

    # Expected combinations
    expected = {
        ("photo", False, False),
        ("photo", False, True),
        ("photo", True, False),
        ("photo", True, True),
    }

    assert result_tuples == expected


def test_permutations_with_complex_parameters():
    """Test permutations with complex parameter combinations."""
    prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
    results = process_prompt(prompt)

    assert len(results) == 8  # Should have 8 permutations (2 x 2 x 2)

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (
            r.text.strip(),
            r.personalization[0]
            if isinstance(r.personalization, list)
            else r.personalization,
            f"{r.aspect_width}:{r.aspect_height}",
            r.stylize,
        )
        for r in results
    }

    expected = {
        ("portrait modern", False, "1:1", 100),
        ("portrait modern", False, "16:9", 100),
        ("portrait modern", "custom", "1:1", 100),
        ("portrait modern", "custom", "16:9", 100),
        ("portrait vintage", False, "1:1", 100),
        ("portrait vintage", False, "16:9", 100),
        ("portrait vintage", "custom", "1:1", 100),
        ("portrait vintage", "custom", "16:9", 100),
    }

    assert result_tuples == expected


def test_cli_mj_command():
    """Test Midjourney prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.mj(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_cli_fal_command():
    """Test Fal.ai prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.fal(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["prompt"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_cli_perm_command():
    """Test permutation expansion using CLI."""
    cli = MidjargonCLI()
    prompt = "a {red, blue} bird on a {branch, rock}"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4
    assert "a red bird on a branch" in data
    assert "a red bird on a rock" in data
    assert "a blue bird on a branch" in data
    assert "a blue bird on a rock" in data
</file>

<file path=".github/workflows/push.yml">
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/midjargon --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/midjargon
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path="VERSION.txt">
v1.8.1
</file>

<file path="docs/prompts_results2.txt">
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 12345,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 67890,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "text": "\"Lost in translation\" neon sign in a Tokyo alleyway",
  "image_prompts": [],
  "stylize": 750,
  "chaos": 0,
  "weird": 250,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "text": "\"Made in Midjourney\" stamp on a vintage postage stamp",
  "image_prompts": [],
  "stylize": 1000,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 2,
  "aspect_ratio": "1:2",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "zoom": "1.5"
  }
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'expressive', 'original', 'raw', 'scenic'} [type=value_error, input_value='default', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 16,
    "aspect_height": 9,
    "aspect_ratio": "16:9",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 16,
    "aspect_height": 9,
    "aspect_ratio": "16:9",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "text": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 2,
  "aspect_height": 3,
  "aspect_ratio": "2:3",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "text": "A cat in a Tundra environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a Jungle environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a City environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "text": "A cyberpunk cat with a neon sign that says \"Midjourney\"",
  "image_prompts": [],
  "stylize": 500,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "text": "A pastel watercolor landscape with \"/imagine\" written in the clouds",
  "image_prompts": [],
  "stylize": 250,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 16,
  "aspect_height": 9,
  "aspect_ratio": "16:9",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'original', 'cute', 'raw', 'expressive'} [type=value_error, input_value='random-64', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
{
  "error": "Invalid value for seed: random - Invalid numeric value: could not convert string to float: 'random'"
}======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "text": "A continuous line charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A loose gestural charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'raw', 'expressive', 'original', 'cute', 'scenic'} [type=value_error, input_value='random', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'original', 'raw', 'cute', 'expressive'} [type=value_error, input_value='random-16', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'expressive', 'scenic', 'raw', 'cute', 'original'} [type=value_error, input_value='random-128', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "text": "An impressionistic watercolor of a cat playing chess with a dog",
  "image_prompts": [],
  "stylize": 50,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 4,
  "aspect_height": 3,
  "aspect_ratio": "4:3",
  "style": "raw",
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": "board, pieces",
  "extra_params": {}
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "text": "cheese:: cake:: painting multi-prompt",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 60,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v4",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "negative": "weight fruit::-.5"
  }
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
{
  "error": "1 validation error for MidjourneyPrompt\nversion\n  Value error, Invalid version value. Must be one of: {'6.1', '3', '2', '1', '5.0', '5.1', '6', '5', '4', '5.2'} [type=value_error, input_value='vniji 5', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "text": "image of a robot holding flowers",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "remix": null,
    "prompt": "A cyborg holding cybernetic orchids",
    "zoom": "2x"
  }
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "medieval",
      "tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "medieval",
      "tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "medieval",
      "tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "medieval",
      "tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "text": "stream running through a redwood forest",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "vary": "region",
    "selection": "sky area",
    "prompt": "aurora borealis",
    "pan": "up"
  }
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]
</file>

<file path="docs/prompts.txt">
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
space:: ship multi-prompt  --stylize {250, 750} --weird 500
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
{Happy, Angry, Shy} cat --style raw --chaos 60 --quality 1 --repeat 3
</file>

<file path=".pre-commit-config.yaml">
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path=".devcontainer/devcontainer.json">
{
  "tasks": {
    "build": "uv pip install --system --upgrade \".[all]\" && pre-commit install"
  }
}
</file>

<file path="docs/midjourney-docs.md">
# Midjourney Docs

## Chapter 1: Web Quick Start

Web Quick Start

Check out this video for a quick introduction to midjourney.com, then follow the guide below to create your first images!

### Making Images on midjourney.com

1\. Make Images from the Imagine Bar

At the top of most pages on the website, you'll see the imagine bar. To start making images, type a prompt into the bar and hit enter.

Once your images start generating, you can find them on the Create tab. Click over to see your results.

2\. Make Variations

From the Create tab, you can see all the images you've made. Click on an image to open the lightbox. Once you have an image you like, you can make new versions with variations.

The lightbox also shows additional tools to help you refine and experiment with your images. Learn more about other buttons in the lightbox on their feature pages: Upscale, Reframe, Repaint.

3\. Change Your Settings

The  button in the imagine bar lets you set default parameters for all your prompts. You can adjust the aspect ratio, stylization, and variety of your images, or adjust your generation speed and stealth.

4\. Use Images in Your Prompts

Midjourney can use existing images as inspiration for brand new ones. If you see an image you like on the Explore page, or want to use an image you generated as a style reference for a totally new prompt, drag and drop that image to the imagine bar.

There are three different ways you can use images:

For a deep dive into using reference images, check out our Working with Images on Web page.

5\. Save and Manage Images

If you're ready to download your images, or want to filter or organize them, visit the Archive tab.

Wherever you see the  button, you can click to save an individual image. You can also download your images in bulk by clicking outside the grid and dragging to make a selection.

You can find more information about the filters and other options on the Archive here.

6\. Create Collaboratively with Chat

Nothing beats the creative energy that comes from making images with others! On the  Chat tab, you can find (or create!) shared spaces to work together with other users.

Need some inspiration? Check out the Daily Theme chat every day to pick up a new theme for your prompts! Hang out there to see the creative ways other users are incorporating the day's theme, or create alongside them.

### Need Help?

You can learn more about all of Midjourney's features and how to use them right here in our documentation. Some popular features:

Setting a non-square aspect ratio

Using an image as an image, style, or character reference

Using the describe feature with an image you like will suggest words and phrases you can use in your prompts to generate similar images

You can ask questions any time in the Help Room.

If you need help with your account, you can browse helpful billing FAQs or submit a ticket to our billing team by visiting help.midjourney.com.



ARTICLE: 

### Making Images on midjourney.com

1\. Make Images from the Imagine Bar

2\. Make Variations

3\. Change Your Settings

4\. Use Images in Your Prompts

5\. Save and Manage Images

6\. Create Collaboratively with Chat

Need Help?

### Discord Quick Start

Discord Quick Start

Use the Midjourney bot to generate stunning images from simple text prompts in seconds. Work directly in Discord. No specialized hardware or software is required.

Code of Conduct

Don't be a jerk.

Don't use our tools to make images that could inflame, upset, or cause drama. That includes gore and adult content.

Be respectful to other people and the team.

### Making Images with Midjourney

1\. Log In To Discord

Access the Midjourney Bot through Discord via web browser, mobile app, or desktop app. Ensure you have a verified Discord account before joining the Midjourney Discord server.

Follow these guides to create or verify your Discord account:  
Create Discord Account  
Verify Discord Account

2\. Subscribe to a Midjourney Plan

To start generating images with Midjourney, you'll need to subscribe to a plan.

Visit Midjourney.com.

Log in using your verified Discord account.

Choose a subscription plan that suits your needs.

Go to Subscription Plans for information on pricing and the features available with each tier.

3\. Join the Midjourney Server on Discord

To start interacting with the Midjourney Bot, join the Midjourney Server

Open Discord and locate the server list on the left-hand sidebar.

Press the `+` button at the bottom of the server list.

In the pop-up window, click the `Join a Server` button.

Paste or type the following URL: http://discord.gg/midjourney and press `Join`.

For additional information, Learn more about Discord servers.

4\. Go to any #General or #Newbie Channel

After joining the Midjourney server on Discord, you'll see several channels listed in the sidebar.

On the Midjourney Server

Locate and select any channel labeled `general-#` or `newbie-#`. These channels are designed for beginners to start using the Midjourney Bot. The Midjourney Bot will not generate images in other channels.

On Other Servers

You can generate images with the Midjourney Bot on any Discord server that has invited the Midjourney Bot. Look for instructions on your server on where to use the Bot.

5.Use the /imagine Command

About Discord Commands  
Interact with the Midjourney Bot on Discord using a Command. Commands are used to create images, change default settings, monitor user info, and perform other helpful tasks. The `/imagine` command generates a unique image from a short text description (known as a Prompt). Learn more about Prompts

How to Use `/imagine`

Type '/imagine prompt:' in the message field. You can also select the `/imagine` command from the list of available slash commands that pop up when you type '/'.

Type a description of the image you want to create in the `prompt` field.

Send your message. The Bot will interpret your text prompt and begin generating the images.

Respect the Community Guidelines. Community guidelines apply wherever the Midjourney Bot is used.

6.Accept the Terms Of Service

Before generating any images, the Midjourney Bot will prompt you to accept the Terms Of Service. You must agree to these terms to proceed with image creation.

7.Image Generation Process

After submitting a text prompt, the Midjourney Bot processes your request, creating four unique image options within a minute. This process utilizes advanced Graphics Processing Units (GPUs), and each image generation counts towards the GPU time included with your Midjourney subscription. To monitor your available GPU time (Fast Time Remaining) use the `/info` command.

8.Select an Image or Create Variations

Once your initial image grid has been generated, two rows of buttons become available underneath your image grid.

`U1` `U2` `U3` `U4` Image Selection

In earlier versions of Midjourney, the `U` buttons were used for upscaling images. With the latest model, images are immediately generated at 1024 x 1024 pixels size. Now, the 'U' buttons help you separate out your chosen image from the grid, making it easier to download and giving you access to additional editing and generation tools.

`` Re-run or Re-roll a Job

The `` button re-runs a Job. In this case, it would re-run the original prompt producing a new grid of images.

`V1` `V2` `V3` `V4` Image Variation

The `V` buttons are used to create variations of the selected image. Each button generates a new image grid that maintains the general style and composition of the selected image.

9.Enhance or Modify Your Image

After singling out an image, an expanded set of options becomes available.

` Vary (Strong)` ` Vary (Subtle)`

Create a stronger or subtle variation of your selected image, generating a new grid of four options.

` Zoom Out 2x` ` Zoom Out 1.5x` ` Custom Zoom`

Zoom Out of your image, extending the canvas its original boundaries without changing the content of the original image. The newly expanded canvas will be filled-in using guidance from the prompt and the original image.

`` `` `` ``

The Pan buttons allow you to expand the canvas of an image in a chosen direction without changing the content of the original image. The newly expanded canvas will be filled in using guidance from the prompt and the original image.

` Favorite`

tag your best images to easily find them on the Midjourney website.

`Web `

Open the image in your gallery on midjourney.com

10.Save Your Image

Click on the image to open it to full size, and then right-click and choose `Save image`. On mobile, long-tap the image and then tap the download icon in the top right corner.

All images are immediately available to view on midjourney.com/imagine

### Next Steps

Direct Messaging the Midjourney Bot  
Are you having difficulty finding yourself while working with other users on the Midjourney server? You can interact with the Midjourney Bot one-on-one in a direct message. Images created within your direct messages are still subject to content and moderation rules and are visible on the Midjourney website.

Learn More About Prompts  
Learn how to write effective and creative prompts, 
Explore how descriptions of artistic mediums, locations, and time periods change an image.

Blend Your Own Images  
Learn how to upload and blend your own images using the `/blend` command.

### Midjourney Bot Assistance

Need help or have questions? Try these commands:  
`/help` Displays useful information and tips about the Midjourney Bot.  
`/ask` Provides answers to questions about the Midjourney Bot.

You can also visit the #support channel on the Midjourney Discord for additional assistance.

### Billing and Subscription Queries

For billing and subscription questions, please visit help.midjourney.com.

You can interact with the Midjourney Bot on Discord by typing aCommand. Commands are used to create images, change default settings, monitor user info, and perform other helpful tasks.

Midjourney Commands can be used in any Bot Channel, on private Discord servers where the Midjourney Bot has been permitted to operate, or in a direct message with the Midjourney Bot.

A Prompt is a short text phrase that the Midjourney Bot interprets to produce an image. The Midjourney Bot breaks down the words and phrases in a prompt into smaller pieces, called tokens, that can be compared to its training data and then used to generate an image. A well-crafted prompt can help make unique and exciting images.



------

## Chapter 2: Making Images with Midjourney

1\. Log In To Discord

2\. Subscribe to a Midjourney Plan

3\. Join the Midjourney Server on Discord

4\. Go to any #General or #Newbie Channel

On the Midjourney Server

On Other Servers

5.Use the /imagine Command

6.Accept the Terms Of Service

7.Image Generation Process

8.Select an Image or Create Variations

9.Enhance or Modify Your Image

10.Save Your Image

Next Steps

Midjourney Bot Assistance

Billing and Subscription Queries

### Community Guidelines

Community Guidelines

TL; DR

Midjourney is an open-by-default community. To keep the platform accessible and welcoming to the broadest number of users, content must be `Safe For Work` (SFW).

We have 4 main rules

Be kind and respect each other

SFW content only

Be thoughtful about how you share your creations

Unauthorized automation & third party apps are not allowed

Thank you for helping us make Midjourney a safe, welcoming space for everyone.

If you see someone violating these guidelines, you can report it here.

Please use these incredible powers with joy, wonder, responsibility and respect.

### Rules

Be kind and respect each other

Be kind and respect each other and staff. Violent behavior, harassment or incitement of any kind will not be tolerated.

Do not create images or use text prompts that are inherently disrespectful, aggressive, or otherwise abusive.

Do not create or use imagery of real people, famous or otherwise, that could be used to harass, abuse, defame, or otherwise harm.

Respect others rights. Do not attempt to find out others' private information. Do not upload others private information.

SFW content only

Do not create or attempt to create gore or adult content. Avoid making visually shocking or disturbing content.

What is Considered Gore? Gore includes images of detached body parts of humans or animals, cannibalism, blood, violence (images of shooting or bombing someone, for instance), mutilated bodies, severed limbs, pestilence, etc.

What is NSFW or Adult Content? Avoid nudity, sexual organs, fixation on such things, sexualized imagery, fetishes, people in showers, on toilets, etc.

Do not create or attempt to create content that in any way sexualizes children or minors. This includes real images as well as generated images. Do not generate, upload, share, or make attempts to distribute content that depicts, promotes, or attempts to normalize child sexual abuse.

Do not create other offensive content. Other things may be deemed offensive or abusive because they can be viewed as racist, homophobic, disturbing, or in some way derogatory to a community. This includes offensive or inflammatory images of celebrities or public figures.

Be thoughtful about how you share your creations

Do not publicly repost the creations of others without their permission.

Be careful about sharing. Its okay to share your creations outside of the Midjourney community, but please consider how others might view your content.

Do not generate images to spread misinformation or disinformation.

Do not generate images for political campaigns or to try to influence the outcome of an election.

Do not generate images to attempt to or to actually deceive or defraud anyone.

Do not intentionally mislead recipients of generated images about their nature or source.

Unauthorized automation and third party apps are not allowed

In order to maintain the highest quality experience for all users, Midjourney accounts are designed for individual use and each user may maintain only one account.

With a few rare exceptions that are explicitly granted, Midjourney does not provide an API, nor provide third-party apps or scripts, and automating interactions with Midjourney service is strictly prohibited according to our Terms of Service. Accounts who do not comply with these rules may be blocked.

You may not resell or redistribute Midjourney Services or access to the Service (this includes sharing your account).

Moderation Policy Notes

Midjourney will block some text and image inputs automatically. An input not being automatically blocked does not necessarily mean that it is allowed.

Users who violate the Terms of Service may be warned by a community moderator, given a time-out, or be blocked from the service.

If you see someone elses content that breaks the rules, please report it.

Overall Policy Notes

The above rules apply to all content, including images made in private servers, images deleted/hidden, using Stealth Mode, in direct messages with the Midjourney Bot, and Midjourney websites.

Any violations of these rules may lead to bans from our services.

Midjourney is both a product and community. We may revoke your access to the community separately from access to the product.

Content guidelines are continually reviewed and may be modified as the Midjourney community grows.

Do not generate images for illegal activity or upload images to our servers that involve illegal activity, or where the uploading itself may be illegal.

This is not an exhaustive list. We may take action against users that violate the spirit of these guidelines, even if their actions are not explicitly prohibited.

We are a small team striving to balance the needs of the broadest number of users in our community. Our decision making process is not a democracy, but we take feedback on moderation very seriously.

Most importantly, have fun!

### Specific Community Guidelines & Important Reminders for External Image Editor

The editor is a powerful new tool for unleashing imagination. Its not for creating images that might deceive, harass, or maliciously harm others.

Do not abuse the editor to manipulate images of real people, famous or otherwise, in ways that could lead to harassment, abuse, or harm.

Do not abuse the editor to create images intended to offend, deceive, or maliciously harm others.

Do not abuse the editor to create NSFW or sexualized imagery. We will take especially strict action against anyone attempting to produce sexualized images of real people.

Anyone attempting to violate our Community Guidelines using the editor will face suspension or banning without refund.  
Use this tool with respect and consideration for others.

### Self-Policing and Reporting

Occasionally prompts will unintentionally produce not safe for work content. Please self-police these images by using the  emoji reaction or by right-clicking selecting Apps and then clicking `Cancel Job` to delete the image.

Users may flag any image for moderator review by right-clicking selecting Apps, and then clicking `Report Job` within Discord or the website by selecting `...` under an image and clicking `Report`.

Report Images in Discord

Report Images on the Website

### 



------

## Chapter 3: Rules

Specific Community Guidelines & Important Reminders for External Image Editor

Self-Policing and Reporting

### Prompts

Prompts

A prompt is a short text phrase that the Midjourney Bot interprets to produce an image. The Midjourney Bot breaks down the words and phrases in a prompt into smaller pieces, called tokens, that are compared to its training data and then used to generate an image. A well-crafted prompt can help make unique and exciting images.

Basic Prompts

A basic prompt can be as simple as a single word, phrase or emoji .

Prompting Tip!

The Midjourney Bot works best with simple, short phrases that describe what you want to see. Avoid long lists of requests and instructions. Instead of: Show me a picture of lots of blooming California poppies, make them bright, vibrant orange, and draw them in an illustrated style with colored pencils Try: Bright orange California poppies drawn with colored pencils

### Advanced Prompts

More advanced prompts can include one or more image URLs, multiple text phrases, and one or more parameters

`Image Prompts`

Image URLs can be added to a prompt to influence the style and content of the finished result. Image URLs always go at the front of a prompt.

Read more about Image Prompts

`Text Prompt`

The text description of what image you want to generate. See below for prompting information and tips. Well-written prompts help generate amazing images.

`Parameters`

Parameters change how an image generates. Parameters can change aspect ratios, models, upscalers, and lots more. Parameters go at the end of the prompt.

Read more about Parameters

### Prompting Notes

Word Choice

Word choice matters. More specific synonyms work better in many circumstances. Instead of big, try huge, gigantic, enormous, or immense.

Plural words and Collective Nouns

Plural words leave a lot to chance. Try specific numbers. "Three cats" is more specific than "cats." Collective nouns also work, flock of birds instead of "birds.

Focus on What You Want

It is better to describe what you want instead of what you dont want. If you ask for a party with no cake,  your image will probably include a cake. To ensure an object is not in the final image, try advanced prompting using the `--no` parameter.

Prompt Length and Details

Prompts can be simple. A single word or emoji will work. However, short prompts rely on Midjourneys default style, allowing it to fill in any unspecified details creatively. Include any element that is important to you in your prompt. Fewer details means more variety but less control.

Try to be clear about any context or details that are important to you. Think about:

Subject: person, animal, character, location, object

Medium: photo, painting, illustration, sculpture, doodle, tapestry

Environment: indoors, outdoors, on the moon, underwater, in the city

Lighting: soft, ambient, overcast, neon, studio lights

Color: vibrant, muted, bright, monochromatic, colorful, black and white, pastel

Mood: sedate, calm, raucous, energetic

Composition: portrait, headshot, closeup, birds-eye view



------

## Chapter 4: Basic Prompts

Advanced Prompts

Prompting Notes

Word Choice

Plural words and Collective Nouns

Focus on What You Want

Prompt Length and Details

### Explore Prompting

Explore Prompting

Even short single-word prompts will produce beautiful images in Midjourney's default style, but you can create more interesting personalized results by combining concepts like artistic medium, historical periods, location, and more.

### Pick A Medium

Break out the paint, crayons, scratchboard, printing presses, glitter, ink, and colored paper. One of the best ways to generate a stylish image is by specifying an artistic medium.

prompt example: `/imagine prompt` `<any art style> style cat`

Block Print

Ballpoint Pen Sketch

Cyanotype

Graffiti

Paint-by-Numbers

Risograph

Ukiyo-e

Pencil Sketch

Watercolor

Pixel Art

Blacklight Painting

Cross Stitch

Acrylic Pour

Cut Paper

Pressed Flower

### Get Specific

More precise words and phrases will help create an image with exactly the right look and feel.

prompt example: `/imagine prompt` `<style> sketch of a cat`

Life Drawing

Continuous Line

Loose Gestural

Value Study

Charcoal

### Time Travel

Different eras have distinct visual styles.

prompt example: `/imagine prompt` `an illustration of a <time period> cat`

1400s

1500s

1600s

1700s

1800s

1900s

1910s

1920s

1930s

1940s

1950s

1960s

1970s

1980s

1990s

### Emote

Use emotion words to give characters personality.

prompt example: `/imagine prompt` `<emotion> cat`

Determined

Happy

Sleepy

Angry

Shy

### Get Colorful

A full spectrum of possibilities.

prompt example: `/imagine prompt` `<color word> colored cat`

Millennial Pink

Acid Green

Desaturated

Canary Yellow

Peach

Two Toned

Pastel

Mauve

Ebony

Neutral

CMYK

Blue Tinted

Iridescent

Brightly

Pink and Blue

### Environmental Exploration

Different environments can set unique moods.

prompt example: `/imagine prompt` `<location> cat`

Tundra

Salt Flat

Jungle

Desert

Forest

Cave

Farm

Crystal Forest

City

Garden



------

## Chapter 5: Pick A Medium

Get Specific

Time Travel

Emote

Get Colorful

Environmental Exploration

### Variations

Variations

Use the `V1` `V2` `V3` `V4` buttons under each image grid, or use the `Vary (Strong)` and `Vary (Subtle)` buttons under an upscaled image to generate different versions of that image.

The `V` buttons correspond to the images in each generated grid from left to right, top to bottom, like this: `.

Control your default amount of variation when using the `V` buttons with the ` High Variation Mode` and ` Low Variation Mode` in your settings. ` High Variation Mode` is the default.

You can also use the `/prefer variability` command to toggle between High and Low Variation Modes.

Under upscaled images, the ` Vary (Strong)` button corresponds to ` High Variation Mode`, while ` Vary (Subtle)` corresponds to ` Low Variation Mode`. These buttons ignore your personal settings.

Want to change your prompt while you make variations? Enable `Remix Mode` in your settings. Learn more about using Remix Mode and how it interacts with your variation settings here.

### Variation Examples

When using Midjourney Version 5 or 6, or Niji Version 5 or 6, you can choose between High and Low variation modes.

The default ` High Variation Mode` will produce new images that vary from the original image in composition, number of elements, colors, and types of details. To use High Variation Mode, click a `V` button beneath a grid while you have it selected in settings, or click the ` Vary (Strong)` button beneath an upscaled image.

` Low Variation Mode` will produce new images that retain the composition and colors of the original, but with subtle changes to the image details. To use Low Variation Mode, select it in `/settings` and click the `V` button corresponding to the iamge you want to vary, or click the ` Vary (Subtle)` button beneath an upscaled image.

Prompt example: `/imagine prompt` `a cute robot holding flowers`

Original Upscaled Image

Image grid using `Vary (Subtle)`

Image grid using `Vary (Strong)`

Prompt example: `/imagine prompt` `a bird watching a butterfly`

Original Upscaled Image

Image grid using `Vary (Subtle)`

Image grid using `Vary (Strong)`



------

## Chapter 6: Upscalers

Upscalers

The current Midjourney and Niji Model Versions produce grids of 1024 x 1024 pixel images. Use the `U1` `U2` `U3` `U4` buttons under each image grid to separate your selected image from its grid. You can then use the `Upscale (Creative)` or `Upscale (Subtle)` tools to increase the size of your image.

The `Upscale (Subtle)` option doubles the size of your image and keeps details very similar to the original. `Upscale (Creative)` also doubles the size of your image but adds new details to the image. Experiment with each upscaler option to find the one most suitable for the style of your image.

`Upscale` tools use your subscription's GPU minutes. Upscaling can take up to twice as many GPU minutes as generating an initial image grid.

`Upscale` tools in Midjourney Version 5.x and 6.0 are not compatible with the --tile parameter.

### How to Use the Upscale Tools

1\. Generate an Image

Create an image using the `/imagine` command.

2\. Select an Image

Use a `U` button to separate your selected image from the grid.

3\. Select Upscale 

Click on the `Upscale (Subtle)` or `Upscale (Creative)` button to upscale your image. The upscalers will double the size of your image to 2048 x 2048 pixels.

Upscale Comparison

Prompt: `chiaroscuro rooster portrait`  
Original 1024 by 1024 pixel image.

Detail from original image

Original image

After upscaling to 2048 x 2048 px

Upscale Comparison

Prompt: `1960s pop-art acrylic painting of a stream running through a redwood forest`

Original image

Subtle upscale

Creative upscale

Detail from original image

Detail from subtle upscale

Detail from creative upscale

Upscale Tip

Upscale jobs you generated before new upscalers were released by refreshing them with the /show command. Buttons for all upscalers compatible with that image will appear under the refreshed job.

### Legacy Upscalers

Earlier Midjourney model versions generated grids of lower-resolution images. You can use a legacy Midjourney upscaler on these images to increase the size and add additional details. There are multiple legacy upscale models available for upscaling images made with earlier Midjourney models. Using a legacy upscaler uses your subscription's GPU minutes.

The Midjourney Bot processes jobs on high-end GPUs. Each minute that it takes to complete a job is a GPU minute. You have a limited amount of GPU minutes when in Fast Mode. Because image generations may be processed on multiple GPUs simultaneously, GPU minutes are not directly connected to the time you wait for an image to generate.

The Midjourney Bot processes jobs on high-end GPUs. Each minute that it takes to complete a job is a GPU minute. You have a limited amount of GPU minutes when in Fast Mode. Because image generations may be processed on multiple GPUs simultaneously, GPU minutes are not directly connected to the time you wait for an image to generate.



------

## Chapter 7: How to Use the Upscale Tools

1\. Generate an Image

2\. Select an Image

3\. Select Upscale 

Upscale Comparison

Detail from original image

Upscale Comparison

Legacy Upscalers

### Vary Region

Vary Region

Use the Midjourney Vary Region editor to select and regenerate specific parts of an upscaled image.

The `Vary (Region)` button appears after a Midjourney image has been upscaled.

Regional variations are guided by the content in your original image and the area you select.

`Vary (Region)` is compatible with Midjourney Model Versions `V5`, `V6`, `niji 5`, and `niji 6`.

### How to Use Vary Region

1\. Generate an Image

Create an image using the `/imagine` command.

2\. Upscale the Image 

Use the U buttons to upscale your selected image.

3\. Select Vary Region 

Click on the ` Vary (Region)` button to open the editing interface.

4\. Select Areas to Regenerate

Choose the freehand or rectangular selection tools in the lower left of the Editor.

Select the areas of your image that you want to regenerate.

The size of your selection will affect your results. Larger selections give the Midjourney Bot more room to generate new creative details. Smaller selections will result in smaller, more subtle changes.  
Note: You cannot edit an existing selection but can undo multiple steps using the undo button in the upper right corner.

5\. Submit Your Job

Click the `Submit ` button to send your request to Midjourney Bot. The Vary Region editor can now be closed, and you can return to Discord while your Job is processed.

Note You can use the ` Vary (Region)` button underneath an upscaled image multiple times to experiment with different selections. Your previous selection will be preserved. You can continue to add to this existing selection or use the `undo` button to clear your selection.

6\. View Your Results

The Midjourney Bot will process your Job and generate a new image grid of variations within the area you selected.

### Vary Region Examples

Upscaled Image

Prompt: colorful candy brooches

Selection

Result

Upscaled Image

Prompt: architectural drawing of a house

Selection

Result

### Vary Region + Remix Mode

You can use Remix mode with the Vary Region editor to update your prompt while regenerating specific parts of your image. Read about using Remix Mode with the Vary Region editor.

Original Image

Prompt: `gouache alligator in sunglasses`

Selection

Updated Prompt: `gouache alligator in green sunglasses`

Result

Updated Prompt: `gouache alligator in green sunglasses`

### Technical Details

Jobs generated using Vary (Region) will honor the following parameters:  
--chaos  
--fast  
--iw  
--no  
--stylize  
--relax  
--style  
--version  
--video  
--weird



------

## Chapter 8: How to Use Vary Region

1\. Generate an Image

2\. Upscale the Image 

3\. Select Vary Region 

4\. Select Areas to Regenerate

5\. Submit Your Job

6\. View Your Results

Vary Region Examples

Vary Region + Remix Mode

Technical Details

### Vary Region + Remix

Vary Region + Remix

Combine Remix Mode and the Midjourney Vary Region editor to select and regenerate specific parts of an upscaled image using a new or modified prompt.

The `Vary (Region)` button appears after a Midjourney image has been upscaled.

Regional variations results are guided by the content in your original image, the area you select, and the modified prompt used.

`Vary (Region)` is compatible with Midjourney Model Versions `V5`, `V6`, `niji 5`, and `niji 6`.

### How to Use Remix Mode with Vary (Region)

1\. Enable Remix Mode

Use the `/settings` command and select ` Remix` from the pop-up.

2\. Generate an Image

Create an image using the `/imagine` command.

3\. Upscale the Image 

Use the U buttons to upscale your selected image.

4\. Select Vary Region 

Click the ` Vary (Region)` button to open the editing interface.

5\. Select Areas to Regenerate

Choose the freehand or rectangular selection tools in the lower left of the Editor.

Select the areas of your image that you want to regenerate.

The size of your selection will affect your results. Larger selections give the Midjourney Bot more room to generate new creative details. Smaller selections will result in smaller, more subtle changes.  
Note: You cannot edit an existing selection but can undo multiple steps using the undo button in the upper right corner.

6\. Modify Your Prompt

Describe what you want to generate in the selected areas with an updated prompt. Your revised prompt should focus on the details you want to introduce or change.

7\. Submit Your Job

Click the `Submit ` button to send your request to Midjourney Bot. The Vary Region editor can now be closed, and you can return to Discord while your Job is processed.

Note You can use the Editor Button underneath an upscaled image multiple times to experiment with different selections and prompts.

8\. View Your Results

The Midjourney Bot will process your Job and generate a new image grid using the information from your original image and the guidance of your new prompt.

New Image Grid

Original vs. Varied Comparison

8\. Upscale and Vary Region again

You can upscale one of your new images and use the Vary Region Editor again to continue refining your image.

Selection

Result

Updated Prompt: hot air balloon lithograph

Result

Updated Prompt: castle in the meadow lithograph

### Vary Region + Remix Prompting Tips

Selections The size of your selection affects the outcome. Larger selections provide the Midjourney Bot with more contextual information, which can improve the scaling and context of new additions. But selecting too much may lead to the newly generated elements blending or replacing parts of the original image you wished to preserve.

Prompts Experiment with how you modify your prompt when Using Vary Region + Remix Mode. Prompts should focus on what you want to happen in the selected area. The Midjourney Bot also considers the existing image when generating a selected area, so shorter focused prompts often are more effective. Midjourney Prompts should not be conversational. Instead of "Please change the meadow trail into a beautiful stream, " be direct and prompt "meadow stream."

Work in Small Steps If you want to change many parts of an image, work on one part at a time. This way, you can create a focused prompt for each part.  
  

### Vary Region + Remix Examples

Original Image

Prompt: `gouache alligator in sunglasses`

Selection

Updated Prompt: `gouache alligator in green sunglasses`

Result

Updated Prompt: `gouache alligator in green sunglasses`

Original Image

Prompt: `scratchboard apple tree branch`

Selection

Updated Prompt: `rainbow scratchboard apple tree branch`

Result

Updated Prompt: `rainbow scratchboard apple tree branch`

### Technical Details

Jobs generated using Vary (Region) + Remix Mode will honor the following parameters:  
--chaos  
--fast  
--iw  
--no  
--stylize  
--relax  
--style  
--version  
--video  
--weird



------

## Chapter 9: Discord Interface

Discord Interface

You can interact with the Midjourney Bot on Discord. The Midjourney server has channels for working collaboratively, technical and billing support, official announcements, offering feedback, and discussions. The community is supportive, encouraging, and eager to share their knowledge with users just starting out.

Midjourney Discord: `https://discord.gg/midjourney`

### Discord Interface

Server List

Direct Messages  
Work one-on-one with the Midjourney Bot in your Direct Messages for a quieter experience.

Midjourney Official Server  
The official Midjourney server with channels for collaboration and billing/technical support.

Channel List

# support  

Visit this channel for billing and technical support from Midjourney Guides.

# newbies  

Visit any #newbies channel to create images.

Member List

Midjourney Bot  
The bot that produces images with the `/imagine` command

Moderators and Guides  
Moderators and Guides can help with billing and technical problems in the support channels.

### Image Grids

The `/imagine` command produces a grid of low-resolution image options based on your prompt. Use the buttons under each image grid to create variations of an image, upscale an image, or rerun the last Midjourney Bot action.

Upscale Buttons

`U1` `U2` `U3` `U4` buttons separate an image from the image grid, allowing you easily download that image or use additional tools like Zoom Out, or Pan.

When using legacy Midjourney model versions the U buttons would upscale an image generating a larger version of the selected image and adding more details, which uses Fast GPU time.

Redo

` ` The redo (re-roll) button reruns a job. In this case, it would rerun the original prompt producing a new grid of images.

Variation Buttons

`V1` `V2` `V3` `V4` V buttons create incremental variations of the selected grid image. Creating a variation generates a new image grid similar to the chosen image's overall style and composition.

### Upscaled Images

` Make Variations` `Web ` ` Favorite`

Make Variations: creates a variation of the upscaled image and generates a new grid of four options.

Web: Open the image in your gallery on midjourney.com

Favorite: tag your best images to easily find them on the Midjourney website.

### Direct Messages

If the #general or #newbie channels are moving too fast, Midjouney subscribers can work one-on-one with the Midjourney Bot in their Discord direct messages.  
Learn how to direct message the Midjourney Bot

### Emoji Reactions

React with different emojis to Midjourney Jobs to send images to your Direct Messages, cancel a job in progress, or delete an image.  
Learn how to use emoji reactions.

### Daily Theme Channel

Participate in a fun themed group image generation in the #daily-theme channel. Look for the day's theme next to the channel's name. All generations must include day's keyword(s).

Turn off the daily theme notification

Want to avoid the daily notification from the daily theme channel? Use the `/daily_theme` command to turn off notifications for that channel.



------

## Chapter 10: Midjourney Discord: https://discord.gg/midjourney

Discord Interface

Server List

Channel List

Member List

Image Grids

Upscale Buttons

Redo

Variation Buttons

Upscaled Images

Direct Messages

Emoji Reactions

Daily Theme Channel

### Direct Messages

Direct Messages

Midjourney subscribers can work one-on-one with the Midjourney Bot in their Discord Direct Messages.

Images generated in your direct messages are still subject to content and moderation rules. They will be visible to other users on the Midjourney website unless you're generating them in Stealth Mode.

### How to Message the Bot

Click on the Midjourney Bot from the Member List (or anywhere you see the Midjourney Bot's name)

Send any message to the Midjourney Bot.

This will begin your Direct Message conversation with the Midjourney Bot.

Find Your Direct Messages

If you accidentally closed or archived your direct message with the Midjourney Bot, send the bot another message to recover it.

Discord Mobile

Discord Desktop

### Troubleshooting

If you dont see messages from the Bot, adjust your privacy settings:

Discord Desktop

Right-click the Midjourney server icon

Select More Options

Toggle "Allow direct messages from server members." on

Discord Mobile

Long-press the Midjourney server icon

Select Privacy Settings

Scroll down to the "Allow direct messages from server members" toggle.

The Member List appears on the right side of the screen on the desktop version of Discord. If you don't see it, click the "Show Member List" icon next to the Discord search bar:

On mobile, while looking at any channel in the Midjourney server, tap the channel name to see a list of members.



------

## Chapter 11: How to Message the Bot

Find Your Direct Messages

Discord Mobile

Discord Desktop

Troubleshooting

Discord Desktop

Discord Mobile

### Discord Emoji Reactions

Discord Emoji Reactions

React with different emojis to Midjourney jobs to send images to your Direct Messages, cancel a job in progress, or delete an image.

React to a generation with an emoji to trigger actions from the Midjourney Bot.

###  Cancel and Delete

 Cancels or deletes a job at any time. Reacting to a job with an X emoji also removes the job from the Midjourney website. If you want to delete an image from the Midjourney webpage but can't find the image within Discord, use the `/show` command  to revive the job. The  reaction only works with your own jobs.

 Send to Direct Messages

React with the envelope emoji  to send a completed job to direct messages. The direct message will include the image's seed number and Job ID. If the envelope emoji is used for an image grid the grid will be sent as individual images. The  reaction only works with your own Jobs.

If you can't react to a job, it may be ephemeral. You'll see an `Only you can see this` warning at the bottom of the job, and reactions won't work. Use the `/show` command  to revive the job to react to it.

Job IDs are unique identifiers used for each image generated by Midjourney.  
Job IDs look like this: 9333dcd0-681e-4840-a29c-801e502ae424and can be found in the first part of all image filenames, in the URLs on the website, and in an image's filename.



------

## Chapter 12:  Cancel and Delete

 Send to Direct Messages

### Add the Bot to Your Server

Add the Bot to Your Server

Add the Midjourney Bot to any Discord Server to create with other subscribers, or make a personal Discord Server to organize your work.

Members of your private server must have their own Midjourney subscription to use the Midjourney Bot.

Midjourney images generated on private servers are still subject to Midjourney's Community Guidelines.

Images generated on private servers are still visible to other users on midjourney.com unless they're generated in Stealth Mode.

### Create Your Own Server

It's easy to create your own private Discord server to organize your work, notes and inspiration. Learn how to create your own Discord Server.

Add App

Select the Midjourney Bot from the User List, and then click Add App:

You can also add the Midjourney Bot to a server using the `Add to Server` button on its page in Discord's App Directory.

Choose your server from the Select a Server drop down

Click Authorize

### Bot Management

Restrict the Bot to Specific Channels

If you do not want the Midjourney Bot to be usable in specific channels, go to Edit Channel, select the Permissions tab, select @everyone under Roles/Members and Uncheck "Use Application Commands." Users who try to use the Midjourney Bot in a channel with these permissions disabled will not see the command.

For more granular control, go to Settings, select Integrations, the Permissions tab, the \+ for the Midjourney Bot, and Manage Integration. `slash command` permissions can then be set for individual roles and channels.

Get Status Updates and Announcements on Your Server

Follow the Midjourney Official Discord #announcements, #community updates, and #status channels on your server to stay up-to-date with Midjourney.  
  



------

## Chapter 13: Create Your Own Server

Add App

Bot Management

Restrict the Bot to Specific Channels

Get Status Updates and Announcements on Your Server

### Your Midjourney Account

Your Midjourney Account

Log into midjourney.com with your Discord or Google account to manage your subscription, view your previous images, and create new ones.

Returning to Midjourney?  
If you've used Midjourney in Discord in the past, choose the `Continue with Discord` option to log into the website.  
You can connect your Google account once you've logged in, but logging in with Google first may cause issues with your account.

Manage Your Profile

To manage your login information, visit the Manage Profile page on the website.

Connected Accounts

You'll see your existing login methods in the top section of the page. Click the `Connect Discord` or `Connect Google` button to add a new account. Once your new login is added, you. can use either to access midjourney.com.

All subscribers can generates images on the website.

To make images in Discord, you must have a Discord account connected.

You can't add a connected account if both the account you're logged in with and the account you're trying to add have Midjourney history, like past subscriptions or generated images (including trial images). If you try, you'll see an error message. Support can't merge these accounts.

You can only have one Discord account and one Google account connected at a time.

Disconnecting accounts is currently unavailable on the website. If you need to change which Discord or Google account you're using, email `billing@midjourney.com` for help.

The email address where you receive your subscription invoices may be different than your login email address(es).

Account Details

Additional details about your account are displayed in this section.

The email address you see here is from the first account you used to log into the website. It won't change or update after your account is created, even if you update your connected accounts. It's independent from your login and billing emails, and isn't used to contact you.

### Need Help?

If you have trouble logging into the website or managing your connected accounts, email `billing@midjourney.com` for help.



------

## Chapter 14: Manage Your Profile

Connected Accounts

Account Details

Need Help?

### Website Navigation

Website Navigation

At midjourney.com, you can create new images, manage your existing images, provide feedback to the team, and more!

Explore

Explore images generated by members of the Midjourney community.

Create

Create your own images using the web-creation interface.

Organize

Browse and organize all your Midjourney images.

Chat

Connect with the Midjourney community. Create images in shared spaces with everyone, or create private Rooms and invite your friends.

Tasks

Earn free Fast time with Rank Images and Surveys, or provide feedback to the team about features you'd like to see with Rate Ideas.

### Help

Click here for links to Midjourney documentation and support resources.

Updates

Catch up on Midjourney announcements, office hours news, and other changes. Set your personal notification preferences with the gear icon.

Light/Dark Mode

Toggle the website between light and dark viewing modes.

Account

Manage Subscription  
Subscribe or make changes to your current plan. You can also purchase additional Fast hours, check your plan details, and access your billing information.

Manage Uploads  
View and manage the images you've used as prompt references.

Sign Out  
Sign out of the website.



------

## Chapter 15: Explore

Create

Organize

Chat

Tasks

Help

Updates

Light/Dark Mode

Account

### Explore Page

Explore Page

From the Explore page, discover what's possible with Midjourney and find fun, exciting, and beautiful prompts to inspire your own creativity.

On the Explore page, you'll find images generated by other users and can quickly use those prompts and images to inspire your own unique creations.  
  
Create, Search, and View Images

Imagine Bar

Enter prompts, manage image references, and adjust your settings from the imagine bar. For more information on how website image creation works, visit the Create tab documentation.

Search Prompts

Search images generated by all Midjourney users. You can search for prompt text (for example `cyberpunk cats`) or parameters (like `--chaos 100`) to see how other Midjourney users are prompting.

Explore Page Sorting Options

By default, the Explore page shows a selection of random, recently generated images by other users. You can click the  Randomize button on the right to see a different set of images or use the sorting options to switch between different views:

Random: Random recent images from the Midjourney community

Hot: Trending images

Top (Day, Week, Month): The top-rated images from the chosen time period

Likes: Images from other users you've liked / ed

### Hover over an Image

When you mouse over an image on the Explore page, you'll see new details and options.

Username

The username of the Midjourney user who generated the image. Click on it to see their public Midjourney images.

Use as Image Prompt

Add this image as an image prompt to the imagine bar at the top of the page.

Edit Prompt

Add this prompt, including parameters and any image prompts or reference images, to the imagine bar at the top of the page.

Search Image

Search for other images like this one.

Like Image

Like /  other users' images so they appear in your "Liked" view.

### Click on an Image

When you click on a single image on the Explore page, you'll see additional details, including the prompt and parameters used to generate it.

1\. Prompt Text and Parameters

The full prompt, including the parameters, their values, and any reference images appear here.

2\. Menu Buttons

Options  
Manually copy prompt details, including the image URL and prompt, to use in your own generations.  
Use the "Report" option from this menu to report content you believe violates our Community Guidelines.

Search  
Find images similar to this one.

Like  
Like /  other users' images so they appear in your "Liked" view.

3\. Use

These buttons allow you to quickly and easily use this image in your own prompts.

Image: Use this image as an image prompt.

Style: Use this image as a Style Reference.

Prompt: Use this image's prompt

4\. Explore Feed

Click through to other nearby images from the Explore feed. You can also use your mouse wheel to scroll through these images from anywhere on the page.



------

## Chapter 16: Create, Search, and View Images

Imagine Bar

Search Prompts

Explore Page Sorting Options

Hover over an Image

Username

Use as Image Prompt

Edit Prompt

Search Image

Like Image

Click on an Image

1\. Prompt Text and Parameters

2\. Menu Buttons

3\. Use

4\. Explore Feed

### Create Page

Create Page

Generate Midjourney images directly on midjourney.com from the Create tab.

Creating and Searching Images

1\. Imagine Bar

Type your prompts here. Hit `Enter` to begin generating when you're ready. You can use parameters in your prompts the same way you would in Discord, or you can set them with the settings tool.

2\.  Image Prompts and References

Click the  button to open the image selection tool, where you can quickly and easily manage image prompts, character references, and style references. For more information about this tool, as well as about managing your uploaded images, visit the Using Image References on Web page.

3\.  Settings

Click the settings button to access your personal settings. Preferences you set here will automatically apply to all your prompts. If you want to use different settings for a single prompt, you can use --parameters in your prompt to override your settings.

For example if your default Speed is Relax, you can run a single job in Fast Mode by adding the `--fast` parameter to the end of your prompt.  
  
Website settings correspond to these features:

Setting NameFeature  
Image SizeAspect Ratio  
StylizationStylize  
WeirdnessWeird  
VarietyChaos  
ModeStyle  
VersionVersion  
SpeedRelax, Fast, or Turbo Mode  
StealthStealth Mode  
  
Your website and Discord settings are synced. This means that if you change your settings in one place, they'll change in the other too  including your generation speed (Relax, Fast, or Turbo Mode) and Stealth Mode settings. Double-check your settings to make sure they're set the way you want them before you generate images!  
Stealth Mode is only available on the Pro and Mega Plans.

4\.  Search

Search images in your Create feed. You can search by prompt text or parameters.

### Hovering over an Image or Prompt

As you generate images, they'll appear on your Create page with the most recent images at the top. Hovering over the generated images, or the prompt display on the right, will show some additional options.

Hovering over an Image

Hover over a generated image to reveal `Vary Subtle` and `Vary Strong` buttons. Learn more about the differences between subtle and strong variations on the Variations page.

Hovering over a Prompt

On the right side of the Create page, you'll see the prompts used to generate your images, including any parameters and image references. Hover over this section to see additional actions you can take with your images:

Rerun: Repeat this job.

Use: Copy this prompt to the imagine bar to quickly reuse or tweak it. Parameters and reference images used in the prompt will be copied too.

Hide: Hide this image from your Create feed. This will also hide the image from your Organize tab. It will still be visible to other users unless it's also Unpublished.

More: See a menu of additional options for this job:

Copy: Copy the prompt, job ID, seed, image, or image URL to your clipboard.  
Report: Report an image you believe violates the Community Guidelines.  
Publish /  Unpublish: Publish or Unpublish the image. This option only appears if your current plan includes Stealth Mode.  
Download: Download the selected image.  
Open in Discord: Jump to the location in Discord where this image was generated. For images generated on the website, a `Discord URL not available` error will appear if you click this button.

### Clicking on an Image

Click on an image in your Create page feed to see additional actions you can take with that image.

1\. Job Type

For non-imagine jobs, hover over this label to see a preview of the original set of images, with the parent image highlighted. Click on any image in the preview to jump to that image.

2\. Menu Buttons

Options  
Manually copy prompt details, including the image URL and prompt, to use in your own generations.

Download  
Download the selected image.

Search  
Search for other images like this one.

Like  
Like /  images so they appear in your "Liked" view.

3\. Create Feed

Click through to other nearby images from your Create feed. You can also use your mouse wheel to scroll through these images from anywhere on the page.

4\. Creation Actions

Use the buttons here to generate new images based on this one.

By default, not all of these options are shown. To customize which buttons appear for you in the light box, click "More options" and toggle the checkboxes to show or hide features.

To learn more about each of these actions, visit their feature pages: Vary, Upscale, Remix, Pan/Reframe, Zoom/Reframe, Repaint (Vary Region).

The `Use` buttons allow you to quickly add elements of this job's prompt to the imagine bar so you can reuse or tweak it. `Image` will add this image to your next job as an image prompt. `Style` will add the image as a Style Reference. `Prompt` will add the full prompt text, including parameters.

You can "Hide" images on the Midjourney website to remove them from your Archive. They'll no longer be visible to you unless you have the "Hidden" filter selected, but other users will still be able to view them (unless the image is also "Unpublished"). Hiding images is a good way to keep your Archive uncluttered. 

You can "Unhide" your hidden images to restore them to your archive anytime, so they're never lost.

By default, all images generated by Midjourney are "published, " or viewable by other users on midjourney.com. Users on plans that include Stealth Mode can generate "unpublished" images that aren't visible to other users.

You can publish your own unpublished images at any time on the website. If you have an active subscription that includes Stealth Mode, you can also unpublish any published images you have.

Learn more about Stealth Mode.

By default, all images generated by Midjourney are "published, " or viewable by other users on midjourney.com. Users on plans that include Stealth Mode can generate "unpublished" images that aren't visible to other users.

You can publish your own unpublished images at any time on the website. If you have an active subscription that includes Stealth Mode, you can also unpublish any published images you have.

Learn more about Stealth Mode.



------

## Chapter 17: Creating and Searching Images

1\. Imagine Bar

2\. Image Prompts and References

3\. Settings

4\. Search

Hovering over an Image or Prompt

Hovering over an Image

Hovering over a Prompt

Clicking on an Image

1\. Job Type

2\. Menu Buttons

3\. Create Feed

4\. Creation Actions

### The Web Editor

The Web Editor

The editor combines the Vary Region, Pan, and Zoom features into a single unifed web interface. Check out this video for a quick overview of what you can do, then read on to learn more!

Your browser does not support the video element. 

### Opening the Editor

Once you've generated an image you want to continue experimenting with, click on it to open the lightbox, then click the `Editor` button.

### Using the Editor

The Editor offers a streamlined web interface for continuing to experiment with your favorite Midjourney generations. You can Remix, Vary Region, Pan, and Zoom at the same time, in any combination.

When you're happy with the changes you've made, click `Submit` to begin generating your new image. Your new images will appear on the Create tab when they're finished.

The Editor can only be used with images generated with Midjourney.

Your browser does not support the video element. 

Editor Tools

1\.  Erase

Change parts of an image you like by Erasing the areas you want to re-generate. For the best results, select some extra space around the details you'd like to change so Midjourney has space to work. This is the default Editor tool. (This works smiliarly to the Vary Region feature.)

2\.  Restore

Refine the selections you made with Erase.

3\.  Undo /  Redo /  Reset

Undo the last change you made in the Editor, re-do the last change you un-did, or reset the interface to the way it was when you first opened the Editor.

4\. Brush Size

Control the diameter of the Erase / Restore brush to select larger or smaller parts of the image at a time.

5\. Scale

Move this slider down to expand your image in all directions. The farther down you go, the more space Midjourney will create around your original image. (This works similarly to the Zoom Out feature.)

6\. Aspect Ratio Selection

Choose a new aspect ratio for your image. You'll see an outline of the new shape of your image, and when you submit your job, Midjourney will expand the original to fit that space. (This works similarly to the Custom Zoom feature.

7\. Edit Prompt

Click and type here to make changes to your prompt. You can change the text, add or remove parameters, or add, remove, or change how you're using reference images. The `Reset Prompt` button will restore the prompt used to create your original image. (Changing your prompt this way functions similarly to the Remix feature.)

Prompt Editing Tip

It can be helpful to change your prompt to reflect the changes you want to make in the image ` for example, if you're erasing details, it can be helpful to describe the details you want to see in the image instead, or if you're expanding the images, describe what you want to see in the new space.

8\.  Reposition

This icon appears in the middle of your existing image. Click and drag to reposition your existing image. Any new blank space will be filled when you submit your job. Any parts of the image that disappear won't be part of your new job.

9\. Size Bars

Instead of using the Scale slider or aspect ratio buttons, you can use the small bars that appear around the edges of your image to extend or crop your image. (This works similarly to the Pan feature.)

10\. Submit /  Back /  Close

Once you're happy with the changes you've made, `Submit` your job! You'll see the new generation added to your Create tab queue. Close the Editor to navigate to there and see your results.

The Back button will return you to the original image's lightbox view.



------

## Chapter 18: Opening the Editor

Using the Editor

Editor Tools

### External Editor

External Editor

Upload your own images to the External Editor and make changes using Midjourney's powerful tools.

The External Editor is only available to subscribers who meet at least one of the following requirements: have a yearly subscription, have been subscribed for at least 12 consecutive months with no interruptions, or have generated more than 10, 000 Midjourney jobs. If you'd like to upgrade your subscription, visit the Manage Subscription page.

The External Editor is a powerful new tool for unleashing your imagination. To maintain the same moderation standards we've set across Midjourney, we're introducing a few additional, necessary precautions.

By using the External Editor, you agree to the following rules in addition to our Terms of Service.

External Editor Access & Guidelines

The External Editor is only available to subscribers who meet at least one of the following requirements: have a yearly subscription, have been subscribed for at least 12 consecutive months with no interruptions, or have generated more than 10, 000 Midjourney jobs.

You must meet the age requirement in our Terms of Service.

You must follow all applicable laws, our Community Guidelines, and other policies.

We may remove content or restrict access at our discretion.

Your Responsibilities

You are responsible for all content you input, create, and share.

You must have the necessary rights to use and edit the images you upload.

If you disagree with these rules, do not use the External Editor.

You will likely encounter friction with our moderation  seemingly innocent prompts may be blocked by our filters. Blocked jobs don't cost you any credits. GPU time will only be deducted when you see your results.

We encourage you to use this tool and your imagination with joy, wonder, responsibility, and respect.

For additional information on policies, including privacy, payments, and disputes, refer to our Terms of Service.

Getting Started

External Editor Tools

To start, open the External Editor and choose an image from your Midjourney gallery, or use the  Edit from URL or  Edit Uploaded Image buttons to import an existing image.

Images you upload to the external editor are only visible to you  they won't appear anywhere on midjourney.com for other users.

Edit Tab

From the Edit tab, you can Remix, Vary Region, Pan, and Zoom, in any combination. When you're happy with the changes you've made, click `Submit Edit` to generate your new image.

1\.  Move / Resize  
Click this button to enable repositioning and scaling options on your starting image. You can click and drag the image to reposition it on your canvas, or use the bars and boxes that appear around the edges and corners of your image to extend or crop it. Any blank space you create, indicated by a grey-and-white checkerboard pattern, will be filled in with new details when you `Submit Edit`.

2\.  Erase  
Change parts of an image by Erasing the areas you want to re-generate. For the best results, select some extra space around the details you'd like to change so Midjourney has space to work. This is the default Editor tool. (This works similarly to the Vary Region feature.)

3\.  Restore  
Refine the selections you made with Erase.

4\.  Undo /  Redo /  Reset  
Undo the last change you made in the External Editor, re-do the last change you un-did, or reset the interface to the way it was when you first opened the External Editor.

5\.  Suggest Prompt  
Use the Describe tool to generate a prompt that matches your starting image.

6\. Brush Size  
Control the diameter of the Erase / Restore brush to select larger or smaller parts of the image at a time.

7\. Image Scale  
Move this slider down to expand your image in all directions. The farther down you go, the more space Midjourney will create around your original image. (This works similarly to the Zoom Out feature.)

8\. Aspect Ratio Selection  
Choose a new aspect ratio for your image. You'll see an outline of the new shape of your image, and when you submit your job, Midjourney will expand the original to fit that space. (This works similarly to the Custom Zoom feature.)

Retexture Tab

Retexturing estimates the shape of a scene and changes the overlying details, like lightning, materials, and surfaces. To retexture an image, click the Retexture Tab. You can edit your prompt in the imagine box at the top of the screen. For the best results, avoid using prompts that will clash with the structure of your starting image. When you're happy with the changes you've made, click `Submit Retexture` to generate your new image.

`Original Image`

`Retextured Image`

Export

Images generated in the External Editor don't automatically appear in your Organize or Create tabs. You can always find and organize them from the organization section of the Edit tab.

Upscale to Gallery  
Add the generated images to your main image gallery on the Organize and Create tabs.

Download Image  
Save your favorite images.

External Editor History

Your previously edited images and generations will appear here. Click  View All to return to the starting screen where you can see all your External Editor images, or  New to start fresh.



------

## Chapter 19: Getting Started

External Editor Tools

Edit Tab

Retexture Tab

Export

External Editor History

### Working with Images on Web

Working with Images on Web

On midjourney.com, you can easily upload and manage images you want to use as references in your prompts. Add images quickly as you work on the Create Page, or upload and manage your existing image references on the Manage Uploads page.

Image Upload and Selection

Click the  button in the Imagine bar on any page to open the image selection tool:

If the image you want to use is already shown, click on it to add it to your prompt. By default, it will be added as an image prompt, but you can also choose to use it as a style reference or character reference instead with the appropriate buttons.

There are several additional things you can do from this screen:

Choose a file or drop it here: If the image you want to use isn't already shown here, drag and drop it from your computer onto this box, or click and navigate through your files to find and add it. The image will appear in the grid of images to the right, and will also be added to your current prompt as an image reference.

Delete: Remove this images from your uploads. Jobs that used this image as a reference won't be affected.

Describe: Generate a list of subjects and descriptors based on the image. This works similarly to the `/describe` command in Discord, but instead of generating several full prompts, it will give you a variety of words and phrases to play with. Clicking on one of the generated phrases will add it to the end of your current prompt. Click the  Reroll button to generate new descriptions, and the  Back button to go back to the image selection tool.

### Using Image References

When you add an image to your prompt, it will be used as an image prompt by default, but you can hover over the image to choose a different option:

Character Reference: Use the selected image as a character reference.

Style Reference: Use the selected image as a style reference.

Image Prompt (Default): Use the image as an image prompt.

Remove: Remove this image from your current prompt.

To use the same image in multiple ways in a prompt (for example, as both a character reference and a style reference), `Shift + click` on the corresponding icons. A darker icon, like the  Image Prompt icon above, means you've chosen that reference type.

You can also use the buttons on the right to manage your reference images:

Lock / Unlock: Your image prompts are unlocked by default, meaning they'll clear every time you submit a prompt. Lock them to keep your selections between prompts. This will also lock the type of reference. The lock icon will turn red to indicate your image references are locked, and your selections will stay the same until you make changes or unlock them again. You can't lock or unlock references individually.

Delete: Removes all image references from your current prompt and closes the image selection tool.

### Manage Uploads Page

You can use the Manage Uploads page to organize the images you use frequently in your prompts.

Every image you use with Midjourney will be saved to your uploads and appear here. This includes images you use in prompts in Discord.

Other users can't access your image uploads page, but any image references you use will appear with your prompts on the website unless you're generating your images in Stealth Mode.

There are two views on the Manage Uploads page:

Visible: These images will appear in the image selection tool when you click the  button.

Hidden: These images are still saved in your uploads, but won't appear in the image selection tool.

You can hide a visible image or unhide a hidden image any time by hovering over it and clicking the  Hide or  Unhide button, or by clicking on it and using the larger buttons beneath the image on the right side of the page.

Delete: Remove an image permanently from your uploads. The image will still appear with any prompts that used it, and you'll be able to continue working with those jobs as normal.  
  



------

## Chapter 20: Image Upload and Selection

Using Image References

Manage Uploads Page

### Organize Page

Organize Page

Search and manage all the images you've generated with Midjourney from your Organize page.

All the images you've made with Midjourney appear on your Organize page, with the most recent images at the top. You can search or filter your Organize to find what you're looking for or create folders to keep your images organized. You can also use your Organize page to perform bulk actions, like downloading multiple images.

If you're generating your images in Stealth Mode, they will appear in your Organize page on the website, but they won't be visible to other Midjourney users.

Deleting an image by reacting to it with  in Discord deletes that image from your Organize page. This is the only way to remove images completely from the website. Once you've ed an image, it can't be restored.

Hiding an image on the website removes it from your Organize page, but those images can still be viewed by other Midjourney users. Hiding an image is not the same as Unpublishing it with Stealth Mode.

### Creating, Searching, and Organizing Images

1\. Imagine Bar

Enter prompts, manage image references, and adjust your settings from the imagine bar. For more information on how website image creation works, visit the Create Page documentation.

2\. Search Prompts

Search images you've created with Midjourney. You can search for prompt text (for example `cyberpunk cats`) or parameters (like `--chaos 100`). Unlike on the Explore page, only images you created will appear as search results here.

3\. Organize

Reveal or hide the organization sidebar on the right side of the screen.

4\. Timeline

Use the timeline to jump to a specific day's. Hover to see the dates, and click to jump to that day. More recent dates are at the top of the timeline, while older dates appear closer to the bottom of the page.

### Folders, Filters, and View Options

These options let you control which of your images you see on the Organize page, and how they're displayed.

Folders

Your existing folders will appear in the list here. To add a new folder to the list, click `Create Folder`. You can drag and drop images into folders to organize them, or use the bulk actions menu to move many images into a folder at once. You can also create smart folders, which will automatically include any images that match the search terms you set for them.

Smart Folders

When creating a new folder, you'll have the option to set it up as a smart folder. Smart folders will automatically include any images you generate that match your search terms, but you can't manually add or remove images from them.

Search Terms  

By default, only prompts that contain all of your search terms will be included in the smart folder, but it doesn't matter where or in what order those words appear in the prompts. For example, if you enter `cat dog` as your search terms, only images with both `cat` and `dog` somewhere in the prompt will be included. To include images with either cat or dog in the prompt, separate the terms with commas: `cat, dog`.

The smart folder search terms match partial strings. This means that if one of your search terms is a word that's also part of a longer word (for example, `cat` is part of `catapult`), any prompts you have with the longer word will also be included in the folder.

Filters

Use these preset options to filter your images.

You can check multiple boxes in each section to show images that match any of those options. For example, if you check "Liked" and "Unrated" in the `Rating` section, all Liked or Unrated images will display, but not Hidden ones.

You can check boxes in multiple sections to show images that match both sets of selections. For example, if you check "Liked" in the `Rating` section and "Landscape" in the `Image Size` section, only landscape images that you Liked will display.

Leaving all the boxes in a section unchecked is the same as checking all of them.

If you can't filter for the set of images you'd like to find using a combination of the preset filters, try using the search bar to find them.

If any of the filters are checked, you won't be able to see all your images. If you think images are missing, uncheck all the boxes on the right, and they should reappear.

View Options

Use these options to control how your images are displayed.

Layout

Square: All your images will appear as squares. In this layout, any landscape or portrait images you've generated will appear cropped.  
Full: All your images will appear uncropped, but they'll be shrunk to fit in the square layout. You'll see white space around any landscape or portrait images to fit them into the page grid, and details may be harder to see.

Image Size

Control how large the image tiles appear on the page. Larger image sizes will result in fewer images being shown on your screen at once.

### Bulk Selection and Actions

From your Organize page, you can take bulk actions on images you've generated, such as downloading them, assigning them to folders, or, if you have a plan that includes Stealth Mode, publishing and unpublishing them.

Bulk Selection

There are several ways to select multiple images from your Organize page:

Click the  next to a date to select all the images you created that day. You can select multiple days at once by clicking the  next to multiple dates.

Click any white space on the page and drag your cursor to select groups of images.

`Shift + Click` any individual images to add or remove them from your selection.

Click outside of a selection or click the  in the bulk actions menu to unselect all the images.

Bulk Actions Menu

Once you've selected a batch of images, a bulk actions menu will appear as a bar near the bottom of the page. The number displayed here is a count of all the images you've selected.

Download

Download the selected images.

More:

Like /  Unlike  
Like or Unlike all the selected images.

Hide /  Unhide  
Hide or Unhide all the selected images from your Organize page. They'll still be visible to other users unless they're unpublished.

Publish /  Unpublish  
Publish or Unpublish all the selected images from the website. These options only appear if your current plan includes Stealth Mode. Unpublished images will still be visible to you.

Add to Folder  
Add all the selected images to a folder you've created. Since you can't manually add or remove images from smart folders, they won't appear in the list of options here.

Cancel  
Clear your selection and close this bar.

You can "Hide" images on the Midjourney website to remove them from your Archive. They'll no longer be visible to you unless you have the "Hidden" filter selected, but other users will still be able to view them (unless the image is also "Unpublished"). Hiding images is a good way to keep your Archive uncluttered. 

You can "Unhide" your hidden images to restore them to your archive anytime, so they're never lost.

By default, all images generated by Midjourney are "published, " or viewable by other users on midjourney.com. Users on plans that include Stealth Mode can generate "unpublished" images that aren't visible to other users.

You can publish your own unpublished images at any time on the website. If you have an active subscription that includes Stealth Mode, you can also unpublish any published images you have.

Learn more about Stealth Mode.



------

## Chapter 21: Creating, Searching, and Organizing Images

1\. Imagine Bar

2\. Search Prompts

3\. Organize

4\. Timeline

Folders, Filters, and View Options

Folders

Filters

View Options

Bulk Selection and Actions

Bulk Selection

Bulk Actions Menu

### Command List

Command List

You can interact with the Midjourney Bot on Discord by typing a Command. Commands are used to create images, change default settings, monitor user info, and perform other helpful tasks.

Midjourney Commands can be used in any Bot Channel, on private Discord servers where the Midjourney Bot has been permitted to operate, or in a direct message with the Midjourney Bot.

Commands

/ask

Get an answer to a question.

/blend

Easily blend two images together.

/daily_theme

Toggle notification pings for the #daily-theme channel update

/describe

Writes four example prompts based on an image you upload.

/docs

Use in the official Midjourney Discord server to quickly generate a link to topics covered in this user guide!

/fast

Switch to Fast mode.

/feedback

Submit suggestions and ideas for Midjourney and rate ideas from others.

/faq

Use in the official Midjourney Discord server to quickly generate a link to popular prompt craft channel FAQs.

/help

Shows helpful basic information and tips about the Midjourney Bot.

/imagine 

Generate an image using a prompt

/info

View information about your account and any queued or running jobs.

/invite

Get the invite link for the Midjourney Discord server.

/list_tuners

Generate a list of all of the Style Tuner you have created.

/prefer option set

Create or manage a custom option.

/prefer option list

View your current custom options.

/prefer remix 

Toggle Remix mode.

/prefer suffix 

Specify a suffix to add to the end of every prompt.

/prefer variability

Toggle between High and Low variations when using the `V1` `V2` `V3` and `V4` buttons underneath an image grid.

/public

For Pro Plan Subscribers: switch to Public Mode

/relax 

Switch to Relax mode.

/settings 

View and adjust the Midjourney Bot's settings

/stealth

For Pro Plan Subscribers: switch to Stealth Mode

/shorten

Submit a long prompt and receive suggestions on how to make it more concise.

/show

Use an images Job ID to regenerate the job within Discord.

/subscribe

Generate a personal link for a user's account page.

/synonyms

Use in the official Midjourney Discord server to explore related words and phrases to try in your prompts.

/tune

Generate a Style Tuner based on your prompt. The Style Tuner lets you make your own Midjourney style and customize the look of your jobs.

/turbo

Switch to Turbo mode.

/userid

Get your Midjourney User ID

### Deprecated

/private (replaced with '/stealth')  
/pixels  
/idea

You can interact with the Midjourney Bot on Discord by typing a Command. Commands are used to create images, change default settings, monitor user info, and perform other helpful tasks.

Midjourney Commands can be used in any Bot Channel, on private Discord servers where the Midjourney Bot has been permitted to operate, or in a direct message with the Midjourney Bot.

Bot Channels are Discord channels where the Midjourney Bot has been permitted to process Slash Commands. On the official Midjourney Discord, all channels in the Newcomer Rooms, Thread Channels, Themed Image Gen, and General Image Gen categories are Bot Channels.



------

## Chapter 22: Commands

/ask

/blend

/daily_theme

/describe

/docs

/fast

/feedback

/faq

/help

/imagine 

/info

/invite

/list_tuners

/prefer option set

/prefer option list

/prefer remix 

/prefer suffix 

/prefer variability

/public

/relax 

/settings 

/stealth

/shorten

/show

/subscribe

/synonyms

/tune

/turbo

/userid

Deprecated

### Blend

Blend

The `/blend` command allows you to upload 2`5 images quickly and then looks at the concepts and aesthetics of each image and merges them into a novel new image.

`/blend` is the same as using multiple image prompts with `/imagine`, but the interface is optimized for easy use on mobile devices.

`/blend` works with up to 5 images. To use more than 5 images in a prompt use image prompts with `/imagine`

`/blend` does not work with text prompts. To use text and image prompts together, use image prompts and text with `/imagine`

### `/blend` Options

After typing the `/blend` command, you will be prompted to upload two photos. Drag and drop images from your hard drive or add images from your photo library when using a mobile device. To add more images, select the `optional/options` field and select `image3`, `image4`, or `image5`. The `/blend` command may take longer to start than other commands because your images must be uploaded before the Midjourney Bot can process your request.

Blended images have a default 1:1 aspect ratio, but you can use the optional `dimensions` field to select between a square aspect ratio (1:1), portrait aspect ration (2:3), or landscape aspect ratio (3:2).

Custom suffixes are added to the end of `/blend` prompts, like any other `/imagine` prompt. Aspect ratios specified as part of the `/blend` command override aspect ratios within a custom suffix.

Blending Tip

For the best results, upload images that are the same aspect ratio as your desired result.

### How to Use `/blend`



------

## Chapter 23: /blend Options

How to Use /blend

### Describe

Describe

The `/describe` command allows you to upload an image and generate four possible prompts based on that image. Use the `/describe` command to explore new vocabulary and aesthetic movements.

The describe feature generates prompt suggestions that are inspirational and suggestive. It cannot be used to recreate an uploaded image exactly.

Describe works slightly differently between Discord and the website. Using the `/describe` commend in Discord will generate full prompts, while the website will offer suggestions of words and phrases to help you build your own prompts.

"Describing" the same image again will provide different suggestions.

### In Discord

Using the `/describe` Command

Use the `/describe` command wherever you use Midjourney Bot in Discord. You can provide an image to describe by entering the image's URL (select the `link` option; find more information about using image URLs in Discord here), or by selecting an image that's stored on your device (use the `image` option).  
  
Once the suggestions have generated, click the corresponding numbered buttons to `/imagine` that prompt. You'll have a chance to edit the text before submitting it.

You can also use the  button to run the `/describe` command on the same image again, or the ` Imagine all` button to generate images with all four prompts at once (though you won't have the chance to edit them first).

An Example `/describe` in Discord

If you use the `/describe` command with the below image Midjourney Bot will suggest four prompts that may generate similar images:

1 drawing of a persian cat face in purple ballpoint pen on a white background, with purple fur, in the style of unknown artist.

2 A purple pencil drawing of a Persian cat, white background, in the style of John Beastman.

3 A purple pencil drawing of an adorable persian cat, with simple lines on a white background, featuring fine details and a beautiful composition in the style of a hyperrealistic work, with sharp edges and sharp focus.

4 A purple pencil drawing of an exotic shorthair cat, simple line art with a white background, fine lines and pastel colors create a soft and delicate atmosphere in this closeup portrait. The sketching style depicts the cat as cute and dreamy, with intricate details shown through detailed lines in a front view. The ink wash technique uses dark black tones with low saturation to create the style of the artist.

Legacy `/describe`

By default, the Discord `/describe` generates prompts that will work best with Version 6.

If you set your default Midjourney Version to 5.0 in Discord, `/describe` will generate shorter prompts that work better with older model versions.

On Web

From the Imagine Bar

Click the  icon in the imagine bar to access image reference options on the website. If the image you'd like to describe doesn't appear already, you can upload it from this view. Once it's uploaded, hover over the image to reveal the  icon, then click that to generate suggestions.

Instead of generating full prompt suggestions like `/describe` does in Discord, the website will give you a variety of words and phrases to play with. Clicking on one of the generated phrases will add it to the end of your current prompt. Click the  Reroll button to generate new descriptions, and the  Back button to go back to the image selection tool.



------

## Chapter 24: User Info

User Info

Use the `/info` command to see information about your current queued and running jobs, subscription type, renewal date, and more.

User ID

Your Midjourney User ID

Subscription

The Subscription section shows which plan you are subscribed to and your next renewal date.

Visibility Mode

Shows whether you are currently in Public or Stealth Mode. Stealth Mode is only available to Pro Plan subscribers.

Fast Time Remaining

Shows your remaining Fast GPU time for the month. Fast GPU time resets monthly and does not carry over.

Ranking Count

Shows your total number of ranked images, along with the number of images ranked in the last 30 days.

Lifetime Usage

Shows your lifetime Midjourney stats. Images include all types of generations (initial image grids, upscales, variations, remix, etc).

Fast, Turbo and Relaxed Usage

Shows your Fast, Turbo and Relaxed Mode usage.

Queued Fast and Relaxed Jobs

Lists all Jobs queued to run.

Running Jobs

Lists all Jobs currently running. A maximum of three jobs can run at the same time.

### Use the Info Command

Type `/info` in any Bot Channel or your Direct Messages. Only you will be able to see your Info popup.  

A Job is any action that uses the Midjourney Bot. Jobs include using `/imagine` to create an initial image grid, upscaling images, and creating variations of images.

A Job is any action that uses the Midjourney Bot. Jobs include using `/imagine` to create an initial image grid, upscaling images, and creating variations of images.

Bot Channels are Discord channels where the Midjourney Bot has been permitted to process Slash Commands. On the official Midjourney Discord, all channels in the Newcomer Rooms, Thread Channels, Themed Image Gen, and General Image Gen categories are Bot Channels.



------

## Chapter 25: User ID

Subscription

Visibility Mode

Fast Time Remaining

Ranking Count

Lifetime Usage

Fast, Turbo and Relaxed Usage

Queued Fast and Relaxed Jobs

Running Jobs

Use the Info Command

### Settings and Presets in Discord

Settings and Presets in Discord

The `/settings` command provides toggle buttons for common options like model version, style value, quality value, and upscaler version. Settings also has toggles for the `/stealth` and `/public` commands.

Parameters added to the end of a prompt will override selections made using `/settings`.

### Model Version Dropdown

Select the Midjourney Model Version to use when generating images. Use The Latest Model is the default selection and will always use the newest Midjourney Model Version.

`Use the latest Model (V6)` `6 Mjourney Model V6 [ALPHA]` ` Niji Model V6 [ALPHA]` `5 Mjourney Model V5.2` `5 Mjourney Model V5.1` ` Niji Model V5` `5 Mjourney Model V5.0` ` Niji Model V4` `4 Mjourney Model V4` `3 Mjourney Model V3` `2 Mjourney Model V2` `1 Mjourney Model V1`  
  
Style Raw Parameter

Midjourney Model Versions 5.1, 5.2, 6, and Niji 6 can be fine-tuned with the --style raw parameter to reduce the Midjourney default aesthetic. This toggle is not available if other model versions are selected.

` Raw Mode`  
  
Stylize Parameter

The Midjourney Bot has been trained to produce images that favor artistic color, composition, and forms. The --stylize or --s parameter influences how strongly this training is applied. Low stylization values produce images that closely match the prompt but are less artistic. High stylization values create images that are very artistic but less connected to the prompt.

` Stylize Low` ` Stylize Med` ` Stylize High` ` Stylize Very High`

Stylize Low = `--s 50`, Stylize Med = `--s 100`, Stylize High = `--s 250`, Stylize Very High = `--s 750`, 
  
Public and Stealth Mode

Toggle between Public and Stealth modes. Corresponds to the `/public` and `/stealth` commands.

`Public`  
  
Remix Mode

Use Remix mode to change prompts, parameters, model versions, or aspect ratios between variations. Remix will take the general composition of your starting image and use it as part of the new Job. Remixing can help change the setting or lighting of an image, evolve a subject, or achieve tricky compositions.

` Remix`  
  
High and Low Variation Mode

Toggle between High Variation and Low Variation mode.

` High Variation Mode` ` Low Variation Mode`  
  
Sticky Style

Sticky Style will save the last `--style` code parameter used in your personal suffix, so you don't have to repeat the code on future prompts. Change codes by using a new `--style` or unselecting Sticky Style.

` Sticky Style`

Turbo, Fast, and Relax Mode

Toggle between Turbo, Fast and Relaxed modes. Corresponds to the `/turbo`, `/fast`, and `/relax` commands and the `--turbo`, `--fast`, and `--relax` parameters.

` Turbo Mode` ` Fast Mode` ` Relax Mode`  
  
Reset Settings

Return to default settings: `Use the latest Model (V6)` ` Stylize Med`. Your public/stealth mode, remix, variation, and generation speed preferences are unaffected.

`Reset Settings`  
  

### Automatically Direct Message Results

Use `/prefer auto_dm` to turn on or off automatic sending of finished jobs to your Direct Message.

### Custom Preferences

Create custom options using prefer commands to add commonly used parameters to the end of prompts automatically.

`/prefer suffix` specify a suffix to add to the end of every prompt.

`/prefer option` Create or manage a custom option.

`/prefer option list` View your current custom options.

Prefer Suffix

`/prefer suffix` automatically appends the specified suffix after all prompts.

Command example: `/prefer suffix` `--ar 16:9 --video`

To clear a set suffix, use the `/settings` command and select ` Reset Settings`, or use `/prefer suffix` again without adding the optional new_value field to the command.

Option Sets

`/prefer option set <name> <value>` command allows you to create a custom shortcut, adding multiple parameters or text snippets to your prompts.

`/prefer option set` `mine` `--chaos 5 --aspect 2:3` creates an option called "mine" that contains the chaos and aspect ratio parameters.

Using `/imagine prompt` `vibrant California poppies --mine`, is interpreted as `/imagine prompt` `vibrant California poppies --chaos 5 --aspect 2:3`.

You can use multiple option sets in the same prompt.

You can use a mix of prompt text and parameters in your option sets. If you do, all the parameters in the set must go at the end, just like in normal prompting.

Your option set will "expand" where it's placed in your prompts, so you'll need to put all your prompt parameters after your option set.

`/prefer option list` list all options created with `prefer option set.` Users can have up to 20 custom options.

To delete a custom option, use `/prefer option set` `<name to delete>` without adding the optional value field to the command.

Subscribers can work one-on-one with the Midjourney Bot in Discord's Direct Messages instead of a public channel. Images made within your direct messages are still subject to content and moderation rules and will be visible on your Midjourney website gallery.



------

## Chapter 26: Model Version Dropdown

Style Raw Parameter

Stylize Parameter

Public and Stealth Mode

Remix Mode

High and Low Variation Mode

Sticky Style

Turbo, Fast, and Relax Mode

Reset Settings

Automatically Direct Message Results

Custom Preferences

Prefer Suffix

Option Sets

### Show Job

Show Job

You can use the `/show` command with the unique Job ID to move a job to another server or channel, revive a lost job, or refresh an old job to make new variations, upscale, or use newer parameters and features.

`/show` only works on your own jobs.

### Find a Job ID

Job IDs are unique identifiers used for each image generated by Midjourney.  
Job IDs look like this: `9333dcd0-681e-4840-a29c-801e502ae424` and can be found in the first part of all image filenames, in the URLs on the website, and in an image's filename.

On the Web

You can find the Job ID of any image in your member gallery by selecting `Options` > `Copy` > `Job ID`.

From the URL

Job IDs are in the URL when viewing an image in your Midjourney gallery.  
https://www.midjourney.com/jobs/9333dcd0-681e-4840-a29c-801e502ae424?index=0.

From the File Name

Job IDs are the last part of the file name when viewing an image you have downloaded from your gallery.  
User_cat_cloud_spirit_9333dcd0-681e-4840-a29c-801e502ae424.png

Using a Discord Emoji Reaction

React to your completed job with the envelope emoji  and Midjourney Bot will send you a direct message with its Job ID. If you're not getting direct messages from the bot, check your Discord privacy settings.

### How to Use Show

Use the `/show <Job ID #>` in any Bot Channel to revive a Job.

Bot Channels are Discord channels where the Midjourney Bot has been permitted to process Slash Commands. On the official Midjourney Discord, all channels in the Newcomer Rooms, Thread Channels, Themed Image Gen, and General Image Gen categories are Bot Channels.



------

## Chapter 27: Find a Job ID

On the Web

From the URL

From the File Name

Using a Discord Emoji Reaction

How to Use Show

### Shorten

Shorten

The `/shorten` command analyzes your prompt, highlights some of your prompt's most influential words, and suggests unnecessary words you could remove. With this command, you can optimize your prompt by focusing on essential terms.

`/shorten` is not compatible with multi prompts or the `--no` parameter

### Analyze a Prompt with `/shorten`

The Midjourney Bot analyzes your prompt by breaking it down into smaller units known as tokens. These tokens can be phrases, words, or even syllables. The Midjourney Bot converts these tokens into a format it can understand. It uses them with the associations and patterns learned during its training to guide how your image is generated. Think of tokens as the building blocks that help the Midjourney Bot make sense of the input and create the desired visual output.

Long prompts with unnecessary words, lengthy descriptions, poetic phrases, or direct addressing of the bot ("Please make me an image, " "Thank you for your help, Midjourney Bot!") can lead to unexpected elements being added to your images.

The `/shorten` command can help you discover the most important words in your prompt and what words you can omit.

/shorten Command Example

If you want to create a pile of sprinkle covered donuts you might try the prompt:  
`Please create a whimsical majestic tower of donuts, intricately crafted and adorned with a mesmerizing array of colorful sprinkles. Bring this sugary masterpiece to life, ensuring every detail is rendered in stunning magical realism. Thank you!`

If you use `/shorten` command with the above prompt the Midjourney Bot will return the following information:

IMPORTANT TOKENS  
Please ~~create~~ a whimsical majestic tower of donuts, intricately crafted and adorned with a mesmerizing array of colorful sprinkles. Bring this sugary masterpiece to life, ~~ensuring every~~ detail is rendered in ~~stunning~~ magical realism. ~~Thank you!~~

SHORTENED PROMPTS  
1 Please, majestic tower of donuts, crafted, array of colorful sprinkles, sugary masterpiece, rendered, magical realism

2 Please, majestic tower of donuts, colorful sprinkles, sugary masterpiece, rendered, magical realism

3 majestic tower of donuts, colorful sprinkles, sugary, magical realism

4 majestic tower of donuts, colorful sprinkles, magical

5 tower of donuts, sprinkles

The most Important tokens in your prompt are highlighted in bold, the least important are ~~stikethroughed~~. You will also be given 5 possible shorter prompts based on this information.

### `Shortened Option 1 `

Please, majestic tower of donuts, crafted, array of colorful sprinkles, sugary masterpiece, rendered, magical realism

`Shortened Option 2 `

Please, majestic tower of donuts, colorful sprinkles, sugary masterpiece, rendered, magical realism

`Shortened Option 3 `

majestic tower of donuts, colorful sprinkles, sugary, magical realism

`Shortened Option 4 `

majestic tower of donuts, colorful sprinkles, magical

`Shortened Option 5 `

tower of donuts, sprinkles

Analyzing the Results

The shortest prompt, `Option 5 : tower of donuts, sprinkles` produced an image closest to the original goal. Many of the filler words like "whimsical, " "mesmerizing, " and "masterpiece" could be omitted. Learning that "tower" and "magical" were considered important tokens helps explain why some images were generated with fairytale castle elements. Learning this provided a clue that "magical" should be removed from the prompt if the goal was to create a stack of delicious donuts.

The `/shorten` command is a tool to help you explore how the Midjourney Bot interprets tokens and experiment with words, but it may not work for all subjects and styles of prompting.

### How to Use Shorten

Use the `/shorten <your prompt>` command in any Bot Channel to get information on your prompt

Bot Channels are Discord channels where the Midjourney Bot has been permitted to process Slash Commands. On the official Midjourney Discord, all channels in the Newcomer Rooms, Thread Channels, Themed Image Gen, and General Image Gen categories are Bot Channels.



------

## Chapter 28: Analyze a Prompt with /shorten

/shorten Command Example

Analyzing the Results

How to Use Shorten

### Parameter List

Parameter List

Parameters are options added to a prompt that change how an image generates. Parameters can change an image's Aspect Ratios, switch between Midjourney Model Versions, change which Upscaler is used, and lots more.

Parameters are always added to the end of a prompt. You can add multiple parameters to each prompt.

Using an Apple device?

Many Apple devices automatically change double hyphens (--) to an em-dash (). Midjourney accepts both!

### Basic Parameters

Aspect Ratios

`--aspect`, or `--ar` Change the aspect ratio of a generation.

Chaos

`--chaos <number 0100>` Change how varied the results will be. Higher values produce more unusual and unexpected generations.

Character Reference

Use images as character references in your prompt to create images of the same character in different situations.

Fast

`--fast` override your current setting and run a single job using Fast Mode.

Image Weight

`--iw <03>` Sets image prompt weight relative to text weight. The default value is 1.

No

`--no` Negative prompting, `--no plants` would try to remove plants from the image.

Quality

`--quality <.25, .5, or 1>`, or `--q <.25, .5, or 1>` How much rendering quality time you want to spend. The default value is 1. Higher values use more GPU minutes; lower values use less.

Random

`--style random`, add a random 32 base styles Style Tuner code to your prompt. You can also use `--style random-16`, `--style random-64` or `--style random-128` to use random results from other lengths of Style Tuners.

Relax

`--relax` override your current setting and run a single job using Relax Mode.

Repeat

`--repeat <140>`, or `--r <140>` Create multiple Jobs from a single prompt. `--repeat` is useful for quickly rerunning a job multiple times.

Seed

`--seed <integer between 04294967295>` The Midjourney bot uses a seed number to create a field of visual noise, like television static, as a starting point to generate the initial image grids. Seed numbers are generated randomly for each image but can be specified with the --seed or --sameseed parameter. Using the same seed number and prompt will produce similar ending images.

Stop

`--stop <integer between 10100>` Use the `--stop` parameter to finish a Job partway through the process. Stopping a Job at an earlier percentage can create blurrier, less detailed results.

Style

`--style <raw>` Switch between versions of the Midjourney Model Version 5.1 and 5.2.  
`--style <4a, 4b, or 4c>` Switch between versions of the Midjourney Model Version 4.  
`--style <cute, expressive, original, or scenic>` Switch between versions of the Niji Model Version 5.  
Use the `/tune` command to create a Style Tuner and generate custom style codes.

Style Reference

Use images as style references in your prompt to influence the style or aesthetic of images you want Midjourney to make.

Stylize

`--stylize <number>`, or `--s <number>` parameter influences how strongly Midjourney's default aesthetic style is applied to Jobs.

Tile

`--tile` parameter generates images that can be used as repeating tiles to create seamless patterns.

Turbo

`--turbo` override your current setting and run a single job using Turbo Mode.

Video

`--video` Saves a progress video of the initial image grid being generated. Emoji react to the completed image grid with  to trigger the video being sent to your direct messages. `--video` does not work when upscaling an image.

Weird

`--weird <number 03000>`, or `--w <number 03000>` Explore unusual aesthetics with the experimental `--weird` parameter.

Default Values (Model Version 5.2)

Aspect RatioChaosQualitySeedStopStylize  
Default Value   
1:101Random100100  
Range   
any0100.25 .5, or 1whole numbers 042949672951010001000  
  
Aspect ratios greater than 2:1 are experimental and may produce unpredictable results.

Default Values (Model Version 6)

Aspect RatioChaosQualitySeedStopStylize  
Default Value   
1:101Random100100  
Range   
1:1414:10100.25 .5 or 1whole numbers 042949672951010001000  
  

### Model Version Parameters

Midjourney routinely releases new model versions to improve efficiency, coherency, and quality. Different models excel at different types of images.

Niji

`--niji <4, or 5>` An alternative model focused on anime-style images.

Version

`--version <1, 2, 3, 4, 5.0, 5.1, 5.2, or 6>` or `--v <1, 2, 3, 4, 5.0, 5.1, 5.2, or 6>` Use a different version of the Midjourney algorithm.

### Legacy Parameters

Some parameters only work with earlier Midjourney Models.  
Read More about legacy parameters here.

### Compatibility

Model Version & Parameter Compatability

Affects initial generationAffects variations + remixVer. 6Ver. 5.2Niji 5  
Max Aspect Ratioanyanyany  
Chaos010001000100  
Image Weight03   
default=1.52   
default=1.52   
default=1  
No  
Quality.25, .5, or 1.25, .5, or 1.25, .5, or 1  
Repeat  
Seed  
Stop101001010010100  
Stylerawrawcute, expressive, original   
and scenic  
Stylize01000   
default=10001000   
default=10001000   
default=100)  
Tile  
Video  
Weird03000   
default=001000   
default=001000   
default=0  
  
The Midjourney Bot processes jobs on high-end GPUs. Each minute that it takes to complete a job is a GPU minute. You have a limited amount of GPU minutes when in Fast Mode. Because image generations may be processed on multiple GPUs simultaneously, GPU minutes are not directly connected to the time you wait for an image to generate.



------

## Chapter 29: Basic Parameters

Aspect Ratios

Chaos

Character Reference

Fast

Image Weight

No

Quality

Random

Relax

Repeat

Seed

Stop

Style

Style Reference

Stylize

Tile

Turbo

Video

Weird

Default Values (Model Version 5.2)

Default Values (Model Version 6)

Model Version Parameters

Niji

Version

Legacy Parameters

Compatibility

Model Version & Parameter Compatability

### Aspect Ratios

Aspect Ratios

The `--ar` (or `--aspect`) parameter changes the aspect ratio of the generated image. An aspect ratio is the width-to-height ratio of an image. It is typically expressed as two numbers separated by a colon, such as 7:4 or 4:3.

A square image has equal width and height, described as a 1:1 aspect ratio. The image could be 1000px  1000px, or 1500px  1500px, and the aspect ratio would still be 1:1. A computer screen might have a ratio of 16:10. The width is 1.6 times longer than the height. So the image could be 1600px  1000px, 4000px  2000px, 320px x 200px, etc.

The default aspect ratio is 1:1.

`--ar` must use whole numbers. Use 139:100 instead of 1.39:1.

The first number represents width, while the second number represents height. For portrait (tall) images, the second number should be larger. For landscape (wide) images, the first number should be larger.

The aspect ratio impacts the shape and composition of a generated image.

Some aspect ratios may be slightly changed when upscaling.

Older Midjourney Version Models may not support all aspect ratios.

### Aspect Ratio Comparison

prompt example: `/imagine prompt` `vibrant California poppies --ar 5:4`

Extremely wide and tall aspect ratios are experimental and may produce unpredictable results.

Common Midjourney Aspect Ratios

`--ar 1:1` Default aspect ratio.  
`--ar 5:4` Common frame and print ratio.  
`--ar 3:2` Common in print photography.  
`--ar 7:4` Close to HD TV screens and smartphone screens.

### Changing the Aspect Ratio of an Image

Do you love an image you have generated but wish it was taller or wider? You can use the Pan and Zoom features to adjust the aspect ratio of your images in different ways. For more information, check out these pages: Pan, Zoom.

### How to Set the Aspect Ratio

Use Aspect Ratio Parameters

Add `--aspect <value>:<value>`, or `--ar <value>:<value>` to the end of your prompt on Discord or in the imagine bar on the website:

Website Settings

On the website, you can also set a default aspect ratio using the Settings button in the imagine bar:

The `Portrait` button will set your aspect ratio to 3:4. The `Landscape` button will set it to 4:3. You can adjust the slider left for taller aspect ratios, up to 1:2, or right for wider ones, up to 2:1.

The value you set here will apply to all your prompts unless you specify a different value using the `--aspect` or `--ar` parameter in an individual prompt.

Not all aspect ratios are supported by the slider, but you can use the `--ar` parameter at the end of your prompt to set any ratio you'd like.



------

## Chapter 30: Aspect Ratio Comparison

Common Midjourney Aspect Ratios

Changing the Aspect Ratio of an Image

How to Set the Aspect Ratio

Use Aspect Ratio Parameters

Website Settings

### Chaos

Chaos

The `--chaos` or `--c` parameter influences how varied the initial image grids are. High `--chaos` values will produce more unusual and unexpected results and compositions. Lower `--chaos` values have more reliable, repeatable results.

`--chaos` accepts values 0`100.  
The default `--chaos` value is 0.

### The Influence of Chaos on Jobs

No `--chaos` value

Using a very low `--chaos` value, or not specifying a value, will produce initial image grids that are similar.

prompt example: `/imagine prompt:` `a silver seashell inlaid with pink and green accents --c 0`

Low `--chaos` values

Using a low `--chaos` value will produce initial image grids that are slightly varied.

prompt example: `/imagine prompt:` `a silver seashell inlaid with pink and green accents --c 10`

Moderate `--chaos` values

Using a moderate `--chaos` value will produce initial image grids that are varied.

prompt example: `/imagine prompt:` `a silver seashell inlaid with pink and green accents --c 25`

High `--chaos` Values

Using a higher `--chaos` value will produce initial image grids that are more varied and unexpected.

prompt example: `/imagine prompt:` `a silver seashell inlaid with pink and green accents --c 50`

Very High `--chaos` Values

Using extremely high `--chaos` values will produce initial image grids that are varied and have unexpected compositions or elements.

prompt example: `/imagine prompt:` `a silver seashell inlaid with pink and green accents --c 80`

### How to Change the Chaos Value

Use the `--chaos` or `--c` Parameter

Add `--chaos <value>` or `--c <value>` to the end of your prompt on Discord or in the imagine bar on the website:

Website Settings

On the website imagine bar Settings, Chaos is called Variety. You can set a default Variety value using the Settings button in the imagine bar:

Adjust the slider left for lower values and right for higher values.

The value you set here will apply to all your prompts unless you specify a different value using the `--chaos` or `--c` parameter in an individual prompt.



------

## Chapter 31: The Influence of Chaos on Jobs

No --chaos value

Low --chaos values

Moderate --chaos values

High --chaos Values

Very High --chaos Values

How to Change the Chaos Value

Use the --chaos or --c Parameter

Website Settings

### Character Reference

Character Reference

You can use images as character references in your prompt to create images of the same character in different situations.

To add character references to a prompt, use the --cref parameter with the web address (URL) where the image is stored online: `--cref URL`

Character references work best when using images generated by Midjourney that feature a single character.

`--cref` is not designed to be used with photographs of real people, and will distort them.

Precise details like specific freckles or t-shirt logos aren't likely to be copied.

`--cref` can be used with Midjourney and Niji Version 6, and can be combined with `--sref`.

You can use multiple character references in a single prompt, but probably don't need to.

Any regular image prompts must go before `--cref`.

Privacy Notes

Upload images in your direct messages with the Midjourney Bot to prevent other server users from seeing an image.

Image prompts and references are visible on the Midjourney website unless you're generating in Stealth Mode.

See the Image Prompts page for help using image URLs in your prompts on Discord, or the Using Image References on Web page for help using all kinds of image references on midjourney.com.

### Examples

`Reference Image: BlueHairGuy.png`

`Prompt: illustration of a man sitting in a cafe`

`Prompt: illustration of a man sitting in a cafe --cref https://url.com/BlueHairGuy.png`

### Character Weight Parameter

Use the character weight parameter `--cw` to set the strength of characterization. `--cw` accepts values from 0 to 100. `--cw 0` focuses on the character's face only. Higher values use the character's face, hair, and clothing. `--cw 100` is default.

prompt example: `/imagine prompt` `illustration of a man sitting in a cafe --cref https://url.com/BlueHairGuy.png`

`--cw 0`

`--cw 50`

`--cw 100`

### Combining Style and Character References

To maintain a consistent style while using a character reference, you can combine the `--sref` and `--cref` parameters. See the Style Reference page for more information on using --sref.

`/imagine prompt` `illustration of a man sitting in a cafe --cref https://url.com/BlueHairGuy.png --sref https://url.com/BlueHairGuy.png`



------

## Chapter 32: See the Image Prompts page for help using image URLs in your prompts on Discord, or the Using Image References on Web page for help using all kinds of image references on midjourney.com

Examples

Character Weight Parameter

Combining Style and Character References

### No

No

The No parameter tells the Midjourney Bot what not to include in your image.

`--no` accepts multiple words separated with commas: `--no item1, item2, item3, item4`

`--No` Comparison

`still life gouache painting`

a range of objects appear in the still life

`still life gouache painting --no fruit`

The still life has fewer fruits

`--no` vs. Don't

The Midjourney Bot considers every word in the prompt as a potential element for the image. Prompting `still life gouache painting without any fruit` or `still life gouache painting, please dont add fruit!` are more likely to produce pictures that include fruits because the relationship between "without" or "don't" and the "fruit" is not interpreted by the Midjourney Bot in the same way a human reader would understand it. To improve your results, focus your prompt on what you do want to see in the image and use the "--no" parameter to specify concepts you don't want to include.

`still life gouache painting`

A range of objects appear in the still life.

`still life gouache painting, please don't add fruit!`

More fruit is present in the final image.

Multi Prompting

The `--no` parameter is the same as weighing part of a multi prompt to "-.5" `still life gouache painting:: fruit::-.5` is the same as `still life gouache painting --no fruit`.

### How to Use the No Paramter

Add `--no item1, item2, item3` to the end of your prompt.



------

## Chapter 33: --No Comparison

--no vs. Don't

Multi Prompting

How to Use the No Paramter

### Personalization

Personalization

Create custom image styles with personalized profiles and moodboards using `--p`

What is Personalization?

Personalization is like your personal style assistant for creating images with Midjourney! When you interact with images by liking or ranking them, Midjourney learns what kind of visuals you enjoy. Then, when you use personalization in your prompt, Midjourney uses what it's learned to create images that match your tastes. It's like telling Midjourney, "Remember how I liked those kinds of images? Make more like that!"

Personalization is compatible with Midjourney Version 6, 6.1, and Niji 6. Niji personalization is entirely separate and handled on the Niji website.

Personalization Profiles

Personalization profiles are like setting up different 'looks' or 'themes' for the images you create with Midjourney. Each profile can represent a different style or mood that you like and you can have multiple profiles for different tastes. Create and manage your personalization profiles on your Personalize page.

Global Profile  
If you were already using personalization when profiles were introduced, this profile will hold all that personalization and style data youve been accumulating. It's also the only profile that changes when you like  images from other users on the Explore page.

Standard Profiles  
These are extra profiles you can create to focus on specific styles. You rank pairs of images to tell Midjourney what you like.

Moodboard Profiles  
You create these by selecting specific images that inspire you and set a particular mood or vibe. They act like vision boards for ideas you want to capture. You can upload your own images, provide image URLs, or select images from your gallery.

When you rank image aesthetics on the website, you will need to pick which profile you are ranking for from your Personalization page. New ranking data will only apply to the profile you select.

### Personalization Walkthrough

Head to the Personalize page on the Midjourney website to view and manage your personalization profiles. This is your starting point for customizing your image styles.













Turn on personalization using the toggle switch. This will automatically add your default personalization profile to all your prompts, allowing your images to reflect your personal style.

To create a standard profile, click the "Create Standard Profile" button. This will take you to a new page where you'll rank pairs of images. Choose the image you like best between the two options. Continue ranking until you've unlocked your profile, which is necessary before you can start using it.

To create a moodboard profile, click the "Create Moodboard" button. This will take you to a blank moodboard page. Here, you can upload images from your computer or device, add images from URLs, or add images from your Midjourney gallery.

Click Copy Code to add your profile ID to the Imagine bar and copy it to your clipboard. If you've turned on personalization, you can also use the checkbox on your favorite profile to automatically include its ID in your prompts when using the website. This makes it easy to apply your chosen style automatically.  

### Using Personalization

On Web

Add `--p` to the end of your prompt in the Imagine bar. This will automatically apply your default personalization profile to your prompt.

To use a specific profile, click Copy Code from your Personalization page to add its profile ID to the end of your prompt (example: `--p pID`). You can also use a specific code `--p CODE`

You can choose a default personalization setting for all your images in the settings panel. To do this, click the settings  button in the Imagine bar, turn Personalize on, and select your profile using the dropdown menu. Once you set it, this will apply to all your future prompts.

In Discord

Add `--p` to the end of your prompt in Discord. This will automatically apply your default personalization profile to your prompt.

To use a specific profile, copy its ID from your Personalization page using the Copy Code button and add it to the end of your prompt (example: `--p pCODE`). You can also use a specific code `--p CODE`

On Discord you can use the ` Personalization` button in your Midjourney settings (run the `/settings` command wherever you use the bot) to automatically add the `--p` parameter to all your prompts.

You'll only be able to use personalization once you've ranked enough image aesthetic pairs and/or ed enough images on the website. If you try to use `--p` without enough data, you'll see an error message directing you to do more ranking.

### Personalization Codes

Your personalization profiles will grow and change as you keep liking, ranking, and adding more image data. As your profile updates, it will generates new codes. These codes act like labels for the different versions of your style profile, helping you keep track of how your preferences have evolved. Copy the ID from your profile to use the latest version. To find older codes, you can use the `/list_personalize_codes` command in Discord or revisit your previous prompts to see the codes you used before.

Note: When using a profile code it will automatically convert from `--p pID` to `--p code` when you submit your prompt.

### Managing Your Profiles

You can manage your profiles by renaming or deleting them. To do this, hover your mouse over a profile and use the pencil  button to rename it or the trash can  button to delete it. If you choose to delete a profile, it will be removed from your profiles list, and you won't be able to add any new data to it. However, any codes that were already created from that profile will still work, allowing you to continue using its style in future prompts.

### Stylize with Personalization

When using personalization, the `--stylize` parameter controls how much of your personalization is applied to the image. A lower stylize value will limit the personalization, while a higher value will increase it. The stylize parameter accepts values from 0 to 1000. The default is 100.



------

## Chapter 34: What is Personalization?

Personalization Profiles

Personalization Walkthrough

Using Personalization

On Web

In Discord

Personalization Codes

Managing Your Profiles

Stylize with Personalization

### Quality

Quality

Control how much time your images take to generate with `--quality` or `--q`

A lower `--q` value means your images generate faster. These jobs consume less GPU time, but the resulting images will be less detailed. This can be useful for experimenting with new prompts, so you can hone your ideas more quickly.

Using a higher `--q` value costs more GPU time and can improve image textures and detail, but may reduce the coherency of your images.

Version Quality Compatibility

Model VersionQuality .25Quality .5Quality 1Quality 2  
Version 6.1x  
Version 6.0x  
Version 5.2x  
niji 5x  
  
`--quality` does not impact the resolution of your generated images, and does not guarantee the resulting images will be "better" or "worse" than an image generated with a higher or lower value  it only influences how much GPU time Midjourney spends creating them.

The default `--quality` value is 1.

Other values are rounded to the closest available option for the model version you're using.

`--q` only influences the initial image generation, not variations or upscales.

### Quality Comparison

Prompt example: `/imagine prompt` `intricate woodcut of a peony`

`--quality .5`

quickest, but least detailed results

`--quality 1`

the default setting

`--quality 2`

slower, but more detailed results

### How to Use the Quality Parameter

Use the `--quality` or `--q` Parameter

Add `--quality <value>` or `--q <value>` to the end of your prompt.



------

## Chapter 35: Version Quality Compatibility

Quality Comparison

How to Use the Quality Parameter

Use the --quality or --q Parameter

### Repeat

Repeat

The `--repeat` or `--r` parameter runs a Job multiple times. Combine `--repeat` with other parameters, like --chaos to increase the pace of your visual exploration.

`--repeat` accepts values 24 for Basic subscribers  
`--repeat` accepts values 210 for Standard subscribers  
`--repeat` accepts values 240 for Pro and Mega subscribers  
The `--repeat` parameter can only be used in Fast and Turbo GPU mode.

### Use the `--repeat` or `--r` Parameter

Add `--repeat <value>` or `--r <value>` to the end of your prompt.

A Job is any action that uses the Midjourney Bot. Jobs include using `/imagine` to create an initial image grid, upscaling images, and creating variations of images.

There are two modes for image generation, Fast Mode and Relax Mode. Fast Mode tries to give you a GPU instantly. It's the highest-priority processing tier and uses your subscription's monthly GPU time. Relax Mode queues your generation behind others based on how much you've used the system. Relax Mode wait times are variable and usually range from 110 minutes.

By default, your images will be generated using Fast mode. You can switch to Relax if you have a Standard or Pro subscription.



------

## Chapter 36: Seeds

Seeds

The Midjourney bot uses a seed number to create a field of visual noise, like television static, as a starting point to generate the initial image grids. Seed numbers are generated randomly for each image but can be specified with the `--seed` parameter. If you use the same seed number and prompt, you will get similar final images.

`--seed` accepts whole numbers 04294967295.

`--seed` values only influence the initial image grid.

Identical `--seed` values using Model Versions `1`, `2`, `3`, `test`, and `testp` will produce images with similar composition, color, and details.

Identical `--seed` values using Model Versions `4`, `5`, `6` and `niji` will produce nearly identical images.

Seed numbers are not static and should not be relied upon between sessions.

### Seed Parameter

If no Seed is specified, Midjourney will use a randomly generated seed number, producing a wide variety of options each time a prompt is used.  
  
Jobs run three times with random seeds:

prompt example: `/imagine prompt` `celadon owl pitcher`

Jobs run three times with `--seed 12345`:

prompt example: `/imagine prompt` `celadon owl pitcher --seed 123`

### How to Find a Job's Seed Number

Use a Discord Emoji Reaction

Find the seed number of a Job in discord by reacting with an  envelope emoji to a Job.

Use The Show Command to Bring Back Old Jobs

To get the seed number for a past image, copy the job ID  and use the `/show <Job ID #>` command with that ID to revive the Job. You can then react to the newly regenerated Job with an  envelope emoji.

### How To Change Seed Numbers

Use the `--seed` Parameter

Add `--seed <value>` to the end of your prompt.

A Job is any action that uses the Midjourney Bot. Jobs include using `/imagine` to create an initial image grid, upscaling images, and creating variations of images.



------

## Chapter 37: Seed Parameter

Jobs run three times with random seeds:

Jobs run three times with --seed 12345:

How to Find a Job's Seed Number

Use a Discord Emoji Reaction

Use The Show Command to Bring Back Old Jobs

How To Change Seed Numbers

Use the --seed Parameter

### Stop

Stop

Use the `--stop` parameter to finish a Job partway through the process. Stopping a Job at an earlier percentage can create blurrier, less detailed results.

`--stop` accepts values: 10`100.  
The default `--stop` value is 100.  
`--stop` does not work while Upscaling.

### Stop Comparison

prompt example: `/imagine prompt` `splatter art painting of acorns --stop 90`

--stop 10

--stop 20

--stop 30

--stop 40

--stop 50

--stop 60

--stop 70

--stop 80

--stop 90

--stop 100

prompt example: `/imagine prompt` `a wooden inlay oak leaf --stop 50`

--stop 10

--stop 20

--stop 30

--stop 40

--stop 50

--stop 60

--stop 70

--stop 80

--stop 90

--stop 100

### How to Change the Stop Percentage

Use the `--stop` Parameter

Add `--stop <value>` to the end of your prompt.



------

## Chapter 38: Stop Comparison

How to Change the Stop Percentage

Use the --stop Parameter

### Style

Style

The `--style` parameter replaces the default aesthetic of some Midjourney Model Versions.

Model Versions 6, 5.2, 5.1 and Niji 6 accept `--style raw`.

### The Effects of `--style raw`

`--style raw` uses an alternative model that may work well for users already comfortable with prompting who want more control over their images. Images made with `--style raw` have less automatic beautification applied, which can result in a more accurate match when prompting for specific styles.

Model Version 6

`--v 6`

black and white oak tree icon

`--v 6 --style raw`

black and white oak tree icon --style raw

`--v 6`

child's crayon drawing of a cat

`--v 6 --style raw`

child's crayon drawing of a cat --style raw

### Model Version 5.2

`--v 5.2`

ice cream icon

`--v 5.2 --style raw`

ice cream icon --style raw

`--v 5.2 `

child's drawing of a cat

`--v 5.2 --style raw`

child's drawing of a cat --style raw

### How to Use Styles

Use the `--style` Parameter

Add `--style <style name>` to the end of your prompt on Discord or in the imagine bar on the website:

Use the Settings Command

Type `/settings` and select `` RAW Mode` from the menu to append `--style raw` to all prompts.

Website Settings

You can choose between Standard and Raw styles as your default "Mode" with buttons in the website Settings menu:

Your current default style will be highlighted in red.

If `Standard Mode` is your default style, you can override it by adding `--style raw` to individual prompts. If `Raw Mode` is your default, you'll need to switch back to `Standard Mode` in your setings to turn it off.



------

## Chapter 39: The Effects of --style raw

Model Version 6

Model Version 5.2

How to Use Styles

Use the --style Parameter

Use the Settings Command

Website Settings

### Style Reference

Style Reference

You can use images as style references in your prompt to influence the style or aesthetic of images you want Midjourney to make.

To add style references to a prompt, use the --sref parameter with the web address (URL) where the image is stored online: `--sref URL`

Style references only apply to prompts that include textthey cant be used with image-only prompts.

You can also use prompt text to reinforce your style reference, and may need to with tricky styles.

Any regular image prompts must go before `--sref`

You can use multiple style references: `--sref URL1 URL2 URL3`

You can also use `--sref random` to apply a random style to your images.

`--sref` can be used with Midjourney and Niji Version 6

Privacy Notes

Upload images in your direct messages with the Midjourney Bot to prevent other server users from seeing an image.

Image prompts and references are visible on the Midjourney website unless you're generating in Stealth Mode.

See the Image Prompts page for help using image URLs in your prompts on Discord, or the Using Image References on Web page for help using all kinds of image references on midjourney.com.

### Examples

`Reference Image: CatSketch.png`

`Prompt: a cat`

`Prompt: a cat --sref https://url.com/CatSketch.png`

### Style Weight Parameter

Use the style weight parameter `--sw` to set the strength of stylization. `--sw` accepts values from 0 to 1000. `--sw 100` is default.

prompt example: `/imagine prompt` `a cat --sref https://url.com/CatSketch.png`

` `--sw 50` `

` `--sw 100` `

` `--sw 800` `

Individual style references can also be assigned different weights: `--sref URL1::2 URL2::1 URL3::1`

See the Multi Prompts page for more information about the relative importance between parts of a prompt.

### Style Reference Versions

There are four versions of the style reference feature. Use the `--sv` parameter to choose between them. `--sv 4` is default.

`--sv 1` The original style reference algorithm, more vibey  
`--sv 2` The second iteration of style references  
`--sv 3` An updated version of the more vibey --sv 1  
`--sv 4` An updated version of --sv 2

` `--sv 1` `

` `--sv 2` `

` `--sv 3` `

` `--sv 4` `

### Random Style References

You can use --sref random to randomly select a style from an abstract range that Midjourney knows how to generate.

Rerolling  or making variations of a job with --sref random will generate different images with the same random style as the parent grid.

Each job from a permutation or `--repeat` prompt with --sref random will use a different random style.

After you submit your prompt, "random" will be replaced with a style reference seed you can use to replicate that style in future prompts.

`--sw` works with random style references to control how strongly the random style influences the results.

You can't combine random style references or style reference seeds with each other or with URL style references.

Examples:

` `a cat --sref random` `

` `a cat --sref random` `

` `a cat --sref random` `

` `a cat --sref random` `

Style Reference Seeds

In your completed job, the "random" value will be replaced with a style reference seed number: `--sref random`  `--sref 762351716`. You can use that style reference seed in future prompts to generate images in the same style.

`a cute cat --sref 762351716`

`a cute rubber duck --sref 762351716`

`a cute owl --sref 762351716`

`a cute turtle --sref 762351716`



------

## Chapter 40: See the Image Prompts page for help using image URLs in your prompts on Discord, or the Using Image References on Web page for help using all kinds of image references on midjourney.com

Examples

Style Weight Parameter

Style Reference Versions

Random Style References

Examples:

Style Reference Seeds

### Stylize

Stylize

The Midjourney Bot has been trained to produce images that favor artistic color, composition, and forms. The `--stylize` or `--s` parameter influences how strongly this training is applied. Low stylization values produce images that closely match the prompt but are less artistic. High stylization values create images that are very artistic but less connected to the prompt.

`--stylize`'s default value is 100 and accepts integer values 01000 when using the current models

### Common Stylize Settings

Influence of Stylize on Model Version 6

prompt example: `/imagine prompt` `child's drawing of a cat --s 100`

`--stylize 0`

`--stylize 50`

Equal to ` Style Low`

`--stylize 100` (default)

Equal to ` Style Med`

`--stylize 250`

Equal to ` Style High`

`--stylize 500`

`--stylize 750`

Equal to ` Style Very High`

prompt example: `/imagine prompt` `colorful risograph of a fig --s 100`

`--stylize 50`

Equal to ` Style Low`

`--stylize 100` (default)

Equal to ` Style Med`

`--stylize 250`

Equal to ` Style High`

`--stylize 750`

Equal to ` Style Very High`

### How to Use Stylize

Use the Stylize Parameter

Add `--stylize <value>` or `--s <value>` to the end of your prompt on Discord or in the imagine bar on the website:

Use the Discord Settings Command

Type `/settings` and select your preferred stylize value from the menu.

` Style Low` ` Style Med` ` Style High` ` Style Very High`

Website Settings

You can set a default Stylization using the Settings button in the imagine bar:

Adjust the slider left for lower values and right for higher values.

The value you set here will apply to all your prompts unless you specify a different value using the `--stylize` or `--s` parameter in an individual prompt.



------

## Chapter 41: Common Stylize Settings

Influence of Stylize on Model Version 6

How to Use Stylize

Use the Stylize Parameter

Use the Discord Settings Command

Website Settings

### Tile

Tile

The `--tile` parameter generates images that can be used as repeating tiles to create seamless patterns for fabrics, wallpapers and textures.

`--tile` works with Model Versions `1` `2` `3` `test` `testp` `5` `5.1` `5.2` and `6`.  
`--tile` only generates a single tile. Use a pattern making tool like this Seamless Pattern Checker  to see the tile repeat.

### Tile Examples

`prompt` `a pattern of pink and blue striped river stones --tile`  

`prompt` `a pattern of colorful watercolor fall leaves --tile`  

### How to Use the Tile Parameter

Add `--tile` to the end of your prompt.



------

## Chapter 42: Tile Examples

How to Use the Tile Parameter

### Version

Version

Midjourney regularly introduces new model versions to improve coherency, efficiency, quality, and style. You can switch model versions using the --version or --v parameter or using the /settings command and selecting your preferred model version. Different models excel at producing different types of images.

`--version` accepts the values 1, 2, 3, 4, 5, 5.0, 5.1, 5.2, 6, and 6.1.

`--version` can be abbreviated `--v`.

`--v 6.1` is the newest and current default model.

### Model Version 6.1

Version 6.1 was released on July 30, 2024 as the new default model. It produces more coherent images with more precise details and textures, and generates images approximately 25% faster than Version 6.

Prompt: vibrant California poppies --v 6.1

Prompt: high contrast surreal collage --v 6.1

### Model Version 6

Midjourney Model Version 6 has enhanced prompt accuracy for longer inputs, improved coherence and knowledge, and advanced image prompting and remixing capabilities.

Midjourney Model Version 6 was released on December 20, 2023, and was the default model from February 14 to July 30, 2024.

Prompt: vibrant California poppies --v 6

Prompt: high contrast surreal collage --v 6

### Niji Model 6

The Niji model is a collaboration between Midjourney and Spellbrush tuned to produce anime and illustrative styles with vastly more knowledge of anime, anime styles, and anime aesthetics. It's excellent at dynamic and action shots and character-focused compositions.

To use this model, add the `--niji 6` parameter to the end of a prompt, or use the `/settings` command and select ` Niji version 6`

Prompt: vibrant California poppies --niji 6

Prompt: high contrast surreal collage --niji 6

Niji 6 vs. Midjourney Version 6

`--v 6`

`vibrant California poppies --v 6`

`--niji 6`

`vibrant California poppies --niji 6`

`--v 6`

`fruit salad tree --v 6`

`--niji 6`

`fruit salad tree --v 6 --style raw`

### How to Switch Models

Use the Version Parameter

Use the `--version` or `--v` parameter to change model versions. For example, `--v 5.2` to use Version 5.2, or `--niji 6` to user Niji Version 6.

Use the Discord Settings Command

Type `/settings` and select your preferred version from the drop-down list.

`6 MJ Version 6.1` `6 MJ Version 6` ` Niji Version 6`

Looking for more information about the older models of Midjourney? Check out the Legacy Model Versions page.

Website Settings

You can set a default Version using the Settings button in the imagine bar:

Select your preferred version from the drop-down menu. Your images will be generated with that version unless you specify a different value using the `--version` or `--v` parameter in an individual prompt.



------

## Chapter 43: Model Version 6.1

Model Version 6

Niji Model 6

Niji 6 vs. Midjourney Version 6

How to Switch Models

Use the Version Parameter

Use the Discord Settings Command

Website Settings

### Video

Video

Use the `--video` parameter to create a short movie of your initial image grid being generated. React to the finished job with the envelope  emoji to have the Midjourney Bot send a link to the video to your Direct Messages.

`--video` only works on image grids, not upscales.

`--video` only works on images generated in Discord.

`--video` works with Model Versions `5.2` `6` `niji 5` and `niji 6`.

`--video` works with Legacy Model Versions `1` `2` `3` `5.0` `5.1` `test` and `testp`.  
Generated videos are deleted 30 days after creation.

### Video Examples

vibrant California Poppies

a botanical sketch of a fern fronds

### How to Get a Video Link

Prompt example: `/imagine prompt` `Vibrant California Poppies --video`

`1` Add `--video` to the end of your prompt.

`2` Once the Job has finished, click Add Reaction

`3` Select the  Envelope emoji.

`4` The Midjourney bot will send a link to the video to your Direct Messages.

`5` Click the link to view your video within a browser. Right-click or Long Press to download the video.

### How to Use the Video Parameter

Add `--video` to the end of your prompt.

Subscribers can work one-on-one with the Midjourney Bot in Discord's Direct Messages instead of a public channel. Images made within your direct messages are still subject to content and moderation rules and will be visible on your Midjourney website gallery.



------

## Chapter 44: Video Examples

How to Get a Video Link

How to Use the Video Parameter

### Weird

Weird

Explore unconventional aesthetics with the experimental `--weird` or `--w` parameter. This parameter introduces quirky and offbeat qualities to your generated images, resulting in unique and unexpected outcomes.

`--weird` accepts values: 0`3000.  
The default --weird value is 0.  
--weird is a highly experimental feature. What's weird may change over time  
--weird is compatible with Midjourney Model Versions 5, 5.1, 5.2, 6, niji 5 and niji 6  
--weird is not fully compatible with seeds

### The Influence of Weird on Jobs

The optimal `--weird` value is dependent on the prompt and requires experimentation. Try starting with smaller values, such as 250 or 500, and then go up/down from there. If you want a generation to be conventionally attractive and weird, try mixing higher `--stylize` values with `--weird`. Try starting with similar values for both. Example `/imagine prompt` `cyanotype cat --stylize 250 --weird 250`.

prompt example: `/imagine prompt` `cyanotype cat --weird 250`

`--weird 0`

`--weird 250`

`--weird 500`

`--weird 1000`

prompt example: `/imagine prompt` `lithograph potato --weird 250`

`--weird 0`

`--weird 250`

`--weird 500`

`--weird 1000`

prompt example: `/imagine prompt` `clockwork chicken --weird 250`

`--weird 0`

`--weird 250`

`--weird 500`

`--weird 1000`

### What's the difference between `--weird`, `--chaos`, and `--stylize`?

`--chaos` controls how diverse the initial grid images are from each other.  
`--stylize` controls how strongly Midjourney's default aesthetic is applied.  
`--weird` controls how unusual an image is compared to previous Midjourney images.

### How to Use Weird

Use the Weird Parameter

Add `--weird <value>` or `--w <value>` to the end of your prompt on Discord or in the imagine bar on the website:

Website Settings

You can set a default Weirdness using the Settings button in the imagine bar:

Adjust the slider left for lower values and right for higher values.

The value you set here will apply to all your prompts unless you specify a different value using the `--weird` or `--w` parameter in an individual prompt.



------

## Chapter 45: Text Generation

Text Generation

With Midjourney Version 6, you can use double quotation marks (`"`) around words or phrases in your prompts to specify text you want to appear in your images.

When using Midjourney Version 6, you can use "quotation marks" to indicate parts of your prompt you want to appear in your image as text: `a cyberpunk cat with a neon sign that says "Midjourney"`.

Single quote marks/apostrophes won't work--Midjourney only recognizes "words and phrases in double quotations" as text that should appear in the resulting image.

Text generation is supported for standard Latin alphabet (English) characters. Shorter words and phrases are more likely to be generated accurately.

If you're having trouble generating the exact word or phrase in your prompt, try using `--style raw` or lower Stylize values, or try using Vary Region to correct small issues.

### Examples

`/imagine prompt: a cyberpunk cat with a neon sign that says "Midjourney"`

`/imagine prompt: a pastel watercolor landscape with "/imagine" written in the clouds`

`/imagine prompt: a cartoon drawing of a manual with the words "read the docs" in big text on the pages`



------

## Chapter 46: Examples

### Image Prompts

Image Prompts

You can use images as part of a prompt to influence a Job's composition, style, and colors. Images prompts can be used alone or with text promptsexperiment with combining images with different styles for the most exciting results.

To add images to a prompt, type or paste the web address where the image is stored online. The address must end in an extension like .png, .gif, or .jpg. After adding image addresses, add any additional text and parameters to complete the prompt.

Prompts must have multiple image prompts or a single image prompt and a text prompt to work.

An image URL must be a direct link to an online image.

Your file should end in .png, .gif, .webp, .jpg, or .jpeg.

In most browsers, right-click or long-press an image and select Copy Image Address to get the URL.

The `/blend` command is a simplified image prompting process optimized for mobile users.

You can also use image URLs as Style References or Character References.

Privacy Notes

Upload images in your direct messages with the Midjourney Bot to prevent other server users from seeing an image.

Image prompts and references are visible on the Midjourney website unless you're generating in Stealth Mode.

### How to Use an Image in Your Prompt

1\. Upload an image to Discord

Follow these instructions to upload your image to Discord.

2\. Copy your image's URL

*Discord Desktop App: Right-click on the image and select Copy Link (NOT "Copy Message Link").

Discord Web App: Click to expand the image, then right-click and choose "Copy image address."

Discord Mobile App: Tap and hold on the image, then select "Copy Media Link."

If none of these methods work, you can click to expand the image, and at the bottom, select "Open in Browser" so you can copy and paste the image's URL.

To incorporate an image into your prompt, you need a direct image link that ends with .png, .gif, .webp, .jpg, or .jpeg. If the image is on your computer or phone, you can send it as a message to the Midjourney Bot first to generate a link.

How To Upload Your Image

Add an Image URL to Your Prompt

To add an image to a prompt, begin typing `/imagine` as usual. After the prompt box appears, drag the image file into the prompt box to add the image's URL, or right-click and paste the link within the prompt box.

### Examples

Starting Images

Greecian style statue

Vintage Flower Illustration

Ernst Haeckel's Jellyfish

Ernst Haeckel's Lichen

Hokusai's The Great Wave

Midjourney Model Version 5

Statue + Flowers

\+ 

Statue + Jellyfish

\+ 

Statue + Lichen

\+ 

Statue + Wave

\+ 

Statue + Lichen + Flowers

\+  \+ 

Aspect Ratio Tip

Crop images to the same aspect ratio as your final image for the best results.

### Image Weight Parameter

Use the image weight parameter `--iw` to adjust the importance of the image vs. text portion of a prompt. The default value is used when no `--iw` is specified. Higher `--iw` values mean the image prompt will have more impact on the finished job.

See the Multi Prompts page for more information about the relative importance between parts of a prompt.

Different Midjourney Version Models have different image weight ranges.

Version 6Version 5Version 4niji 6niji 5  
Image Weight Default11NA11  
Image Weight Range0302NA0302  
  
prompt example: `/imagine prompt` `flowers.jpg birthday cake --iw .5`

Image Prompt

--iw .25

--iw .5

--iw .75

--iw 1

--iw 1.25

--iw 1.5

--iw 1.75

--iw 2

--iw 3

### Technical Details

Prompts that only use images and no text are not compatible with the --stylize, or --weird parameters.



------

## Chapter 47: How to Use an Image in Your Prompt

1\. Upload an image to Discord

2\. Copy your image's URL

How To Upload Your Image

Add an Image URL to Your Prompt

Examples

Starting Images

Midjourney Model Version 5

Statue + Flowers

Statue + Jellyfish

Statue + Lichen

Statue + Wave

Statue + Lichen + Flowers

Image Weight Parameter

Technical Details

### Multi Prompts

Multi Prompts

The Midjourney Bot can blend multiple concepts using :: as a separator. Using a multi-prompt allows you to assign relative importance to the concept in the prompt, helping you control how they are blended together.

Multi-Prompt Basics

Adding a double colon `::` to a prompt indicates to the Midjourney Bot that it should consider each part of the prompt individually. For the prompt `space ship` both words are considered together, and the Midjourney Bot produces images of sci-fi spaceships. If the prompt is separated into two parts, `space:: ship`, both concepts are considered separately, then blended together creating a sailing ship traveling through space.  
  
There is no space between the double colons `::`  
Multi-prompts work with Model Versions `1`, `2`, `3`, `4`, `'5`, `niji`, and `niji 5`  
Any parameters are still added to the very end of the prompt.

`space ship`

space ship is considered as a single thought.

`space:: ship`

space and ship are considered separate thoughts

`cheese cake painting`

cheese cake painting is considered together, producing a painted image of a cheesecake.

`cheese:: cake painting`

cheese is considered separately from cake painting, producing images of painted cakes made of cheeses.

`cheese:: cake:: painting`

cheese, cake, and painting are considered separately, producing tiered cakes, made of cheeses with common classical painting compositions and elements.

Prompt Weights

When a double colon `::` is used to separate a prompt into different parts, you can add a number immediately after the double colon to assign the relative importance to that part of the prompt.

In the example below, the prompt `space:: ship` produced a sailing ship traveling through space. Changing the prompt to `space::2 ship` makes the word space twice as important as the word ship, producing images of space that have ships as a supporting element.

[Model Versions] `1`, `2`, `3` only accept whole numbers as weights  
[Model Versions] `4`, `niji 4`, `niji 5`, `5`, `5.1`, and `5.2` and can accept decimal places for weights  
Non-specified weights default to 1.

`space:: ship`

space and ship are considered as separate thoughts

`space::2 ship`

space is twice as important as ship

Weights are normalized:  
`space:: ship` is the same as `space::1 ship`, `space:: ship::1`, `space::2 ship::2`, `space::100 ship::100`, etc.  
`cheese::2 cake` is the same as `cheese::4 cake::2`, `cheese::100 cake::50` etc.  
`cheese:: cake:: painting` is the same as `cheese::1 cake::1 painting::1`, `cheese::1 cake:: painting::`, `cheese::2 cake::2 painting::2` etc.

### Negative Prompt Weights

Negative weights can be added to parts of a multi-prompt to help remove unwanted elements.  
The sum of all weights must be a positive number.

`still life gouache painting`

a range of objects appear in the still life

`still life gouache painting:: fruit::-.5`

The still life has fewer fruits

The `--no` Parameter

The `--no` parameter is the same as weighing part of a multi prompt to "-.5" `vibrant tulip fields:: red::-.5` is the same as `vibrant tulip fields --no red`.



------

## Chapter 48: Multi-Prompt Basics

space ship

space:: ship

Prompt Weights

space:: ship

space::2 ship

Negative Prompt Weights

The --no Parameter

### Remix

Remix

Enable Remix Mode to edit your prompt text and parameters after generating an image. It can help you change the setting or lighting of an image, evolve a subject, or acheive tricky compositions.

Turn Remix Mode on by using the `/prefer remix` command or by using `/settings` command and clicking the ` Remix Mode` button.

Once enabled, Remix Mode allows you to edit your prompt when you make a variation (including `Vary (Region)`), Reroll , or Pan an existing image.

You can edit image references, model version, parameters, and weights in addition to prompt text when using Remix Mode, but the resulting combination of prompt elements must still work.

If you don't change anything about the prompt in the Remix window, Midjourney will generate a normal variation.

Remixing takes into account your variation mode settings.

While `Remix Mode` is enabled, `V` buttons turn green instead of blue when clicked.

### Using Remix

Turn Remix Mode on by using the `/prefer remix` command or by using `/settings` command and clicking the ` Remix Mode` button. Once Remix mode is active:

Step 1

`line-art stack of pumpkins`

Click a ` Vary` or `V` button.

Select an image grid or upscaled image to Remix.

Step 2

`Remix`

Change your prompt.

Modify or enter a new prompt in the pop-up.

Results

`pile of cartoon owls`

The Midjourney Bot generates an image using the new prompt with influence from the original image.

Starting Image

line-art stack of pumpkins

Model Change

line-art stack of pumpkins --test

Subject Change

balloon-animal shaped stack of pumpkins"

Medium Change

vibrant illustrated stack of fruit

### Changing Parameters with Remix

You can add or remove Parameters while using Remix mode, but you must use valid parameter combinations. Changing `/imagine prompt` `illustrated stack of pumpkins --version 3 --stylize 10000` to `illustrated stack of pumpkins --version 4 --stylize 10000` will return an error because Midjourney Model Version 4 is incompatible with Stylize values over 1000.

Only parameters that normally influence variations will work while using Remix:

Affects Initial   
GenerationAffects Variations   
and Remix  
Aspect Ratio*  
Chaos  
Image Weight  
No  
Quality  
Seed  
Same Seed  
Stop  
Stylize  
Tile  
Video  
  
Changing aspect ratios with Remix will stretch an image. It will not extend the canvas, add missing details, or fix a bad crop. To adjust aspect ratios or fix cropping issues, try Zoom or Pan instead.

### Variation Modes and Remix

In Midjourney Versions 5 and 6 and Niji Versions 5 and 6, you can choose between ` High Variation Mode` (the default) and ` Low Variation Mode`. This setting applies to Remixing variations as well, which means you'll see stronger changes with High Variation Mode and subtler changes with Low Variation Mode. You may have trouble changing the subject or composition of your image with Remix if you have Low Variation Mode enabled, for example, but it can be useful for changing details.

Examples

Starting Image

a horse

Low Variation Mode

a unicorn - Remix (Subtle)

High Variation Mode

a unicorn - Remix (Strong)



------

## Chapter 49: Using Remix

Step 1

Step 2

Results

Starting Image

Model Change

Subject Change

Medium Change

Changing Parameters with Remix

Variation Modes and Remix

Examples

Starting Image

Low Variation Mode

High Variation Mode

### Style Tuner

Style Tuner

Personalize the appearance of your Midjourney images using the Style Tuner. Use the /tune command to generate a range of sample images showing different visual styles based on your prompt. Choose your favorite images, and you'll receive a unique code you can use to customize the look of future Jobs.

Share your Style Tuner and Codes with others to share, explore, and experiment with different aesthetics.

`/tune` and codes are only compatible with Midjourney Model Version 5.2  
`/tune` is not compatible with the current default Midjourney Model Version 6  
`/tune` is only available while in Fast Mode.  
`--style` parameters created with the Style Tuner are compatible with `--stylize` values between 20`1000.

### How to Use the Style Tuner

1\. Generate Your Custom Style Tuner

Create a Style Tuner page using the `/tune` command.

2\. Select Your Preferred Options

Style Directions: Choose the number of image pairs you want to see in your Style Tuner (16, 32, 64, or 128 pairs).

Default Mode: Select the style mode for your sample images (Default or Raw). If you typically do not use the --style raw parameter with your prompts, choose "default."

Use an Exisiting Style Tuner

If another user has previously generated a Style Tuner with your prompt, you will receive a link to that Tuner. Click the link to access the existing Style Tuner. Using a previously generated Style Tuner does not use your subscription's GPU minutes.

3\. Submit your Job

Click the `Submit` button.

Confirm your submission.

Your Style Tuner generates a pair of images for each Style Direction. A Style Tuner with 16 directions will generate 32 images. A Style Tuner with 128 directions will generate 256 images. Generating these images uses your subscription's Fast GPU time.

4\. Open Your Custom Style Tuner

When your Style Tuner is ready, the Midjourney Bot will send you a direct message with a link to your Tuner.

Click the link to open your Style Tuner in your web browser.

Try this Style Tuner: https://tuner.midjourney.com/ejYLCOY

5\. Select images

Your Style Tuner will show rows of image pairs, each representing a distinct visual direction for your prompt. Click on the image you prefer in each pair. If you don't feel strongly about either image, leave the empty middle box selected.

6\. Copy Your Code

The Style Tuner generates a code you can add to your prompts with the `--style <code>` Parameter. Learn more about parameters.

To copy your prompt and Parameter

Find your customized code at the bottom of the page.

Click the `Copy` button to copy your original prompt and newly generated `--style <code>` parameter.

You can share your Style Tuner page with friends and generate new codes without using any additional GPU minutes!

7\. Generate an Image

Return to Discord

Use the `/imagine` command and paste your copied prompt and `--style <code>` parameter into the `prompt` field.

Generate your image

8\. Use Additional Midjourney Tools

Take your image further by using other Midjourney tools like Upscale, Pan, Zoom-Out, Remix, or Vary-Region.

9\. Experiment and Explore

Use your style code with a new prompt:

The Style Tuner you create uses your initial prompt to create sample images and help you visualize the impact of your choices. However, the generated codes can be used with any prompt. Remember that styles and prompts always work together to generate an image, so a style code may not transfer as intended to other prompts.

Experiment: Style codes and prompts interact in complex ways. A code may have a strong effect on one prompt and a subtle effect on a similar prompt. The images you choose in your Style Tuner can combine in unexpected and creative ways. Use style codes as a tool to explore new looks and visuals.

Generate more codes: You can return to your Style Tuner page at any time to change your selections and create new codes.

Share style codes: You can share or use style codes created by friends.

Find a Style Tuner page: Find the Style Tuner page for any style code by adding it to this URL: https://tuner.midjourney.com/code/StyleCodeHere.

10\. Save and Reuse Your Codes

Use the `/settings` command and turn on ``Sticky Style`. Sticky Style will save the last `--style` parameter used in your personal suffix, so you don't have to repeat the code on future prompts. Change codes by using a new `--style` or unselecting ``Sticky Style`.

Use custom options to store your favorite codes.

Or, create your own Discord server to organize your images, prompts, image references, and Style Tuner codes.

### Style Tune Examples

`prompt` `vibrant california poppies`  
All images were made by style created using this Style Tuner

### Random Codes

Use the `--style random` parameter to apply a random 32 base styles Style Tuner code to your prompt. You can also use `--style random-16`, `--style random-64` or `--style random-128` to use random results from other lengths of tuners.

`--random` simulates Style Tuner code with random selections chosen for 75% of the image pairs. You can adjust this percentage by adding a number to the end of the `--random` parameter. For example, `--style random-32-15` simulates a 32-pair tuner with 15% of the image pairs selected, `--style random-128-80` simulates a 128-pair tuner with 80% of the image pairs selected.

### Combine Codes

Combine multiple codes in one parameter with a hyphen, `--style code1-code2`.  
Combine multiple codes and style raw: `--style raw-code1-code2`

### Style Tuner and --stylize

The `--stylize` parameter adjusts the influence of the --style parameter on your generated images. If you're not seeing the desired effect from your code, consider combining it with higher stylization values, like `--stylize 250`, or `--stylize 500`.

Comparison

`prompt` `vibrant California poppies --style fdeQ4zOX5jd --stylize 250`

--stylize 20

--stylize 100 (default)

--stylize 250

--stylize 750

### Style Raw

Combine your custom style code with Midjourney Style Raw by using `--style raw-<code>`.  
Example: To use Style Raw and `--style fjo5S8BgMoV` use `--style raw-fjo5S8BgMoV`.

### Style Tuner and Niji Model Version

Style Tuner codes created with the Midjourney Bot are not compatible with the Niji Model version accessed through the Midjourney Bot. To create a Style Tuner or Code for Niji Model version, join the Niji Discord community and interact with the Niji Bot in the same way you interact with the Midjourney Bot. Your Midjourney subscription gives you access to the Niji community and Bot.

### Technical Details

`/tune` is compatible with prompts that include the following:  
--aspect  
--chaos  
--tile  
multi prompts

`/tune` and style codes are not compatible with image prompts that do not include a text prompt.

If your `/tune` command does not return a clickable link, check that Embeds and Link Previews is enabled in your Discord App Settings  

### There are two modes for image generation, Fast Mode and Relax Mode. Fast Mode tries to give you a GPU instantly. It's the highest-priority processing tier and uses your subscription's monthly GPU time. Relax Mode queues your generation behind others based on how much you've used the system. Relax Mode wait times are variable and usually range from 1`10 minutes

By default, your images will be generated using Fast mode. You can switch to Relax if you have a Standard or Pro subscription.

There are two modes for image generation, Fast Mode and Relax Mode. Fast Mode tries to give you a GPU instantly. It's the highest-priority processing tier and uses your subscription's monthly GPU time. Relax Mode queues your generation behind others based on how much you've used the system. Relax Mode wait times are variable and usually range from 1`10 minutes.

By default, your images will be generated using Fast mode. You can switch to Relax if you have a Standard or Pro subscription.

Parameters are options added to a prompt that change how an image generates. Parameters can change an image's Aspect Ratios, switch between Midjourney Model Versions, change which Upscaler is used, and lots more.



------

## Chapter 50: How to Use the Style Tuner

1\. Generate Your Custom Style Tuner

2\. Select Your Preferred Options

3\. Submit your Job

4\. Open Your Custom Style Tuner

5\. Select images

6\. Copy Your Code

7\. Generate an Image

8\. Use Additional Midjourney Tools

9\. Experiment and Explore

10\. Save and Reuse Your Codes

Style Tune Examples

Random Codes

Combine Codes

Style Tuner and --stylize

Comparison

Style Raw

Style Tuner and Niji Model Version

Technical Details

### Pan

Pan

The Pan option allows you to expand the canvas of an image in a chosen direction without changing the content of the original image. The newly expanded canvas will be filled in using guidance from the prompt and the original image.

Pan allows you to increase the image resolution beyond the maximum 1024px x 1024px dimensions in one direction.  
Pan is compatible with Midjourney Model Version 5, 5.1, 5.2, and niji 5

Panning an Image

The Pan buttons `` `` `` `` will appear after upscaling an image. When panning, only the closest 512 pixels to the side of the image, along with the prompt, are used to determine the new section.

`Prompt: A vibrant fantasy landscape`

Starting Image

Pan ``

Pan ``

Pan ``

Pan ``

After panning an image once, you can only pan that image again in the same direction (horizontal/vertical). You may continue to pan in that direction as often as you like. After panning several times, the image may become too large to send on Discord. When this happens, you will be sent a link to the image instead.

Pan `` and `` several times

### Pan with Remix Mode

Panning supports Remix Mode. This allows you to change your prompt when panning.

Starting Image

Starting prompt: `A vibrant fantasy landscape`

Pan `` \+ `Remixed Prompt`

Pan `` \+ ` Remix prompt: A vibrant fantasy city`



------

## Chapter 51: Panning an Image

Pan with Remix Mode

### Zoom Out

Zoom Out

The Zoom Out option allows you to extend the canvas of an upscaled image beyond its original boundaries without changing the content of the original image. The newly expanded canvas will be filled-in using guidance from the prompt and the original image.

`Zoom Out` does not increase the maximum 1024px x 1024 px size of an image.

### Zoom Out

` Zoom Out 2X` ` Zoom Out 1.5X` buttons will appear after upscaling an image.

Prompt: vibrant California poppies

`Starting Image`

`Zoom Out 1.5X`

`Zoom Out 2X`

### Make Square

With `Make Square` you can adjust the aspect ratio of a non-square image to make it square. If the original aspect ratio is wide (landscape), it will be expanded vertically. If it is tall (portrait), it will be expanded horizontally. The emoji `` `` next to the ` Make Square` button also indicates which way the image will be expanded. The ` Make Square` button will appear underneath non-square upscaled images.

Prompt: vibrant California poppies

`Starting Image`

` Make Square`

`Starting Image`

` Make Square`

### Custom Zoom

The ` Custom Zoom` button lets you choose how much to zoom out on an image. ` Custom Zoom` button under an upscaled image will pop up a dialogue box where you enter a custom value for `--zoom`. `--zoom` accepts values between 1-2.

Change the Aspect Ratio of an Upscaled Image

You can use `--zoom 1` in this `Custom Zoom` pop-up box to change the aspect ratio, with the `--ar parameter`, without zooming out.

Change Your Prompt with Custom Zoom

` Custom Zoom` allows you to change the prompt before you expand your image, giving you finer control over the finished image. For example, changing the prompt to "A framed picture on the wall" gives this result:

`Starting Image`

prompt: vibrant California poppies

`Custom Zoom + Changed Prompt`

`Zoom Out` prompt: A framed picture on the wall --zoom 2



------

## Chapter 52: Zoom Out

Make Square

Custom Zoom

Change Your Prompt with Custom Zoom

### Permutation Prompts

Permutation Prompts

Permutation Prompts allow you to quickly generate variations of a prompt with a single `/imagine` command. By including lists of options separated with commas `, ` within curly braces `{}` in your prompt, you can create multiple versions of a prompt with different combinations of those options.

Basic Subscribers can create a maximum of 4 Jobs with a single Permutation Prompt.  
Standard Subscribers can create a maximum of 10 Jobs with a single Permutation Prompt.  
Pro and Mega Subscribers can create a maximum of 40 Jobs with a single Permutation Prompt.

You can use Permutation Prompts to create combinations and permutations involving any part of a Midjourney Prompt, including text, image prompts, parameters, or prompt weights.  
Permutation prompts are only available while using Fast mode.

### Permutation Prompt Basics

Separate your list of options within curly brackets {} to quickly create and process multiple prompt variations.  
  
Prompt Example:  
`/imagine prompt` `a {red, green, yellow} bird` creates and processes three Jobs.

`/imagine prompt` `a red bird`  
`/imagine prompt` `a green bird`  
`/imagine prompt` `a yellow bird`

GPU Minutes

The Midjourney Bot processes each Permutation Prompt variation as an individual Job. Each Job consumes GPU minutes.

Permutation Prompts will show a confirmation message before they begin processing.

### Permutation Prompt Examples

Prompt Text Variations

The prompt `/imagine prompt` `a naturalist illustration of a {pineapple, blueberry, rambutan, banana} bird` will create and process four Jobs:

a naturalist illustration of a pineapple bird

a naturalist illustration of a blueberry bird

a naturalist illustration of a rambutan bird

a naturalist illustration of a banana bird

### Prompt Parameter Variations

The prompt `/imagine prompt` `a naturalist illustration of a fruit salad bird --ar {3:2, 1:1, 2:3, 1:2}` will create and process four Jobs with different aspect ratios:

a naturalist illustration of a fruit salad bird --ar 3:2

a naturalist illustration of a fruit salad bird --ar 1:1

a naturalist illustration of a fruit salad bird --ar 2:3

a naturalist illustration of a fruit salad bird --ar 1:2

The prompt `/imagine prompt` `a naturalist illustration of a fruit salad bird --{v 5, niji, test}` will create and process three Jobs using different Midjourney Model Versions:

a naturalist illustration of a fruit salad bird --v 5

a naturalist illustration of a fruit salad bird --niji

a naturalist illustration of a fruit salad bird --test

### Multiple and Nested Permutations

It is possible to use multiple sets of bracketed options in a single prompt.  
`/imagine prompt` `a {red, green} bird in the {jungle, desert}` creates and processes four Jobs.

`/imagine prompt` `a red bird in the jungle`  
`/imagine prompt` `a red bird in the desert`  
`/imagine prompt` `a green bird in the jungle`  
`/imagine prompt` `a green bird in the desert`

It is also possible to nest sets of bracketed options inside other sets of brackets within a single prompt:

Example: `/imagine prompt` `A {sculpture, painting} of a {seagull {on a pier, on a beach}, poodle {on a sofa, in a truck}}.`

`/imagine prompt` `A sculpture of a seagull on a pier.`  
`/imagine prompt` `A sculpture of a seagull on a beach.`  
`/imagine prompt` `A sculpture of a poodle on a sofa.`  
`/imagine prompt` `A sculpture of a poodle in a truck.`  
`/imagine prompt` `A painting of a seagull on a pier.`  
`/imagine prompt` `A painting of a seagull on a beach.`  
`/imagine prompt` `A painting of a poodle on a sofa.`  
`/imagine prompt` `A painting of a poodle in a truck.`  
  

### Escape Character

If you want to include a `, ` within the curly brackets that does not act as a separator place a backslash `\` directly before it.

`imagine prompt` `{red, pastel, yellow} bird` produces three Jobs  
`/imagine prompt` `a red bird`  
`/imagine prompt` `a pastel bird`  
`/imagine prompt` `a yellow bird`

`imagine prompt` `{red, pastel \, yellow} bird` produces two Jobs  
`/imagine prompt` `a red bird`  
`/imagine prompt` `a pastel, yellow bird`

There are two modes for image generation, Fast Mode and Relax Mode. Fast Mode tries to give you a GPU instantly. It's the highest-priority processing tier and uses your subscription's monthly GPU time. Relax Mode queues your generation behind others based on how much you've used the system. Relax Mode wait times are variable and usually range from 110 minutes.

By default, your images will be generated using Fast mode. You can switch to Relax if you have a Standard or Pro subscription.

A Job is any action that uses the Midjourney Bot. Jobs include using `/imagine` to create an initial image grid, upscaling images, and creating variations of images.

The Midjourney Bot processes jobs on high-end GPUs. Each minute that it takes to complete a job is a GPU minute. You have a limited amount of GPU minutes when in Fast Mode. Because image generations may be processed on multiple GPUs simultaneously, GPU minutes are not directly connected to the time you wait for an image to generate.



------

## Chapter 53: Permutation Prompt Basics

Permutation Prompt Examples

Prompt Text Variations

Prompt Parameter Variations

Multiple and Nested Permutations

Escape Character

### Remaster

Remaster

Remaster

The Remaster feature is available for upscaled images generated using earlier Midjourney Model Versions. It creates a new grid of images using the latest Midjourney Model, combining the original image's composition with the coherency of the newer Midjourney Model Version v5.2.

Remaster any previously upscaled job by clicking the ` Remaster` button beneath the original upscale.

To Remaster very old jobs, use the `/show` command to refresh that job in Discord.

prompt example: `/imagine prompt` `Byzantine sandcastle cathedral --v 2`

Original Model Version 2 Image

Remastered with Model Version 5.2



------

## Chapter 54: Remaster

### Model Version 5

Model Version 5

Midjourney regularly introduces new model versions to improve coherency, efficiency, quality, and style. You can switch model versions by using the /settings command and selecting your preferred model version. Different models excel at producing different types of images.

Read about the latest Midjourney Models here.

### Default Parameter Values

Model Version 5, 5.1, and 5.2

Aspect RatioChaosQualitySeedStopStylize  
Default Value   
1:101Random100100  
Range   
any0100.25 .5, or 1whole numbers 042949672951010001000  
  
Aspect ratios greater than 2:1 are experimental and may produce unpredictable results.

### Model Version 5.2 (Legacy)

The Midjourney V5.2 model was released in June 2023. To use this model, add the `--v 5.2` parameter to the end of a prompt, or use the `/settings` command and select `5 MJ Version 5.2`

Default Model 06/22/2302/14/2024

This model produces more detailed, sharper results with better colors, contrast, and compositions. It also has a slightly better understanding of prompts than earlier models and is more responsive to the full range of the `--stylize` parameter.

Prompt: vibrant California poppies --v 5.2

Prompt: high contrast surreal collage --v 5.2

Model Version 5.2 + Style Raw Parameter

Midjourney Model Versions 5.1 and 5.2 can be fine-tuned with the `--style raw` parameter to reduce the Midjourney default aesthetic.

Read more about the Midjourney `--style` parameter.

`default --v 5.2`

`vibrant California poppies`

`--v 5.2 --style raw`

`vibrant California poppies --style raw`

`default --v 5.2`

`high contrast surreal collage`

`--v 5.2 --style raw`

`high contrast surreal collage --style raw`

### Model Version 5.1 (Legacy)

The Midjourney V5.1 was released on May 4th, 2023. To use this model, add the `--v 5.1` parameter to the end of a prompt, or use the `/settings` command and select `5 MJ Version 5.1`

Default Model 05/03/2306/22/23

This model has a stronger default aesthetic than earlier versions, making it easier to use with simple text prompts. It also has high Coherency, excels at accurately interpreting natural language prompts, produces fewer unwanted artifacts and borders, has increased image sharpness, and supports advanced features like repeating patterns with `--tile`.

Prompt: vibrant California poppies --v 5.1

Prompt: high contrast surreal collage --v 5.1

### Model Version 5.0 (Legacy)

The Midjourney V5.0 model produces more photographic generations than the V5.1 model. This model produces images that closely match the prompt but may require longer prompts to achieve your desired aesthetic.

Default Model 03/30/2305/03/23

To use this model, add the `--v 5` parameter to the end of a prompt, or use the `/settings` command and select `5 MJ Version 5`  
  
Prompt: vibrant California poppies --v 5

Prompt: high contrast surreal collage --v 5

### Niji Model 5 (Legacy)

The Niji model is a collaboration between Midjourney and Spellbrush tuned to produce anime and illustrative styles with vastly more knowledge of anime, anime styles, and anime aesthetics. It's excellent at dynamic and action shots and character-focused compositions.

To use this model, add the `--niji 5` parameter to the end of a prompt, or use the `/settings` command and select ` Niji version 5`

This model is sensitive to the `--stylize` parameter. Experiment with different stylization ranges to fine-tune your images.

Niji 5 Styles

Niji Model Version 5 can also be fine-tuned with `--style` parameters to achieve unique looks. Try `--style cute`, `--style scenic`, `--style original` (uses the original Niji Model Version 5, which was the default before May 26th, 2023), or `--style expressive`.

Niji Style Parameters  
`--style cute` creates charming and adorable characters, props, and settings.  
`--style expressive` has a more sophisticated illustrated feeling.  
`--style original` uses the original Niji Model Version 5, which was the default before May 26th, 2023.  
`--style scenic` makes beautiful backgrounds and cinematic character moments in the context of their fantastical surroundings.

`default --niji 5`

birds perching on a twig --niji 5

`--style original`

birds perching on a twig --niji 5 --style original

`--style cute`

birds perching on a twig --niji 5 --style cute

`--style expressive`

birds perching on a twig --niji 5 --style expressive

`--style scenic`

birds perching on a twig --niji 5 --style scenic

### V5 Upscaler Tools

Midjourney Model Version 5.2 produces grids of 1024 x 1024 pixel images. Use the `U1` `U2` `U3` `U4` buttons under each image grid to separate your selected image from its grid. You can then use the `Upscale (2x)` or `Upscale (4x)` tools to increase the size of your image.

`Upscale` tools use your subscription's GPU minutes. Using `Upscale 2X` on an image takes roughly twice as long as generating an initial image grid. Using `Upscale 4X` on an image takes roughly six times as long as generating an initial image grid.

V5 `Upscale` tools are not compatible with the pan tool or the tile parameter.

Upscaler Comparison

`Upscale (2x)`

Original 1024 by 1024 pixel image

Detail from the original image

After `Upscale (2x)` to 2048 x 2048 px

### Upscaler Comparison

Prompt: `1960s pop-art acrylic of redwoods`  
Original 1024 by 1024 pixel image.

Original 1024 by 1024 pixel image

Detail from the original image

After `Upscale (4x)` to 4096 x 4096 px

### Influence of --stylize on Model Version 5

Midjourney Model Version 5 Stylize Comparison

prompt example: `/imagine prompt` `child's drawing of a cat --s 100`

`--stylize 50`

Equal to ` Style Low`

`--stylize 100` (default)

Equal to ` Style Med`

`--stylize 250`

Equal to ` Style High`

`--stylize 750`

Equal to ` Style Very High`

Niji 5 Stylize Comparison

prompt example: `/imagine prompt` `colorful risograph of a fig --niji 5 --s 100`

`--stylize 50`

` Style Low`

`--stylize 100` (default)

` Style Med`

`--stylize 250`

` Style High`

`--stylize 750`

` Style Very High`

Coherency is the strength of the connection between the text prompt and the resulting image. A high degree of coherency means that the image will be an accurate representation of the prompt text.

The Midjourney Bot processes jobs on high-end GPUs. Each minute that it takes to complete a job is a GPU minute. You have a limited amount of GPU minutes when in Fast Mode. Because image generations may be processed on multiple GPUs simultaneously, GPU minutes are not directly connected to the time you wait for an image to generate.



------

## Chapter 55: Default Parameter Values

Model Version 5.2 (Legacy)

Model Version 5.2 + Style Raw Parameter

Model Version 5.1 (Legacy)

Model Version 5.0 (Legacy)

Niji Model 5 (Legacy)

Niji 5 Styles

V5 Upscaler Tools

Upscaler Comparison

Upscaler Comparison

Influence of --stylize on Model Version 5

Midjourney Model Version 5 Stylize Comparison

Niji 5 Stylize Comparison

### Model Version 4

Model Version 4

Midjourney regularly introduces new model versions to improve coherency, efficiency, quality, and style. You can switch model versions by using the /settings command and selecting your preferred model version. Different models excel at producing different types of images.

Read about the latest Midjourney Models here

### Default Paramter Values

Model Version 4

Aspect RatioChaosQualitySeedStopStyleStylize  
Default Value   
1:101Random1004c100  
Range   
1:22:10100.25 .5 or 1whole numbers 04294967295101004a, 4b, or 4c01000  
  

### Model Version 4 (Legacy)

The Midjourney V4 model is an entirely new codebase and brand-new AI architecture designed by Midjourney and trained on the new Midjourney AI supercluster. The latest Midjourney model has more knowledge of creatures, places, objects, and more. It's much better at getting small details right and can handle complex prompts with multiple characters or objects. The Version 4 model supports advanced functionality like image prompting and multi-prompts.

This model has very high Coherency and excels with Image Prompts.

Prompt: vibrant California poppies

Prompt: high contrast surreal collage

Version 4 Styles 4a, 4b, and 4c

Midjourney Model Version 4 has three slightly different "flavors" with slight tweaks to the stylistic tuning of the model. Experiment with these versions by adding `--style 4a`, `--style 4b`, or `--style 4c` to the end of a V4 prompt.

`--v 4 --style 4c` is the current default and does not need to be added to the end of a prompt.

Note on Style 4a and 4b

`--style 4a` and `--style 4b` only support 1:1, 2:3, and 3:2 aspect ratios.  
`--style 4c` support aspect ratios up to 1:2 or 2:1.

`--style 4a`

vibrant California poppies --style 4a

`--style 4b`

vibrant California poppies --style 4b

`--style 4c`

vibrant California poppies --style 4c

`--style 4a`

school of fish --style 4a

`--style 4b`

school of fish --style 4b

`--style 4c`

school of fish --style 4c

### Niji Model 4 (Legacy)

The `niji 4` model is a collaboration between Midjourney and Spellbrush tuned to produce anime and illustrative styles. The `--niji 4` model has vastly more knowledge of anime, anime styles, and anime aesthetics. It's excellent at dynamic and action shots and character-focused compositions in general.

prompt example: `/imagine prompt` `vibrant California poppies --niji 4`

`--v 4`

California poppies --v 4

`--niji 4`

California poppies --niji 4

`--v 4`

birds sitting on a twig --v 4

`--niji 4`

birds sitting on a twig --niji 4

### V4 Upscaler Tools

Earlier Midjourney model versions start by generating a grid of low-resolution image options for each Job. You can use a Midjourney upscaler on any of these images to increase the size and add additional details. There are multiple upscale models available for upscaling an image. Using an upscaler uses your subscription's GPU minutes.

The `U1` `U2` `U3` `U4` buttons under each image grid are used to upscale the selected image.

Read more about current upscaling options

Midjourney Dimensions and Sizes

All sizes are for square 1:1 aspect ratios.

Model VersionStarting Grid SizeV4 Default UpscalerDetail UpscaleLight UpscaleBeta Upscale  
Version 4512 x 5121024 x 10241024 x 10241024 x 10242048 x 2048  
niji 4512 x 5121024 x 10241024 x 10241024 x 10242048 x 2048  
  
Model Version 4 Upscaler

The Midjourney Model Version 4 upscaler increases image size while smoothing or refining details. Some small elements may change between the initial grid image and the finished upscale.

prompt: `adorable rubber duck medieval knight`

prompt: `sand cathedral`

### Influence of Stylize on Model V4

prompt example: `/imagine prompt` `illustrated figs --v 4 --s 100`

`--stylize 50`

` Style Low`

`--stylize 100` (default)

` Style Med`

`--stylize 250`

` Style High`

`--stylize 750`

` Style Very High`

### Coherency is the strength of the connection between the text prompt and the resulting image. A high degree of coherency means that the image will be an accurate representation of the prompt text

The Midjourney Bot processes jobs on high-end GPUs. Each minute that it takes to complete a job is a GPU minute. You have a limited amount of GPU minutes when in Fast Mode. Because image generations may be processed on multiple GPUs simultaneously, GPU minutes are not directly connected to the time you wait for an image to generate.



------

## Chapter 56: Default Paramter Values

Model Version 4 (Legacy)

Version 4 Styles 4a, 4b, and 4c

Niji Model 4 (Legacy)

V4 Upscaler Tools

Midjourney Dimensions and Sizes

Model Version 4 Upscaler

Influence of Stylize on Model V4

### Early Model Versions

Early Model Versions

Midjourney regularly introduces new model versions to improve coherency, efficiency, quality, and style. You can switch model versions by using the /settings command and selecting your preferred model version. Different models excel at producing different types of images.

Read about the latest Midjourney Models here

### Model Version 1, 2, and 3 (Legacy)

You can access earlier midjourney models by using the `--version` or `--v` parameter or by using the `/settings` command and selecting a model version. Different models excel at different types of images.

prompt example: `/imagine prompt` `vibrant California poppies --v 1`

`--version 3`

default model: 07/2211/22

highly creative compositions

moderate coherency

`--version 2`

default model: 04/2207/22

creative, colorful, and painterly

low coherency

`--version 1`

default model: 02/2204/22

very abstract and painterly

low coherency

`--hd` (high definition)

early alternative model

busy detailed and abstract

low coherency

### Niji Model 4 (Legacy)

The `niji 4` model is a collaboration between Midjourney and Spellbrush tuned to produce anime and illustrative styles. The `--niji 4` model has vastly more knowledge of anime, anime styles, and anime aesthetics. It's excellent at dynamic and action shots and character-focused compositions in general.

prompt example: `/imagine prompt` `vibrant California poppies --niji 4`

`--v 4`

California poppies --v 4

`--niji 4`

California poppies --niji 4

`--v 4`

birds sitting on a twig --v 4

`--niji 4`

birds sitting on a twig --niji 4

### Test Models (Legacy)

Occasionally new models are released temporarily for community testing and feedback. There are currently two available test models: `--test` and `--testp`, which can be combined with the `--creative` parameter for more varied compositions.

prompt example: `/imagine prompt` `vibrant California poppies --testp --creative`

`--test`

A general-purpose artistic model with good coherency 

`--test` \+ `--creative`

`--testp`

A photo-realism model with good coherency

`--testp` \+ `--creative`

Notes on current test models `--test` and `--testp`

Test models only support `--stylize` values between 12505000.  
Test models do not support multi-prompts or image-prompts  
Test models have a maximum aspect ratio of 3:2 or 2:3.  
Test models only generate two initial grid images when the aspect ratio is 1:1.  
Test models only generate one initial grid image when the aspect ratio is not 1:1.  
Words near the front of the prompt may matter more than words near the back.

### Early Model Upscaler Tools

Earlier Midjourney model versions start by generating a grid of low-resolution image options for each Job. You can use a Midjourney upscaler on any of these images to increase the size and add additional details. There are multiple upscale models available for upscaling an image. Using an upscaler uses your subscription's GPU minutes.

The `U1` `U2` `U3` `U4` buttons under each image grid are used to upscale the selected image.

Read more about current upscaling options

Midjourney Dimensions and Sizes

All sizes are for square 1:1 aspect ratios.

Model VersionStarting Grid SizeV4 Default UpscalerDetail UpscaleLight UpscaleBeta UpscaleMax Upscale**  
v1v3256 x 256-1024 x 1024*1024 x 10241024 x 10241664 x 1664  
niji512 x 5121024 x 10241024 x 10241024 x 10242048 x 2048-  
test / testp512 x 512---2048 x 2048-  
hd512 x 512-1536 x 1536*1536 x 15362048 x 2048-  
  
`*` = the default upscaler for each Midjourney Version Model.  
`**` Max Upscale is an older resource-intensive upscaler and is only available when users are in Fast Mode.

Light Upscaler

The Light Upscaler creates a 1024px x 1024px image and adds a moderate amount of details and textures. The Light Upscaler is useful for faces and smooth surfaces when using older Midjourney Model Versions.

Use the `--uplight` parameter to change the behavior of the `U1` `U2` `U3` `U4` upscale buttons to use the Light Upscaler.

prompt: `adorable rubber duck medieval knight`

prompt: `sand cathedral`

Detailed Upscaler

The Detail Upscaler creates a 1024px x 1024px image and adds many additional fine details to the image.

Images that have been upscaled with the detailed upscaler can be upscaled again using the `Upscale to Max` button for a final resolution of 1664px x 1664px. `Upscale to Max` is only available when in Fast mode.

The Detailed upscaler was the default for Midjourney Model Versions `V1`, `V2`, `V3`, and `hd`

prompt: `adorable rubber duck medieval knight`

prompt: `sand cathedral`

Beta Upscaler

The Beta Upscaler creates a 2048px x 2048px image without adding many additional details. The Beta Uspcaler is useful for faces and smooth surfaces.

Use the `--upbeta` parameter to change the behavior of the `U1` `U2` `U3` `U4` upscale buttons to use the Beta Upscaler.

prompt: `adorable rubber duck medieval knight`

prompt: `sand cathedral`

The Midjourney Bot processes jobs on high-end GPUs. Each minute that it takes to complete a job is a GPU minute. You have a limited amount of GPU minutes when in Fast Mode. Because image generations may be processed on multiple GPUs simultaneously, GPU minutes are not directly connected to the time you wait for an image to generate.

There are two modes for image generation, Fast Mode and Relax Mode. Fast Mode tries to give you a GPU instantly. It's the highest-priority processing tier and uses your subscription's monthly GPU time. Relax Mode queues your generation behind others based on how much you've used the system. Relax Mode wait times are variable and usually range from 110 minutes.

By default, your images will be generated using Fast mode. You can switch to Relax if you have a Standard or Pro subscription.



------

## Chapter 57: Model Version 1, 2, and 3 (Legacy)

Niji Model 4 (Legacy)

Test Models (Legacy)

Early Model Upscaler Tools

Midjourney Dimensions and Sizes

Light Upscaler

Detailed Upscaler

Beta Upscaler

### Legacy Model Version Parameters

Legacy Model Version Parameters

Parameters are options added to a prompt that change how an image generates. Parameters can change an image's Aspect Ratios, switch between Midjourney Model Versions, change which Upscaler is used, and lots more.

The parameters on this page only work with legacy Midjourney Model Versions. For information on parameters that work with the latests Midjourney Model Versions read more here.

### Legacy Model Version Parameters

Midjourney routinely releases new model versions to improve efficiency, coherency, and quality. Different models excel at different types of images.

Niji

`--niji 4` and `niji 5` Use an alternative model focused on anime style images.

High Definition

`--hd` Use an early alternative Model that produces larger, less consistent images. This algorithm may be suitable for abstract and landscape images.

Test

`--test` Use the Midjourney special test model.

Testp

`--testp` Use the Midjourney special photography-focused test model.

Version

`--version <1, 2, 3, 4, or 5>` or `--v <1, 2, 3, 4, or 5>` Use a different version of the Midjourney algorithm. The current algorithm is the default setting.

Legacy Upscaler Parameters

Midjourney starts by generating a grid of low-resolution image options for each Job. You can use a Midjourney upscaler on any grid image to increase the size and add additional details. There are multiple upscale models available for upscaling an image.

Uplight

`--uplight` Use an alternative "light" upscaler when selecting the U buttons. The results are closer to the original grid image. The upscaled image is less detailed and smoother.

Upbeta

`--upbeta` Use an alternative beta upscaler when selecting the U buttons. The results are closer to the original grid image. The upscaled image has significantly fewer added details.

Legacy Parameters

These parameters only work with specific earlier Midjourney Models.

Creative

`--creative` Modify the `test` and `testp` models to be more varied and creative.

Sameseed

`--sameseed` Seed values create a single large random noise field applied across all images in the initial grid. When --sameseed is specified, all images in the initial grid use the same starting noise and will produce very similar generated images.

### Compatibility

Legacy Model Version & Parameter Compatability

Affects initial generationAffects variations + remixVer. 5Ver. 4Ver. 3Test /  
TestpNiji 4Niji 5  
Max Aspect Ratioany1:2 or 2:15:2 or 2:53:2 or 2:31:2 or 2:1any  
Chaos  
Image Weight.52   
default=1.52   
default=1any   
default=.25.52   
default=1  
No  
Quality.251.251.252.252.252  
Repeat  
Seed  
Sameseed  
Stop  
Styleraw4a, and 4bexpressive, and cute  
Stylize01000   
default=10001000   
default=10062560000   
default=2500)12505000   
default=2500)01000   
default=100)  
Tile  
Video  
Weird  
Number of Grid Images--4442 (1 when aspect ratio1:1)44  
  

### Deprecated Parameters

--width and --w (replaced with --aspect)  
--height and --h (replaced with --aspect)  
--fast (replaced with --quality)  
--vibe (now known as V1)  
--upanime  
--hq  
--newclip  
--nostretch  
--old



------

## Chapter 58: Legacy Model Version Parameters

Niji

High Definition

Test

Testp

Version

Legacy Upscaler Parameters

Uplight

Upbeta

Legacy Parameters

Creative

Sameseed

Compatibility

Legacy Model Version & Parameter Compatability

Deprecated Parameters

### Subscription Plans

Subscription Plans

Midjourney has four subscription tiers. Pay month-to-month or for the entire year for a 20% discount. Each subscription plan includes access to the Midjourney member gallery, the official Discord, general commercial usage terms, and more.

How to Subscribe

In the Midjourney Discord server use the `/subscribe` command to generate a personal link to the subscription page.

Or, log into the Midjourney website and go to Midjourney.com/account.

Or, log into the Midjourney website and click on your name and then `Manage Subscription` from the sidebar.

Billing and Subscription Help

For billing and subscription questions, please visit help.midjourney.com.

### Plan Comparison

Basic PlanStandard PlanPro PlanMega Plan  
Monthly Subscription Cost$10$30$60$120  
Annual Subscription Cost$96   
($8 / month)$288   
($24 / month)$576   
($48 / month)$1152   
($96 / month)  
Fast GPU Time3.3 hr/month15 hr/month30 hr/month60 hr/month  
Relax GPU Time-UnlimitedUnlimitedUnlimited  
Purchase Extra  
GPU Time$4/hr$4/hr$4/hr$4/hr  
Work Solo In Your  
Direct Messages  
Stealth Mode--  
Maximum Concurrent Jobs3 Jobs  
10 Jobs waiting in queue3 Jobs  
10 Jobs waiting in queue12 Fast Jobs  
3 Relaxed Jobs   
10 Jobs in queue12 Fast Jobs  
3 Relaxed Jobs   
10 Jobs in queue  
Rate Images to Earn Free GPU Time  
Usage RightsGeneral Commercial Terms*General Commercial Terms*General Commercial Terms*General Commercial Terms*  
  
If you have subscribed at any point, you are free to use your images in just about any way you want. You must purchase the Pro or Mega plan if you are a company making more than $1, 000, 000 USD in gross revenue per year. For complete details, please see the Terms of Service

Subscribe to a Plan

Go to https://www.midjourney.com/account/ or use the `/subscribe` command to generate a link to the subscription page.

Don't Share Your Link

The generated link is unique for each account and should never be shared with others!

Payment Methods

Only payment methods supported by Stripe are currently accepted: credit or debit cards issued by services like Mastercard, VISA, or American Express. Stripe is a PCI Service Provider Level 1, the most stringent level of certification available in the payments industry.

Google Pay and Apple Pay are available in some regions.

PayPal, wire transfer, and similar methods are not supported.

### Manage Your Plan

Manage your subscription plan at https://www.midjourney.com/account/.

Automatic Renewal

Unused monthly Fast GPU time does not roll over.

Your payment method on file with our third party payment processor will be automatically charged at the end of each monthly or annual billing period.

Switch Plans

Upgrade your plan at any time. When upgrading, you may choose whether the upgrade should be effective immediately or at the end of the current billing cycle. If you choose to upgrade immediately, you will be offered a prorated price based on the usage of the plan you are upgrading from. Downgrades are always effective at the end of the current billing cycle.

Proration?

Unused Fast GPU Time is credited towards your account when you choose to upgrade immediately. If a Basic subscriber upgrades immediately without using any GPU time, they receive a $10 credit towards their new plan. If a Standard subscriber upgrades after using 50% of their Fast GPU time, they receive a $15 credit towards their new plan.

Cancellation

Go to https://www.midjourney.com/account/ to cancel a subscription at any time. Cancellations are effective at the end of the current billing cycle. Subscription benefits like access to the community gallery and the bulk download tool are available until the end of the current billing cycle.

Your generated images and Midjourney.com/account page are not deleted if you cancel your subscription. You can resubscribe to a plan at any time by visiting https://www.midjourney.com/account/.

Refunds

Refunds are available for subscribers who have lifetime usage of less than 20 GPU minutes, including time used in Relax Mode. If you are eligible for a refund, the dialog box will automatically pop up when you click to cancel your account.

### Buy More Fast Hours

Run out of Fast GPU and want to buy more before your monthly subscription renews? You can purchase additional Fast GPU hours for $4/hr. Hourly Prices are experimental and subject to change.

Purchase more Fast GPU hours on your Midjourney account page.

You must have an active subscription to use Fast GPU hours

Purchased Fast GPU hours expire after 60 days (effective October 1, 2024)

Refunds will not be issued on Fast Hours

Account Information

Use the `/info` command to view information about your account, including how much Fast time is left for the subscription period, lifetime usage stats, the number of queued or running jobs, and the subscription renewal date.



------

## Chapter 59: Plan Comparison

Subscribe to a Plan

Payment Methods

Manage Your Plan

Automatic Renewal

Switch Plans

Cancellation

Refunds

Buy More Fast Hours

Account Information

### Stealth Mode

Stealth Mode

Midjourney is an open-by-default community, and all image generations are visible at midjourney.com, including images created in private discord servers, direct messages, and on the Midjourney web app.

Subscribers to the Pro and Mega plans have access to Stealth Mode. Stealth mode prevents your images from being visible to others on the Midjourney website. Use the `/stealth` and `/public` commands toggle between Stealth and Public mode.

Stealth Mode Only Prevents Others From Viewing Your Images on Midjourney.com!  
Images generated in public channels are always visible to other users, even when using Stealth Mode. To prevent others from seeing an image you create using Stealth Mode, generate images in your Direct Messages or on a private Discord server.

If you cancel or downgrade your Midjourney subscription, previously created Stealth Mode images will remain unpublished.

### How to Switch to Stealth Mode

Your website and Discord settings are separate. This includes your preference of Stealth or Public Mode. Double-check your Discord and website settings before generating any images to be sure they're set to the mode you want to use.

In Discord

Using Commands

Use the `/stealth` as a standalone command in Discord to turn Stealth Mode on. Use `/public` to turn it off.

Switching this way will apply your choice to all your future prompts until you use a different command to change modes, choose a different mode in your settings, or use the opposite parameter in your prompt.

Using Settings

Use the `/settings` command to adjust your settings. The `Public` button can be used to toggle between Stealth and Public mode.

When the `Public` button is green, you are making images in Public mode.

When the `Public` button is gray, you are making images in Stealth mode.

Using Parameters

To override your default visibility mode for a specific prompt, you can add the `--stealth` or `--public` parameter to the end.

Using `/info` to check if you are in Stealth Mode

Use the `/info` command to see information about your account. Visibility shows whether you are currently in Public or Stealth Mode.

On the Website

Website Settings

You can toggle Stealth Mode on and off in the website Settings menu:

A red `On` button means Stealth Mode is enabled. A gray `Off` button means Public Mode is enabled. Click the button to toggle between them.

Your choice will apply to all your prompts unless you use the opposite `--stealth` or `--public` parameter in an individual prompt.

Publishing and Unpublishing Existing Images

If your current subscription plan includes Stealth Mode, you can also publish or unpublish existing images on the website by using the bulk actions menu from your Archive page or the  Options menu from within an individual image view.



------

## Chapter 60: How to Switch to Stealth Mode

In Discord

Using Commands

On the Website

### Earn Free Hours

Earn Free Hours

Midjourney subscribers can earn free Fast time by ranking images and filling out surveys. A bonus Fast hour is awarded to the top 2000 ranking participants each day.

Awarded Fast hours expire 30 days from the date you earned.

You need an active subscription to earn and use free Fast hours.

### How to Rank Images

Every day, the 2000 Midjourney users who rank the most images earn a free Fast hour. There are four ways to rank images:

Curate Community Front Page

Choose the image from each set that you think most belongs on the front page of the Explore feed. These rankings don't affect your personalization.

Rank Image Aesthetics

Aesthetic rankings are based on personal preference. Choose the image you like the most based on its overall appearance, effort, colors, concept, or theme. Don't take the prompt into account.

Ranking Images Aesthetics also contributes to your Midjourney personalization.

Rank Niji Aesthetics

Niji Aesthetics ranking includes only images generated with the Niji models of Midjourney. Ranking Niji Aesthetics contributes your your Niji personalization, which applies to `--niji` images you generate with personalization turned on.

Rank Prompt Accurage

Choose the images from each pair that most accurately matches its prompt. These rankings don't affect your personalization.

### Surveys

Research surveys also appear on the Tasks tab. You'll be able to see how many Fast hours each survey awards for completion before you begin. You don't need an active Midjourney subscription to take these surveys and see your results, but you will only earn Fast time for completing them if you're an active subscriber.

### Keep Track of Your Free Hours

You can check how many earned and purchased Fast hours you have available in the Purchased & Awarded Fast Hours box on your Manage Subscription page. Hover your mouse over the  icon to see when these hours expire.

### There are two modes for image generation, Fast Mode and Relax Mode. Fast Mode tries to give you a GPU instantly. It's the highest-priority processing tier and uses your subscription's monthly GPU time. Relax Mode queues your generation behind others based on how much you've used the system. Relax Mode wait times are variable and usually range from 110 minutes

By default, your images will be generated using Fast mode. You can switch to Relax if you have a Standard or Pro subscription.



------

## Chapter 61: How to Rank Images

Surveys

Keep Track of Your Free Hours

### Fast, Relax, & Turbo Modes

Fast, Relax, & Turbo Modes

Midjourney uses powerful Graphics Processing Units (GPUs) to interpret and process each prompt. When you purchase a subscription to Midjourney, you are purchasing time on these GPUs.

Different subscription plans have different amounts of monthly GPU time.  
This monthly subscription GPU time is Fast Mode time. Fast Mode tries to give you access to a GPU instantly. It's the default processing tier and uses your subscription's monthly GPU time.

### How many GPU minutes do my generations cost?

The Average Job the Midjourney bot processes takes about one minute of GPU time to finish creating an image. Upscaling an image, using nonstandard aspect ratios, or older Midjourney Model Versions may take more time. Creating variations or using lower quality values will take less time.

A Job's time depends on the following factors:

\+ Lower Time++ Average Time+++ Higher Time  
Job TypeVariations`/imagine`Upscale  
Aspect Ratiodefault (square)tall or wide  
Quality Parameter`--q 0.25` or `--q 0.5`default (`--q 1`)`--q 2` (for legacy Model Versions)  
Stop Parameter`--stop 10``--stop 99`default (`--stop 100`)  
  
Use `/info` before and after running a process to see how many of your remaining GPU minutes the generation used.

### Fast vs. Relax Mode

Subscribers to the Standard, Pro, and Mega plans can create an unlimited number of images each month in Relax Mode. Relax Mode will not cost any GPU time, but Jobs will be placed into a queue based on how much you've used the system.

How long do I need to wait in Relax mode?

Jobs in Relax mode are placed in a queue to be processed as GPUs become available. Wait times for Relax are dynamic but generally range between 010 minutes per job. If you use Relax mode occasionally, you will have shorter wait times compared to subscribers that have used it more. This priority currently resets whenever you renew your monthly subscription.

Limitations

Permutation prompts, the --repeat parameter and the Legacy upscaler, Max Upscale are not available while useing Relax mode.

Run Out of Fast Time?

You can purchase more Fast Hours on your Midjourney.com/accounts page.

By default, images are generated using Fast Mode.  
Unused monthly Fast GPU time does not roll over.

### Turbo Mode

Turbo Mode is available for subscribers who want extremely quick image generation. Turbo mode uses a high-speed experimental GPU pool. Jobs run in Turbo mode generate up to four times faster but consume twice as many subscription GPU minutes as a typical Fast Mode Job.

Turbo mode is only available with Midjourney Model Versions 5, 5.1, 5.2, and 6.

If Turbo mode is selected, but the GPUs are unavailable, or it is incompatible with the selected model version, your job will run in Fast Mode instead.

Turbo Mode is an experimental feature, and availability and price may change at any time.

### How to Switch Between Modes

All users have access to Fast and Turbo Modes. Only Standard, Pro, and Mega Plan subscribers can use Relax Mode.

Your website and Discord settings are synced. This means that if you change your settings in one place, they'll automatically change in the other  including your generation speed. Double-check your settings to make sure they're set the way you want them before you generate images!

In Discord

Using Commands

Use `/relax`, `/fast`, or `/turbo` as a standalone command in Discord to switch between image generation speeds.

Switching this way will apply your choice to all your future prompts until you use a different command to change modes, choose a different mode in your settings, or use a different mode parameter in your prompt.

Using Settings

Use the `/settings` command and choose ` Relax` ` Fast` or ` Turbo` from the menu.

Using the `--relax` `--fast` or `--turbo` parameters

To override your default generation speed for a specific prompt, you can add the `--fast`, `--relax`, or `--turbo` parameter at the end.

Website Settings

You can choose between Stealth and Public modes as your default "Speed" with buttons in the website Settings menu:

Your current default Speed will be highlighted in red.

The Speed you set here will apply to all your prompts unless you specify a different one using the `--relax` or `--fast` or `--turbo` parameter in an individual prompt.

A Job is any action that uses the Midjourney Bot. Jobsinclude using `/imagine` to create an initial image grid, upscaling images, and creating variations of images.



------

## Chapter 62: How many GPU minutes do my generations cost?

Fast vs. Relax Mode

How long do I need to wait in Relax mode?

Limitations

Run Out of Fast Time?

Turbo Mode

How to Switch Between Modes

In Discord

Website Settings

### Contacting Support

Contacting Support

Most issues can be resolved without needing manual intervention. If you're still stuck, follow the instructions below to get help.

Self-Help

Use the `/ask` command to get answers to many common support questions.

### Tech Support and General Questions

We provide support directly within Discord if you have an issue with the Midjourney Bot or Midjourney.com website. You can find help in the `#support` channel, just above the newbies rooms. Volunteers and helpful community members run this channel and can't assist with billing issues.

Billing Support

Billing and Subscription Help

For billing and subscription questions, please visit help.midjourney.com.
</file>

<file path="docs/prompts_results.txt">
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 12345,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 67890,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "text": "\"Lost in translation\" neon sign in a Tokyo alleyway",
  "image_prompts": [],
  "stylize": 750,
  "chaos": 0,
  "weird": 250,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "text": "\"Made in Midjourney\" stamp on a vintage postage stamp",
  "image_prompts": [],
  "stylize": 1000,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 2,
  "aspect_ratio": "1:2",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "zoom": "1.5"
  }
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'raw', 'original', 'cute', 'expressive'} [type=value_error, input_value='default', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
{
  "error": "Missing value for parameter: video"
}======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "text": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 2,
  "aspect_height": 3,
  "aspect_ratio": "2:3",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "text": "A cat in a Tundra environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a Jungle environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a City environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "text": "A cyberpunk cat with a neon sign that says \"Midjourney\"",
  "image_prompts": [],
  "stylize": 500,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "text": "A pastel watercolor landscape with \"/imagine\" written in the clouds",
  "image_prompts": [],
  "stylize": 250,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 16,
  "aspect_height": 9,
  "aspect_ratio": "16:9",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'original', 'expressive', 'cute', 'scenic', 'raw'} [type=value_error, input_value='random-64', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image",
      "URL",
      "of",
      "classic",
      "butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "sad",
      "painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
{
  "error": "Invalid value for seed: random - Invalid numeric value: could not convert string to float: 'random'"
}======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "text": "A continuous line charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A loose gestural charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'cute', 'original', 'expressive', 'raw'} [type=value_error, input_value='random', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'original', 'expressive', 'scenic', 'raw'} [type=value_error, input_value='random-16', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'scenic', 'original', 'expressive', 'raw'} [type=value_error, input_value='random-128', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "text": "An impressionistic watercolor of a cat playing chess with a dog",
  "image_prompts": [],
  "stylize": 50,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 4,
  "aspect_height": 3,
  "aspect_ratio": "4:3",
  "style": "raw",
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": "board, pieces",
  "extra_params": {}
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "text": "cheese:: cake:: painting multi-prompt",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 60,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v4",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "negative": "weight fruit::-.5"
  }
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
{
  "error": "1 validation error for MidjourneyPrompt\nversion\n  Value error, Invalid version value. Must be one of: {'6', '5', '4', '3', '2', '1', '5.2', '5.0', '5.1', '6.1'} [type=value_error, input_value='vniji 5', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "error": "Missing value for parameter: remix"
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "medieval",
      "tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "medieval",
      "tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "medieval",
      "tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image",
      "URL",
      "of",
      "medieval",
      "tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "text": "stream running through a redwood forest",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "vary": "region",
    "selection": "sky area",
    "prompt": "aurora borealis",
    "pan": "up"
  }
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]
</file>

<file path="docs/prompts.sh">
cat ./prompts.txt | while read p; do
    echo "======"
    echo $p
    python -m midjargon mj "$p" -j
done
</file>

<file path="docs/refactoring-ideas.md">
# Future refactoring


## Gemini Flash Think

Hello, Im Claude 3 Haiku.

The current parser code in `midjargon` is structured into several modules, each handling a specific part of the prompt parsing process:

*   **`src/midjargon/core/input.py`**: Handles initial input and permutation expansion.
*   **`src/midjargon/core/permutations.py`**: Implements the logic for expanding permutation expressions `{option1, option2}`. It uses string manipulation and recursion to generate all combinations.
*   **`src/midjargon/core/parameters.py`**:  Parses parameters from the prompt string (e.g., `--ar 16:9 --stylize 100`). It handles parameter names, values, shorthand parameters, and some basic validation.
*   **`src/midjargon/core/parser.py`**:  The main parser that ties everything together. It splits the prompt into image URLs, text, and parameters, and then uses `parse_parameters` to handle the parameter string. It outputs a generic `MidjargonDict`.
*   **`src/midjargon/engines/midjourney/parser.py`**:  Takes the `MidjargonDict` and validates and transforms it into a `MidjourneyPrompt` Pydantic model. This is where Midjourney-specific logic and validation reside.
*   **`src/midjargon/engines/midjourney/models.py`**: Defines the Pydantic models (`ImagePrompt`, `MidjourneyPrompt`) that represent a validated Midjourney prompt.

**Analysis of the Current Code and Potential Issues:**

1.  **String Manipulation Heavy:** The permutation expansion and parameter parsing heavily rely on string manipulation (splitting, joining, iterating through characters). While functional, this can become less readable and potentially less efficient for very complex prompts with deep nesting and numerous permutations.

2.  **Iterative and Recursive Permutation Expansion:** The `expand_text` function in `permutations.py` appears to be iterative with recursion for nested permutations. While it works, a more purely iterative approach might be slightly easier to follow and potentially optimize.

3.  **Parameter Parsing Logic in `core` and `engine`:** Parameter parsing is split between `core/parameters.py` (basic parsing and shorthand expansion) and `engines/midjourney/parser.py` (Midjourney-specific validation and transformation). This separation is good for modularity, but it adds complexity to the overall flow.

4.  **Dictionary-based Intermediate Representation:**  `MidjargonDict` acts as an intermediate representation. While flexible, it is less type-safe than directly working with Pydantic models throughout the parsing process.

5.  **Error Handling with `SystemExit` in `test_parameters.py`**: Using `SystemExit` in tests is not ideal. Tests should ideally raise exceptions that can be caught and asserted within the testing framework. (This is a minor point, but good practice for testing).

**Alternative Python-based Methods for Cleaner and Efficient Parsing:**

To improve the code, we can consider the following approaches:

1.  **Leveraging Python's `ast` module for Permutation Parsing:** Instead of manual string parsing for permutations, we could explore using Python's `ast` (Abstract Syntax Tree) module to parse the permutation expressions. This might be overkill for simple `{}` syntax, but it could provide a more robust and potentially more efficient way to handle complex nested structures, if the syntax were to become more sophisticated in the future. For the current level of complexity, using a dedicated parser generator library might be more suitable if aiming for a more formal parsing approach.

2.  **Using Regular Expressions more effectively for Parameter Parsing:** While the current code uses string splitting, regular expressions could be used more strategically to parse parameters. This can make the parameter extraction and value separation more concise and potentially faster, especially when dealing with different parameter value formats (quoted strings, lists, etc.).

3.  **Directly working with Pydantic Models during Parsing:** Instead of creating a `MidjargonDict` and then converting to `MidjourneyPrompt`, we could aim to parse directly into the Pydantic models. This would improve type safety and potentially streamline the data flow, reducing intermediate data structures. We can still maintain modularity by having separate parsing functions for different parts of the prompt, but they would directly populate the model fields.

4.  **Iterative Permutation Expansion with Generators:**  For permutation expansion, we can use generators to yield each permutation variation one at a time. This can be more memory-efficient, especially for prompts that expand to a very large number of variations.

5.  **Data-Driven Parameter Validation:**  Instead of hardcoding validation rules in the `MidjourneyParser`, we could make the validation data-driven. We could define parameter types, ranges, and allowed values in a data structure (e.g., a dictionary or JSON file), and then use this data to dynamically validate the parameters. This would make it easier to extend and maintain the parser as new Midjourney parameters are introduced.

**Skeleton Code demonstrating some of these ideas (focusing on parameter parsing and direct model population):**

```python
import re
from typing import Dict, List, Optional

from pydantic import BaseModel, ValidationError

# Assume MidjourneyPrompt model is defined as in the original code

class CleanerMidjourneyParser:
    def parse_prompt(self, prompt_string: str) -> "MidjourneyPrompt":
        image_urls, text_and_params = self._split_image_urls_and_text(prompt_string)
        text, param_string = self._split_text_and_params(text_and_params)
        params = self._parse_parameters(param_string)

        try:
            return MidjourneyPrompt(text=text, image_prompts=image_urls, **params)
        except ValidationError as e:
            # Re-raise with more context if needed
            raise ValueError(f"Prompt validation error: {e}") from e


    def _split_image_urls_and_text(self, prompt_string: str) -> tuple[List["ImagePrompt"], str]:
        """Splits image URLs from the beginning of the prompt."""
        urls: List["ImagePrompt"] = []
        text_part = prompt_string.strip()
        url_pattern = re.compile(r"^https?://[^\s/$.?#].[^\s]*\.(jpg|jpeg|png|gif|webp)$", re.IGNORECASE)
        tokens = prompt_string.split() # Simple tokenization by space initially

        image_tokens = []
        remaining_tokens = []

        for token in tokens:
            if url_pattern.match(token):
                image_tokens.append(token)
            else:
                remaining_tokens.append(token)

        for url_str in image_tokens:
            urls.append(ImagePrompt(url=url_str)) # Directly create ImagePrompt model

        text_part = " ".join(remaining_tokens)
        return urls, text_part


    def _split_text_and_params(self, text_and_params: str) -> tuple[str, str]:
        """Splits text and parameter string."""
        parts = re.split(r'\s--(?=[^\s])', text_and_params, maxsplit=1) # Split at '--' preceded by whitespace or start of string, but only once
        text = parts[0].strip()
        param_string = parts[1] if len(parts) > 1 else ""
        return text, param_string


    def _parse_parameters(self, param_string: str) -> Dict[str, Optional[str]]:
        """Parses parameter string into a dictionary, directly for MidjourneyPrompt model."""
        params: Dict[str, Optional[str]] = {}
        if not param_string:
            return params

        # More robust regex for parameter parsing - example, needs refinement
        param_regex = re.compile(r'--(\w+)\s*([^\s--]+)?') # Captures parameter name and optional value
        for match in param_regex.finditer(param_string):
            name = match.group(1)
            value = match.group(2) # Can be None if flag parameter
            # Expand shorthand here if needed, or in model validation
            normalized_name = self._normalize_parameter_name(name) # Example normalization
            params[normalized_name] = value

        return params


    def _normalize_parameter_name(self, name: str) -> str:
        """Example: Normalize shorthand parameter names."""
        shorthand_map = {
            "s": "stylize",
            "c": "chaos",
            # ... more mappings
        }
        return shorthand_map.get(name, name)


# Example usage
parser = CleanerMidjourneyParser()
prompt_input = "https://example.com/image.jpg a serene landscape --ar 16:9 --stylize 100"
midjourney_prompt = parser.parse_prompt(prompt_input)
print(midjourney_prompt)
```

**Review, Analysis & Improvement of Skeleton Code:**

1.  **Regex for Parameter Splitting:** The `re.split(r'\s--(?=[^\s])', ...)` in `_split_text_and_params` attempts to split at `--` only when it's preceded by whitespace and followed by a non-whitespace character. This is a starting point but needs careful testing to ensure it handles various prompt formats correctly, including cases where `--` might be part of the text description (though less common in Midjourney prompts).  A more robust approach might involve iterating through the text and identifying parameter blocks based on `--` delimiters.

2.  **Parameter Value Extraction Regex (`_parse_parameters`):** The `param_regex = re.compile(r'--(\w+)\s*([^\s--]+)?')` is a basic example and likely needs improvement to handle:
    *   Quoted parameter values (e.g., `--style "raw photo"`).
    *   Comma-separated values (e.g., `--no trees,cars`).
    *   Parameters without values (flag parameters like `--tile`).
    *   Parameters where the value itself might contain dashes (though less common, needs consideration).
    *   Potentially, different separators between parameters (though space is standard).

3.  **Direct Model Population:** The skeleton aims to directly create `ImagePrompt` models in `_split_image_urls_and_text` and populate `MidjourneyPrompt` fields in `_parse_parameters`. This is a good direction for type safety.

4.  **Normalization Function (`_normalize_parameter_name`):**  The `_normalize_parameter_name` is a good idea to centralize shorthand expansion. This can be expanded to handle more complex normalization or even validation logic if needed.

5.  **Error Handling (ValidationError):**  Catching `ValidationError` from Pydantic is important for providing user-friendly error messages. The skeleton code includes a basic `try...except` block, which can be enhanced to provide more specific error messages based on the `e.errors()` output from Pydantic.

**Further Improvements and Considerations:**

*   **More Sophisticated Permutation Handling:** For cleaner permutation expansion, consider using a parser combinator library (like `parsy` or `lark`, although `lark` might be heavier for this task) or a dedicated string parsing library. This would make the permutation logic more declarative and potentially easier to maintain and extend. However, for the current complexity, a well-structured iterative or recursive function might still be sufficient and more performant than introducing a heavy parsing library.

*   **Data-Driven Parameter Validation:** Implement the data-driven validation approach. Create a data structure (e.g., a JSON or YAML file, or even Python dictionaries) that defines parameters, their types, valid ranges, allowed values, and shorthand mappings. Load this data and use it to dynamically validate and process parameters in `_parse_parameters` and the `MidjourneyPrompt` model validators. This makes the parser more configurable and easier to adapt to changes in Midjourney's parameter set.

*   **Generator for Permutations:**  Implement the permutation expansion as a generator function to improve memory efficiency, especially for large permutation sets.

*   **Comprehensive Testing:**  Develop a more extensive test suite to cover various prompt formats, parameter combinations, edge cases, and error conditions. This is crucial to ensure the robustness of the parser.

By incorporating these alternative methods and iteratively refining the code, the `midjargon` parser can become cleaner, more efficient, and more maintainable while remaining readable and Pythonic. The key is to balance readability and performance, choosing the right tools and techniques for each part of the parsing process.

## Claude Sonnet

Hello! I see you'd like me to analyze the parser code and suggest cleaner and more efficient Python-based methods. Let me help with that.

"Hello, I'm Claude 3.5 Sonnet"

Let me analyze the code structure and suggest some improvements. Here's my thinking:

1. Core Architecture Issues:
- The current parser uses a multi-stage approach that's somewhat complex
- There's tight coupling between the parser and parameter handling
- Error handling is scattered across multiple modules
- Type definitions could be more precise
- The permutation handling is overly complex

2. Main Areas for Improvement:
- Introduce a proper Parser interface using abstract base classes
- Use more dataclasses/Pydantic models for type safety
- Implement a proper tokenizer/lexer stage
- Better error handling with custom exceptions
- More efficient permutation handling

Let me create a skeleton of an improved architecture:

```python


from abc import ABC, abstractmethod
from dataclasses import dataclass
from enum import Enum, auto
from typing import Generic, Iterator, Optional, TypeVar, Union

# Custom exceptions for better error handling
class ParserError(Exception):
    """Base class for parser errors."""
    pass

class TokenizerError(ParserError):
    """Error during tokenization."""
    pass

class ValidationError(ParserError):
    """Error during validation."""
    pass

# Token types for lexical analysis
class TokenType(Enum):
    TEXT = auto()
    PARAMETER = auto()
    VALUE = auto()
    IMAGE_URL = auto()
    WEIGHT = auto()
    PERMUTATION_START = auto()
    PERMUTATION_END = auto()
    PERMUTATION_SEPARATOR = auto()

@dataclass
class Token:
    """Represents a token in the prompt string."""
    type: TokenType
    value: str
    position: int

class Tokenizer:
    """Converts prompt string into tokens."""
    
    def __init__(self, text: str):
        self.text = text
        self.pos = 0
        
    def tokenize(self) -> Iterator[Token]:
        """Generate tokens from input text."""
        while self.pos < len(self.text):
            # Skip whitespace
            if self.text[self.pos].isspace():
                self.pos += 1
                continue
                
            # Handle URLs
            if self.text[self.pos:].startswith(('http://', 'https://')):
                yield self._tokenize_url()
                continue
                
            # Handle parameters
            if self.text[self.pos:].startswith('--'):
                yield self._tokenize_parameter()
                continue
                
            # Handle permutations
            if self.text[self.pos] == '{':
                yield Token(TokenType.PERMUTATION_START, '{', self.pos)
                self.pos += 1
                continue
                
            # Handle weights
            if self.text[self.pos:].startswith('::'):
                yield self._tokenize_weight()
                continue
                
            # Handle regular text
            yield self._tokenize_text()

T = TypeVar('T')

class Parser(ABC, Generic[T]):
    """Abstract base class for prompt parsers."""
    
    @abstractmethod
    def parse(self, text: str) -> T:
        """Parse prompt text into structured format."""
        pass
    
    @abstractmethod
    def validate(self, result: T) -> bool:
        """Validate parsed result."""
        pass

@dataclass
class Parameter:
    """Represents a parsed parameter."""
    name: str
    value: Optional[Union[str, int, float]] = None

@dataclass
class PromptComponent:
    """Base class for prompt components."""
    text: str

@dataclass
class ImagePrompt(PromptComponent):
    """Represents an image reference in the prompt."""
    url: str

@dataclass
class WeightedPrompt(PromptComponent):
    """Represents a weighted prompt component."""
    weight: float

@dataclass
class ParsedPrompt:
    """Represents a fully parsed prompt."""
    components: list[PromptComponent]
    parameters: dict[str, Parameter]

class PromptParser(Parser[ParsedPrompt]):
    """Main prompt parser implementation."""
    
    def __init__(self):
        self.tokenizer = None
        
    def parse(self, text: str) -> ParsedPrompt:
        """Parse prompt text into structured format."""
        self.tokenizer = Tokenizer(text)
        tokens = list(self.tokenizer.tokenize())
        
        # First pass: group tokens into logical components
        components = self._group_components(tokens)
        
        # Second pass: handle permutations
        expanded = self._expand_permutations(components)
        
        # Third pass: extract and validate parameters
        params = self._extract_parameters(expanded)
        
        result = ParsedPrompt(components=expanded, parameters=params)
        self.validate(result)
        return result
    
    def validate(self, result: ParsedPrompt) -> bool:
        """Validate parsed result."""
        # Implement validation logic
        return True
    
    def _group_components(self, tokens: list[Token]) -> list[PromptComponent]:
        """Group tokens into logical components."""
        components = []
        current_tokens = []
        
        for token in tokens:
            if token.type in (TokenType.TEXT, TokenType.PERMUTATION_START, 
                            TokenType.PERMUTATION_END, TokenType.PERMUTATION_SEPARATOR):
                current_tokens.append(token)
            elif token.type == TokenType.IMAGE_URL:
                if current_tokens:
                    components.append(self._create_text_component(current_tokens))
                    current_tokens = []
                components.append(ImagePrompt(token.value))
            elif token.type == TokenType.WEIGHT:
                if current_tokens:
                    text = self._create_text_component(current_tokens)
                    components.append(WeightedPrompt(text, float(token.value)))
                    current_tokens = []
        
        if current_tokens:
            components.append(self._create_text_component(current_tokens))
            
        return components
    
    def _expand_permutations(self, components: list[PromptComponent]) -> list[PromptComponent]:
        """Handle permutation expansion."""
        # Implement permutation logic
        return components
    
    def _extract_parameters(self, components: list[PromptComponent]) -> dict[str, Parameter]:
        """Extract and validate parameters."""
        # Implement parameter extraction
        return {}
    
    def _create_text_component(self, tokens: list[Token]) -> str:
        """Create text component from tokens."""
        return ' '.join(t.value for t in tokens)

# Example usage:
def parse_prompt(text: str) -> ParsedPrompt:
    """Parse a prompt string."""
    parser = PromptParser()
    try:
        return parser.parse(text)
    except ParserError as e:
        # Handle parsing errors
        raise


```

Key improvements in this design:

1. Clear Separation of Concerns:
- Tokenizer handles lexical analysis
- Parser focuses on structural analysis
- Clear interfaces between components
- Type-safe data structures

2. Better Error Handling:
- Custom exception hierarchy
- Specific error types for different stages
- Better error context and reporting

3. More Efficient Permutation Handling:
- Token-based approach avoids string manipulation
- Single-pass permutation expansion
- Memory-efficient iterator patterns

4. Improved Type Safety:
- Use of dataclasses and type hints
- Generic parser interface
- Clear data structures for components

5. More Maintainable:
- Clear abstraction boundaries
- Easier to test individual components
- More extensible for new features

Would you like me to explain any particular aspect in more detail or focus on specific improvements?

## o1

Hello, Im ChatGPT v4.0

Below is an outline of a more streamlined approach to parsing and validating these Midjourney-like prompts. Ill first give a **high-level overview** of the idea, then **show a skeleton**, then **review and refine** the approach.

---

### 1. High-Level Overview

1. **Separate Concerns Clearly**:  
   - **Permutation Expansion**: Expand `{red, blue}` blocks first (into multiple prompt strings).  
   - **URL/Image Extraction**: Capture all image-like tokens at the start (or anywhere you choose) into a list.  
   - **Parameter Extraction**: Gather all `--param value` pairs.  
   - **Prompt Text**: Whatever remains after images and parameters is the text.

2. **Rely on Declarative Structures** (e.g., Python dataclasses or Pydantic models) to:
   - Convert the extracted data into typed fields (for example, `ar`  `(width, height)`).
   - Validate ranges or enumerations (`--v 5`, `--niji 6`).

3. **Use Python Built-ins**:
   - **Split** or **regex** for scanning parameters.
   - **`shlex`** module or something similar to handle shell-like tokens (optional).
   - **`dataclasses.replace`** or Pydantics `.copy(update=...)` for reusing partial parse results if needed.

4. **Minimize Passing Large Dictionaries** around. Instead:
   - Convert extracted data directly into structured objects.
   - This reduces the risk of mystery keys floating around at each step.

---

### 2. Skeleton Code (Conceptual)

Below is some simplified, *illustrative* Python code that shows how you might unify these steps in a clearer manner. It is **not** a full implementationrather, a scaffold to show a different architectural approach.

```python
from dataclasses import dataclass, field
from typing import List, Optional, Dict

@dataclass
class MidjargonParameters:
    """Holds parameters from the command line, with defaults and validations."""
    aspect_width: int = 1
    aspect_height: int = 1
    stylize: int = 100
    chaos: int = 0
    weird: int = 0
    seed: Optional[int] = None
    version: Optional[str] = None
    # etc... more fields here
    
    extra_params: Dict[str, str] = field(default_factory=dict)

@dataclass
class MidjargonPrompt:
    """Represents a fully expanded prompt."""
    images: List[str] = field(default_factory=list)
    text: str = ""
    params: MidjargonParameters = field(default_factory=MidjargonParameters)

def parse_prompt(raw_prompt: str) -> MidjargonPrompt:
    """
    Parse a single prompt string (already expanded, no `{...}` blocks) into
    images, text, and parameters. Return a MidjargonPrompt object.
    """
    tokens = raw_prompt.strip().split()
    images = []
    # 1) Gather images from the start (or until a non-image token)
    idx = 0
    while idx < len(tokens) and looks_like_image_url(tokens[idx]):
        images.append(tokens[idx])
        idx += 1
    
    # 2) The remainder might have text and parameters; let's find parameters by scanning for `--`
    text_chunks = []
    param_pairs = []
    
    current_idx = idx
    while current_idx < len(tokens):
        if tokens[current_idx].startswith('--'):
            # Found a parameter
            param_name = tokens[current_idx][2:]  # remove --
            # If next token does NOT start with --, treat it as the value
            if current_idx + 1 < len(tokens) and not tokens[current_idx + 1].startswith('--'):
                param_value = tokens[current_idx + 1]
                current_idx += 2
            else:
                param_value = None
                current_idx += 1
            
            param_pairs.append((param_name, param_value))
        else:
            text_chunks.append(tokens[current_idx])
            current_idx += 1
    
    text_str = " ".join(text_chunks)
    
    # 3) Convert param_pairs into a MidjargonParameters object
    params_obj = build_parameters(param_pairs)
    
    # 4) Return a completed MidjargonPrompt
    return MidjargonPrompt(images=images, text=text_str, params=params_obj)

def build_parameters(param_pairs: List[tuple]) -> MidjargonParameters:
    """
    Convert param pairs into typed fields on MidjargonParameters.
    If a param doesnt map to a known field, store it in `extra_params`.
    """
    result = MidjargonParameters()
    
    for name, value in param_pairs:
        name_lower = name.strip().lower()
        
        if name_lower in ("ar", "aspect") and value:
            # parse aspect ratio
            w, h = value.split(":")
            result.aspect_width = int(w)
            result.aspect_height = int(h)
        
        elif name_lower in ("s", "stylize") and value:
            result.stylize = int(value)
        
        elif name_lower in ("c", "chaos") and value:
            result.chaos = int(value)
        
        elif name_lower in ("v", "version") and value:
            result.version = f"v{value}"
        
        else:
            # unrecognized param => put in extra_params
            result.extra_params[name_lower] = str(value) if value else None
    
    # Run any final validations (range checks, etc.)
    _validate_params(result)
    
    return result

def _validate_params(params: MidjargonParameters):
    if not (0 <= params.chaos <= 100):
        raise ValueError(f"Chaos out of range: {params.chaos}")
    if params.stylize < 0 or params.stylize > 1000:
        raise ValueError(f"Stylize out of range: {params.stylize}")
    # etc. for each param

def looks_like_image_url(token: str) -> bool:
    # Check if token ends with .jpg, .png, etc. or matches a URL pattern
    lower = token.lower()
    return any(lower.endswith(ext) for ext in (".jpg", ".jpeg", ".png", ".gif", ".webp"))
```

#### Explanation

1. **`parse_prompt`**: Splits the raw prompt into tokens, extracts image URLs, text, and parameters in a single pass.  
2. **`build_parameters`**: Converts `(name, value)` pairs into the correct fields in a `MidjargonParameters` dataclass.  
3. **`_validate_params`**: Houses numeric range validations in a separate function, making the main logic cleaner.  
4. **`looks_like_image_url`**: A small helper to decide if a token is an image URL.  

---

### 3. Review & Analysis

- **Pros**:
  - **Readability**: Each function has a single, clear responsibility.  
  - **Less Indirection**: We move from raw tokens  typed fields in fewer steps.  
  - **Easier Maintenance**: Using dataclasses ensures clarity about what parameters exist, plus default values.  
  - **Testing**: The flow is straightforward to test with unit tests for each function.

- **Potential Gaps**:
  - Were only handling a single prompt with no `{...}` permutations in `parse_prompt`. Wed want a separate function to do permutations first and generate multiple calls to `parse_prompt`.  
  - We assume a simplistic image at start rule. If your real code allows images in the middle, youd need a different approach.  
  - No advanced tokenization (e.g., handling quoted strings with spaces). A real-world approach might require `shlex` or a small parser.  

#### Possible Improvements

1. **Handle Quoted Values**: Use `shlex.split` or a regular expression to robustly handle values containing spaces or special characters.  
2. **Better URL Checking**: Use a library or a more thorough regex if needed.  
3. **Advanced Validation**: If parameters have complex constraints or cross-dependencies, integrate a Pydantic model with custom validators.  
4. **Permutation Support**: Create a small function (like `expand_permutations(raw_prompt: str) -> List[str]`) to handle the curly-brace expansions before passing each final string to `parse_prompt`.

---

### Summary

This skeleton shows that you can *separate each phase* (permutation expansion, tokenization, param-building, and validation) into smaller, dedicated functions. Using a `dataclass` (or Pydantic) for the parameters leads to more readable code with fewer deeply nested conditionals. Each step remains **transparent** and **testable**keeping everything clean and efficient, yet still readable.

## Gemini Pro

Hello, Im GPT-4,

Here's a detailed breakdown of my thinking, the proposed alternative implementation, its review, analysis, and iterative improvement:

**Core Issues and Objectives**

The existing code relies heavily on string manipulation, regular expressions, and manual parsing logic, particularly in `src/midjargon/core/parser.py`, `src/midjargon/core/parameters.py` and  `src/midjargon/core/permutations.py`, and the engine-specific implementations (`src/midjargon/engines/midjourney/*`). This approach can become complex, error-prone, and difficult to maintain as the prompt syntax evolves.  The goal is to create a more robust, readable, and maintainable solution using Python's strengths.

The interplay between models is also a bit convoluted. `parse_midjargon_prompt_to_dict` produces a flat dictionary, which the engine-specific parser then has to re-interpret. This two-stage process is less efficient than a direct, type-safe parsing into the final model.

**Proposed Approach:  Leverage Pydantic and a Recursive Descent Parser**

The cleaner and more efficient approach involves two main components:

1.  **Pydantic Models for Structure:** Define Pydantic models to represent the structure of a Midjourney prompt *directly*. This leverages Pydantic's built-in validation and type handling, avoiding manual checks and conversions.  We already use Pydantic, but the structure could be much improved.
2.  **Recursive Descent Parser:** Implement a recursive descent parser, which is a top-down parsing technique well-suited for context-free grammars (like the Midjargon prompt syntax).  This offers much better structure and readability compared to the current iterative approach.

This approach eliminates the need for the intermediate `MidjargonDict` and the two-stage parsing process, streamlining the entire flow.

**Skeleton Code (Illustrative)**

First, let's refactor the Pydantic models. This is crucial. Instead of a flat `MidjourneyPrompt`, we'll create a hierarchy of models that represent the prompt's grammar.

```python
# src/midjargon/engines/midjourney/models.py
from pydantic import BaseModel, Field, field_validator, model_validator
from typing import List, Union, Optional, Literal

# --- Parameter Models ---
class AspectRatio(BaseModel):
    width: int
    height: int

    @field_validator("width", "height")
    @classmethod
    def positive(cls, v):
        if v <= 0:
            raise ValueError("Must be positive")
        return v
    def __str__(self):
        return f"{self.width}:{self.height}"

class NumericParameter(BaseModel):
    value: int | float

class Stylize(NumericParameter):
    value: int = Field(default=100, ge=0, le=1000)

class Chaos(NumericParameter):
    value: int = Field(default=0, ge=0, le=100)

class Weird(NumericParameter):
    value: int = Field(default=0, ge=0, le=3000)

class ImageWeight(NumericParameter):
    value: float = Field(default=1.0, ge=0.0, le=3.0)

class Seed(NumericParameter):
    value: int = Field(default=None, ge=0, le=4294967295)

class Stop(NumericParameter):
    value: int = Field(default=100, ge=10, le=100)
  
class Quality(NumericParameter):
    value: float = Field(default=1.0, ge=0.1, le=2.0)

class StyleWeight(NumericParameter):
    value: int = Field(default=None, ge=0, le=2000)

class CharacterWeight(NumericParameter):
      value: int = Field(default=100, ge=0, le=200)
    
class StyleVersion(NumericParameter):
      value: int = Field(default=2, ge=1, le=10)
    
class Repeat(NumericParameter):
      value: int = Field(default=None, ge=1, le=100)


class Version(BaseModel):
    version: str
    @field_validator('version')
    def validate_version(cls, v):
        if v.startswith("niji"):
          parts = v.split()
          if len(parts) == 1:  # Just "niji"
              return v
          version = parts[-1]
          if version not in {"4", "5", "6"}:
              raise ValueError(f"Invalid niji version. Must be one of: 4, 5, 6")
          return v
        else: 
          version = v.lstrip("v")
          if version not in {"1","2","3","4","5","5.0", "5.1", "5.2","6", "6.1"}:
            raise ValueError("Version must be one of: 1, 2, 3, 4, 5, 5.0, 5.1, 5.2, 6, 6.1")
          return v

class Style(BaseModel):
    style: Literal["raw", "expressive", "cute", "scenic", "original"]


class FlagParameter(BaseModel):
    flag: bool = Field(default=False)

class Tile(FlagParameter):
    pass

class Turbo(FlagParameter):
    pass

class Relax(FlagParameter):
    pass

class ImagePrompt(BaseModel):
    url: str

class WeightedPrompt(BaseModel):
    prompt: 'PromptPart'  # Forward reference
    weight: float = 1.0

class Permutation(BaseModel):
  options: List['PromptPart']

class TextPrompt(BaseModel):
    text: str

PromptPart = Union[TextPrompt, WeightedPrompt, Permutation, ImagePrompt]

class Parameter(BaseModel):
    name: str
    value: Optional[Union[str, int, float, bool, AspectRatio, Version, Style]] = None

class MidjourneyPrompt(BaseModel):
    prompt_parts: List[PromptPart] = Field(default_factory=list)
    parameters: List[Parameter] = Field(default_factory=list)

```

Now, the parser skeleton:

```python
# src/midjargon/engines/midjourney/parser.py

from typing import List, Optional, Union
from .models import *  # Import the refactored models

class MidjourneyParser:

    def __init__(self, prompt_string: str):
        self.prompt_string = prompt_string
        self.tokens = self.tokenize(prompt_string)
        self.index = 0

    def tokenize(self, prompt_string: str) -> List[str]:
      # Better tokenization
      #Splits by spaces, but also keeps :: together and -- together
      return re.findall(r'\S*::\S*|\S*--\S*|\S+', prompt_string)


    def parse(self) -> MidjourneyPrompt:
        prompt_parts = self.parse_prompt_parts()
        parameters = self.parse_parameters()
        return MidjourneyPrompt(prompt_parts=prompt_parts, parameters=parameters)

    def parse_prompt_parts(self) -> List[PromptPart]:
        parts = []
        while self.index < len(self.tokens) and not self.current_token().startswith('--'):
            parts.append(self.parse_prompt_part())
        return parts

    def parse_prompt_part(self) -> PromptPart:
        if self.current_token().startswith("http"):
            return self.parse_image_prompt()
        elif self.current_token().endswith("::"):
            return self.parse_weighted_prompt()
        elif self.current_token() == '{':
          return self.parse_permutation()
        else:
            return self.parse_text_prompt()

    def parse_image_prompt(self) -> ImagePrompt:
        url = self.consume()
        return ImagePrompt(url=url)

    def parse_weighted_prompt(self) -> WeightedPrompt:
      prompt_text = self.consume()
      # Remove the ::
      prompt_text = prompt_text[:-2]
      
      # Check if there is a weight
      weight = 1.0
      if self.index < len(self.tokens) and self.is_number(self.current_token()):
          try:
              weight = float(self.consume())
          except ValueError:
              pass # default

      prompt_part_model = TextPrompt(text=prompt_text) #Simplifies later recursion.
      return WeightedPrompt(prompt=prompt_part_model, weight=weight)


    def parse_permutation(self) -> Permutation:
      self.consume() # Consume the {
      options = []

      while self.index < len(self.tokens) and self.current_token() != '}':
        options.append(self.parse_prompt_part())
        if self.current_token() == ',':
            self.consume()  # Consume the comma

      self.consume()  # Consume the }
      return Permutation(options = options)
    

    def parse_text_prompt(self) -> TextPrompt:
        text = self.consume()
        return TextPrompt(text=text)


    def parse_parameters(self) -> List[Parameter]:
        parameters = []
        while self.index < len(self.tokens) and self.current_token().startswith('--'):
            parameters.append(self.parse_parameter())
        return parameters

    def parse_parameter(self) -> Parameter:
      name = self.consume()[2:]  # Remove --
      value = None

      if self.index < len(self.tokens) and not self.current_token().startswith('--'):
        if name == "ar":
          value = self.parse_aspect_ratio()
        elif name == "v" or name == "version" or name == 'niji':
          value = self.parse_version()
        elif name == 'style':
          value = self.parse_style()
        elif self.is_numeric_parameter(name):
            value = self.parse_numeric_parameter(name)
        else:
          value = self.consume()  # Simple string value

      #Create instances of specialized models for validation
      if name == "stylize" or name == 's':
          param_model = Stylize(value=int(value))
      elif name == "chaos" or name == "c":
          param_model = Chaos(value=int(value))
      elif name == "weird" or name == "w":
          param_model = Weird(value=int(value))
      elif name == "iw" or name == "image_weight":
          param_model = ImageWeight(value=float(value))
      elif name == "seed":
          param_model = Seed(value=int(value))
      elif name == "stop":
          param_model = Stop(value=int(value))
      elif name == "q" or name == 'quality':
        param_model = Quality(value=float(value))
      elif name == 'cw' or name == 'character_weight':
        param_model = CharacterWeight(value = int(value))
      elif name == 'sw' or name == 'style_weight':
        param_model = StyleWeight(value= int(value))
      elif name == 'sv' or name == 'style_version':
        param_model = StyleVersion(value = int(value))
      elif name == 'r' or name == 'repeat':
        param_model = Repeat(value = int(value))
      elif name == 'tile':
        param_model = Tile()
        value = True
      elif name == 'turbo':
        param_model = Turbo()
        value = True
      elif name == 'relax':
        param_model = Relax()
        value = True
      else:
        param_model = Parameter(name=name, value=value) #Create a generic parameter

      return param_model


    def parse_aspect_ratio(self) -> AspectRatio:
        value = self.consume()
        try:
            width, height = map(int, value.split(':'))
            return AspectRatio(width=width, height=height)
        except ValueError:
            raise ValueError(f"Invalid aspect ratio: {value}")

    def parse_version(self) -> Version:
      value = self.consume()
      return Version(version=value)
    
    def parse_style(self)-> Style:
      value = self.consume()
      return Style(style=value)

    def is_numeric_parameter(self, name: str) -> bool:
        numeric_params = {
            "stylize", "s", "chaos", "c", "weird", "w",
            "iw", "image_weight", "seed", "stop",
            "q", "quality", "cw", "character_weight",
            "sw", "style_weight", "sv", "style_version",
            "r", "repeat"
        }
        return name in numeric_params
    
    def parse_numeric_parameter(self, name:str)-> Union[int, float]:
      value = self.consume()
      return value

    def current_token(self) -> Optional[str]:
        if self.index < len(self.tokens):
            return self.tokens[self.index]
        return None

    def consume(self) -> str:
        token = self.current_token()
        if token is not None:
            self.index += 1
        else:
          raise ValueError("Unexpected end of input")
        return token
    
    def is_number(self, token: str) -> bool:
      try:
          float(token)
          return True
      except ValueError:
          return False

# Example Usage (for demonstration)
parser = MidjourneyParser("a cat on a mat --ar 16:9 --stylize 200")
parsed_prompt = parser.parse()
print(parsed_prompt.model_dump_json(indent=2))

parser = MidjourneyParser("{a, the} cat {sitting, sleeping}::2 on a mat --v 6")
parsed_prompt = parser.parse()
print(parsed_prompt.model_dump_json(indent=2))
```

**Review, Analysis, and Improvement**

1.  **Clarity and Readability:** The code is significantly clearer.  The Pydantic models define the expected structure, and the recursive descent parser follows the grammar logically.  Each parsing function (`parse_prompt_part`, `parse_parameter`, etc.) has a specific responsibility.

2.  **Maintainability:** Adding new parameters or prompt features becomes much easier.  You'd add a new field to the appropriate Pydantic model and a corresponding `parse_...` method in the parser.

3.  **Robustness:** Pydantic handles type validation and range constraints automatically.  The parser structure itself makes it less likely to miss edge cases.

4.  **Efficiency:** While a full implementation is needed for precise benchmarking, this approach is likely to be more efficient.  It avoids repeated string splitting and dictionary lookups.  The direct parsing into the final model eliminates the intermediate dictionary stage.

5.  **Type Safety:** The entire process is now type-safe, thanks to Pydantic and the parser's structure.

**Iterative Improvements (Beyond the Skeleton)**

*   **Error Handling:** The skeleton code includes basic error handling (e.g., `ValueError` for invalid aspect ratios), but this should be expanded.  The parser should provide informative error messages, indicating the location and nature of the parsing error.  A custom exception hierarchy could be beneficial.

*   **Tokenization:** The `tokenize` function needs improvement. Instead of a simple `split()`, it should handle:
    *   Keeping `--` and `::` together.
    *   Handling quoted strings (for parameters like `--style "raw photo"`).
    *    Correctly splitting around commas and curly braces, except when escaped.
    * Use of RegEx here can be optimized

*  **Permutations as a separate concern**: The `expand_midjargon_input` function should still exist, and use the `expand_text` function. But it should happen *before* parsing. The parser should not handle permutations.

*   **Parameter Value Parsing:** The `parse_parameter` method needs to handle the different parameter types (numeric, string, version, style, etc.) more robustly.  It can use a dictionary to map parameter names to parsing functions.

*   **Complete Grammar Coverage:**  The skeleton doesn't cover *all* aspects of the Midjourney prompt syntax (e.g., multi-prompts with `::`). The parser needs to be extended to handle these features.

*  **Testing:** The test suite should be expanded considerably to cover all the new parsing logic and error cases.

* **Abstract Base Class for Engines.** The `EngineParser` should have a `parse_string` method, instead of relying only on `parse_dict`.

This detailed response provides a strong foundation for building a much-improved prompt parser. It addresses the core issues, outlines a robust approach, and highlights areas for further refinement. The key improvements are leveraging Pydantic for data modeling and validation, and using a recursive descent parser for structured and readable parsing logic.

## r1

<think>
Okay, I need to analyze the provided parser code and think about alternative Python-based methods that are cleaner and more efficient while still being readable. Let me start by understanding the existing code structure and functionality.

Looking at the files, the core parsing seems to be in src/midjargon/core/parser.py and src/midjargon/engines/midjourney/parser.py. The parser takes a prompt string, handles permutations, extracts parameters, and validates them using Pydantic models. The current approach uses regex and manual splitting for parsing parameters and text, and it handles permutations with nested braces and escaped characters.

Possible areas for improvement:

1. **Parameter Parsing**: The parameters are parsed using a series of splits and regex checks. Maybe using a structured approach with a state machine or a more declarative parser could make it cleaner.

2. **Handling Permutations**: The permutation expansion code in permutations.py uses loops and manual string manipulation. Maybe using itertools.product for generating combinations could simplify the code.

3. **Image URL Extraction**: The image URLs are extracted by splitting the list of tokens. Using a regex to find all URLs at the start might be more efficient.

4. **Use of Pydantic Models**: The current models in midjourney/models.py have validators. Perhaps leveraging Pydantic's built-in validation more could reduce custom code.

Alternative Approaches:

- **Using a Parser Combinator**: Libraries like `parsy` or `pyparsing` can make the parsing code more declarative and easier to maintain.
- **Refactoring Permutation Handling**: Replace manual expansion with itertools.product and recursive functions for nested permutations.
- **Improve Parameter Handling**: Use a structured parser for parameters that can handle different types (flags, values) without manual state tracking.

Let me sketch skeleton code for a possible cleaner approach:

1. **Parsing Parameters with Parsy**:
   Define parsers for parameters, which can handle flags and key-value pairs more cleanly.

```python
import parsy as P

# Define parsers
parameter = (
    P.string('--') >> 
    P.regex(r'[a-zA-Z0-9_-]+').map(str.strip)  # parameter name
    << P.whitespace.optional()
)
value = P.regex(r'[^ ]+')  # simple value, can be extended for quoted values

param_parser = (
    parameter.bind(lambda name: 
        (value | P.produce(None)).map(lambda v: (name, v)))
    .sep_by(P.whitespace)
)
```

2. **Handling Permutations with itertools**:
   Use recursive parsing of permutation groups and generate product combinations.

```python
from itertools import product

def parse_permutation(text):
    # Sample implementation to split options, handling nesting and escapes
    # This would need to handle nested braces and escaped commas
    options = split_options(text)
    return options

def expand_permutations(prompt):
    # Split the prompt into parts and expand each permutation group
    # recursively, then generate all combinations
    parts = re.split(r'({|})', prompt)
    # ... process parts and build a list of possible segments
    # then use product to combine them
    return [''.join(combo) for combo in product(*segments)]
```

3. **Refactoring Image URL Extraction**:
   Use a regex to find all leading URLs.

```python
import re

url_pattern = re.compile(r'^https?://\S+\.(?:jpg|jpeg|png|gif|webp)\b', re.IGNORECASE)

def extract_urls(prompt):
    urls = []
    tokens = prompt.split()
    for token in tokens:
        if url_pattern.match(token):
            urls.append(token)
        else:
            break
    return urls, ' '.join(tokens[len(urls):])
```

4. **Simplifying the Pydantic Models**:
   Use Pydantic's field validators and custom types to handle parameter validation, reducing the need for manual checks.

```python
from pydantic import BaseModel, field_validator

class MidjourneyParams(BaseModel):
    ar: Optional[str] = None
    stylize: Optional[int] = None

    @field_validator('ar')
    def validate_ar(cls, v):
        if v and ':' not in v:
            raise ValueError("Aspect ratio must be in width:height format")
        return v
```

Review and Analysis:

- **Current Approach**: The existing code manually splits strings and uses loops for parsing, which can be error-prone and hard to maintain. For example, the parameter parsing in core/parameters.py splits on spaces and handles quoted values manually, which might not cover all edge cases.

- **Proposed Improvements**:
  - **Parser Combinators**: Using a library like `parsy` makes the parsing logic more declarative, reducing the need for complex state management.
  - **itertools for Permutations**: Leveraging itertools.product can simplify generating permutations and reduce the risk of bugs in nested cases.
  - **Regex for URLs**: A single regex can extract all leading image URLs more efficiently than splitting and checking each token.

- **Potential Issues**:
  - **Performance**: Parser combinators might have a performance cost for very long prompts. However, given that prompts are typically not excessively long, this is acceptable.
  - **Learning Curve**: Introducing a new library (like `parsy`) might require some learning, but it improves code readability.

- **Further Optimizations**:
  - **Memoization**: For permutation expansion, caching parts that don't change could speed up processing.
  - **Precompiled Regex**: Using precompiled regex patterns for URL detection and parameter splitting.

Improved Skeleton Code:

```python
# New parser using parsy for parameters
import parsy as P

# Define parsers
whitespace = P.regex(r'\s+')
param_name = P.regex(r'[a-zA-Z0-9_-]+')
param_value = P.regex(r'(?:[^ \n"]|"(?:\\"|[^"])*")+')  # Handle quoted values

parameter = (
    P.string('--') >> param_name
    .bind(lambda name: 
        (whitespace >> param_value.map(lambda v: (name, v))) | P.success((name, None))
    )
)

def parse_parameters(param_str):
    return parameter.sep_by(whitespace).parse(param_str.strip()).to_dict()


# Handling permutations with recursive splitting
def expand_permutations(text):
    stack = []
    current = ['']
    i = 0
    while i < len(text):
        if text[i] == '{':
            # Start new permutation group
            stack.append(current)
            current = ['']
            i += 1
        elif text[i] == '}' and stack:
            # End current group, combine with previous
            group = current
            prev = stack.pop()
            options = [g for g in group if g]
            current = []
            for p in prev:
                for o in options:
                    current.append(p + o)
            i += 1
        elif text[i] == '\\' and i +1 < len(text):
            # Escaped character
            current = [c + text[i+1] for c in current]
            i +=2
        else:
            # Add character to all current parts
            current = [c + text[i] for c in current]
            i +=1
    return current


# Example usage
print(expand_permutations("a {red, blue} bird"))  # ['a red bird', 'a blue bird']
print(expand_permutations("a {b{c,d},e}f"))    # ['a bcf', 'a bdf', 'a ef']

# URL extraction with regex
import re

url_re = re.compile(r'^(https?://\S+\.(?:jpe?g|png|gif|webp)\b)', re.IGNORECASE)

def split_urls_and_text(prompt):
    urls = []
    rest = []
    for token in prompt.strip().split():
        if url_re.match(token):
            urls.append(token)
        else:
            rest.append(token)
    text = ' '.join(rest)
    return urls, text

# Integrating into the parser
class MidjargonParser:
    def parse(self, prompt):
        # Step 1: Expand permutations
        expanded = expand_permutations(prompt)
        # Step 2: For each variant, split into images, text, params
        variants = []
        for variant in expanded:
            urls, rest = split_urls_and_text(variant)
            text_part, param_str = split_text_and_params(rest)
            params = parse_parameters(param_str)
            variants.append({'images': urls, 'text': text_part, **params})
        return variants

# This approach uses a more structured way to handle each part of parsing.
```

Analysis of Improvements:

- **Readability**: The use of parser combinators and itertools makes the code more declarative. Each part of the parsing process is separated into functions with clear responsibilities.

- **Efficiency**: The regex-based URL extraction and itertools.product for permutations should be more efficient than manual loops and splits.

- **Maintainability**: By breaking down the parser into smaller, testable components, the code becomes easier to debug and extend. For example, the `parse_parameters` function is isolated and can be tested independently.

Potential Further Refinements:

- **Error Handling**: Adding better error messages and handling edge cases, such as unmatched braces or incorrect parameter formats.

- **Performance Testing**: Profiling the new implementation to ensure it handles large prompts efficiently.

- **Integration with Pydantic**: Leveraging Pydantic's model parsing to automatically convert parameters to the correct types, reducing manual validation code.

In conclusion, restructuring the parser with a focus on declarative parsing libraries and Python's built-in utilities can lead to cleaner, more maintainable code while maintaining or improving efficiency.
</think>

Hello, Im GPT-4.

Here's my analysis and suggested improvements for the Midjargon parser system:

1. **Core Issues in Current Implementation**
- Complex state management in permutation parsing
- Fragmented parameter handling across multiple modules
- Overly nested validation logic
- Mix of string manipulation approaches

2. **Proposed Architectural Changes**
- Use parser combinators for structured parsing
- Separate tokenization from interpretation
- Use immutability for parser state
- Leverage Python's itertools for permutation expansion

```python
# Skeleton for next-gen parser using parser combinators
from dataclasses import dataclass
from functools import partial
import re
from itertools import product
from typing import Generator

@dataclass
class ParseState:
    text: str
    offset: int = 0

    def consume(self, length: int) -> "ParseState":
        return ParseState(self.text, self.offset + length)
    
    @property
    def current(self) -> str:
        return self.text[self.offset:] if self.offset < len(self.text) else ""

def regex(pattern: str) -> partial:
    comp = re.compile(pattern)
    def matcher(state: ParseState) -> tuple[str, ParseState]:
        if match := comp.match(state.current):
            return match.group(), state.consume(match.end())
        raise ValueError(f"No match for {pattern}")
    return partial(matcher)

def alt(*parsers) -> partial:
    def matcher(state: ParseState):
        for parser in parsers:
            try:
                return parser(state)
            except ValueError:
                continue
        raise ValueError("No alternatives matched")
    return partial(matcher)

# Example usage
url_parser = regex(r"https?://\S+\.(?:jpe?g|png|gif|webp)\b")
brace_open = regex(r"\{")
brace_close = regex(r"\}")

def parse_permutations(state: ParseState) -> Generator[list[str], None, None]:
    # Implementation using generator for memory efficiency
    pass
```

3. **Key Enhancements**
- **Permutation Handling**:
```python
def expand_permutations(text: str) -> list[str]:
    stack = [[]]
    current = ['']
    escaped = False
    
    for char in text:
        if escaped:
            current = [c + char for c in current]
            escaped = False
        elif char == '\\':
            escaped = True
        elif char == '{':
            stack.append(current)
            current = ['']
        elif char == '}':
            if len(stack) > 1:
                options = [c for c in current if c]
                parent = stack.pop()
                ...# AND SO ON
```

<think>
Okay, let's tackle this problem. The user has a Python project for parsing Midjourney prompts, and they want suggestions for cleaner, more efficient, and readable code. The existing code handles permutations, parameters, and various validations. 

First, I need to understand the current structure. Looking at the files, there's a lot going on: permutation expansion, parameter parsing, validation. But the code might be getting bogged down with too many steps and perhaps some redundancy.

The user mentions using alternative Python-based methods. So maybe using more functional programming approaches or leveraging existing libraries. They provided a skeleton using parser combinators and itertools, which are good for structured parsing and combinatorics.

Starting with the permutation handling. The current code uses recursive functions and manual splitting of options. But using itertools.product could simplify generating combinations. For example, splitting the text into segments and then using product to generate all possible combinations.

For parsing parameters, the current code has a lot of conditional checks. Maybe using a state machine approach with dataclasses to track the parsing state. That would make the code more modular and easier to test.

The tokenization step is crucial. Instead of handling each character manually, using regular expressions to tokenize the input into different elements (URLs, braces, parameters) could make the code cleaner. Then, processing these tokens in a pipeline.

Validation can be separated into different stages. For example, first parse the structure, then validate the parameters against allowed values. Using Pydantic models here could help with data validation and serialization.

For the permalink expansion, the current code uses a while loop with complex state management. Replacing that with a generator function that yields parsed elements step by step could improve readability and efficiency.

Another point is handling escaped characters. The current code replaces them with markers, but using a stateful approach during parsing would handle them more naturally without temporary replacements.

For parameters, splitting the parsing into key-value pairs with type conversion based on the parameter name. Using a registry of parameter handlers could make adding new parameters easier without modifying the core logic.

Overall, the goal is to modularize each part: tokenization, permutation expansion, parameter parsing, validation. Using Python's built-in features like dataclasses, itertools, and regular expressions can lead to cleaner code.

So the steps would be:

1. Tokenize the input into URLs, text, parameters, and permutation blocks.
2. Expand permutations using itertools.product.
3. Parse parameters into a structured format with validation.
4. Combine everything into the final parsed prompt structure.

Each of these steps can be a separate component, making the code more maintainable and testable. This approach should handle edge cases like nested permutations and escaped characters more gracefully while improving performance through efficient combination generation.
</think>

Here's an improved approach using modern Python features and a more structured parser design:

```python
from dataclasses import dataclass, field
from itertools import product
import re
from typing import Generator, List, Tuple, Union
from functools import partial
from pydantic import BaseModel, ValidationError

# --- Core Data Models ---
class PromptComponent(BaseModel):
    text: str
    weight: float = 1.0

class ImageReference(PromptComponent):
    url: str
    weight: float = 1.0

class Parameter(BaseModel):
    name: str
    value: Union[str, float, int, None]

# --- Parser Infrastructure ---
@dataclass
class ParserState:
    text: str
    pos: int = 0
    components: List[Union[PromptComponent, Parameter]] = field(default_factory=list)
    current_weight: float = 1.0

def tokenize(text: str) -> Generator[Tuple[str, str], None, None]:
    """Tokenize input into meaningful components"""
    token_spec = [
        ('URL', r'https?://\S+\.(?:jpe?g|png|gif|webp)\b'),
        ('BRACE_OPEN', r'\{'),
        ('BRACE_CLOSE', r'\}'),
        ('PARAM', r'--[\w-]+'),
        ('WEIGHT', r'::\-?\d+(?:\.\d+)?'),
        ('TEXT', r'[^{}]+')  # Match any non-brace characters
    ]
    tok_regex = '|'.join(f'(?P<{pair[0]}>{pair[1]})' for pair in token_spec)
    
    for match in re.finditer(tok_regex, text, re.IGNORECASE):
        kind = match.lastgroup
        value = match.group()
        if kind == 'TEXT':
            value = value.strip()
            if not value:
                continue
        yield kind, value

# --- Permutation Handling ---
def expand_permutations(text: str) -> List[str]:
    def parse_segment(state: ParserState):
        options = []
        current = []
        escaped = False
        
        while state.pos < len(state.text):
            char = state.text[state.pos]
            if escaped:
                current.append(char)
                escaped = False
                state.pos += 1
            elif char == '\\':
                escaped = True
                state.pos += 1
            elif char == '{':
                state.pos += 1
                nested = parse_segment(state)
                options.append(nested)
            elif char == '}':
                state.pos += 1
                break
            elif char == ',' and not escaped:
                options.append(''.join(current).strip())
                current = []
                state.pos += 1
            else:
                current.append(char)
                state.pos += 1
        
        if current:
            options.append(''.join(current).strip())
        return options or ['']

    root = parse_segment(ParserState(text, 0))
    return [''.join(comb) for comb in product(*root)]

# --- Parameter Parsing ---
PARAM_TYPES = {
    'stylize': int,
    'chaos': int,
    'weird': int,
    'seed': int,
    'stop': int,
    'iw': float,
    'quality': float,
}

def parse_parameter(param_str: str) -> Parameter:
    name, *values = param_str.lstrip('-').split(maxsplit=1)
    value = values[0] if values else None
    
    if value is None:
        return Parameter(name=name, value=None)
    
    # Type conversion
    converter = PARAM_TYPES.get(name)
    if converter:
        try:
            value = converter(value)
        except (ValueError, TypeError):
            raise ValueError(f"Invalid value for {name}: {value}")
    
    return Parameter(name=name, value=value)

# --- Main Parser ---
class PromptParser:
    def __init__(self):
        self.state = ParserState()
        self.image_refs = []
        self.components = []
        self.params = []

    def parse(self, text: str) -> 'PromptParser':
        for kind, value in tokenize(text):
            if kind == 'URL':
                self.image_refs.append(ImageReference(url=value))
            elif kind == 'PARAM':
                self.params.append(parse_parameter(value))
            elif kind == 'WEIGHT':
                self.state.current_weight = float(value.lstrip('::'))
            elif kind == 'BRACE_OPEN':
                permutations = expand_permutations(value)
                self.components.extend(permutations)
            else:
                self.components.append(
                    PromptComponent(text=value, weight=self.state.current_weight)
                )
        return self

# --- Usage Example ---
prompt = "https://example.com/img.jpg {vintage,modern} portrait --stylize 500 --chaos 50"
parser = PromptParser().parse(prompt)

print("Images:", [img.url for img in parser.image_refs])
print("Components:", [c.text for c in parser.components])
print("Params:", [(p.name, p.value) for p in parser.params])
```

Key improvements:

1. **Structural Patterns**:
- Uses parser combinators through tokenization pipeline
- Separate tokenization from interpretation
- Immutable ParserState for tracking position
- Type hints throughout

2. **Efficiency**:
- Generator-based tokenization for memory efficiency
- itertools.product for Cartesian permutations
- Lazy evaluation where possible

3. **Validation**:
- Pydantic models for data integrity
- Centralized parameter type conversion
- Clear error handling

4. **Readability**:
- Declarative token specification
- Separate concerns for different prompt elements
- Clear data flow through parser stages

5. **Extensibility**:
- Easy to add new parameter types
- Modular token handling
- Clear extension points for new features

This approach handles the core requirements while being more maintainable and type-safe. The parser generates structured output that can be directly validated and processed by downstream systems.
</file>

<file path="examples/basic_usage.py">
#!/usr/bin/env python3
# this_file: examples/basic_usage.py

"""
Example script demonstrating basic usage of the midjargon package.
"""

from midjargon import expand_midjargon_input, parse_midjargon_prompt
from rich.console import Console
from rich.panel import Panel

console = Console()


def main():
    # Example 1: Basic prompt parsing
    console.print("\n[bold blue]Example 1: Basic Prompt[/]")
    prompt = "a beautiful landscape --ar 16:9 --stylize 200"
    result = parse_midjargon_prompt(prompt)
    console.print(
        Panel(
            f"Text: {result.text}\n"
            f"Aspect Ratio: {result.parameters.aspect}\n"
            f"Stylize: {result.parameters.stylize}"
        )
    )

    # Example 2: Using image references
    console.print("\n[bold blue]Example 2: Image Reference[/]")
    prompt = "https://example.com/image.jpg a photo in this style --stylize 100"
    result = parse_midjargon_prompt(prompt)
    console.print(
        Panel(
            f"Text: {result.text}\n"
            f"Image URL: {result.images[0].url if result.images else 'None'}\n"
            f"Stylize: {result.parameters.stylize}"
        )
    )

    # Example 3: Permutations
    console.print("\n[bold blue]Example 3: Permutations[/]")
    prompt = "a {red, blue} bird on a {green, yellow} tree"
    variants = expand_midjargon_input(prompt)
    for i, variant in enumerate(variants, 1):
        console.print(f"Variant {i}: {variant.prompt.text}")

    # Example 4: Weighted prompts
    console.print("\n[bold blue]Example 4: Weighted Prompts[/]")
    prompt = "first style::0.7 second style::0.3"
    variants = expand_midjargon_input(prompt)
    for variant in variants:
        console.print(Panel(f"Text: {variant.prompt.text}\nWeight: {variant.weight}"))

    # Example 5: Style references
    console.print("\n[bold blue]Example 5: Style References[/]")
    prompt = "test --sref p123456 --sw 200"
    result = parse_midjargon_prompt(prompt)
    if result.parameters.style_reference:
        console.print(
            Panel(
                f"Text: {result.text}\n"
                f"Style Code: {result.parameters.style_reference.code}\n"
                f"Weight: {result.parameters.style_reference.weight}"
            )
        )

    # Example 6: Combined features
    console.print("\n[bold blue]Example 6: Combined Features[/]")
    prompt = "a {vintage, modern} {portrait, landscape}::0.6 another style::0.4"
    variants = expand_midjargon_input(prompt)
    console.print(f"Total variants: {len(variants)}")
    for i, variant in enumerate(variants, 1):
        console.print(
            Panel(
                f"Variant {i}:\nText: {variant.prompt.text}\nWeight: {variant.weight}"
            )
        )


if __name__ == "__main__":
    main()
</file>

<file path="src/midjargon/core/main.py">
# this_file: src/midjargon/core/main.py
from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from midjargon.core.models import PromptVariant


def format_json_output(
    variants: list[PromptVariant], include_parsed: bool = False
) -> dict[str, Any]:
    """Format prompt variants as JSON output.

    Args:
        variants: List of prompt variants to format.
        include_parsed: Whether to include parsed data in output.

    Returns:
        Dictionary containing formatted output.
    """
    if not variants:
        return {}

    # For single variants without weights, return simple format
    if len(variants) == 1 and variants[0].weight == 1.0:
        variant = variants[0].prompt
        result = {
            "text": variant.text,
            "images": [str(img.url) for img in variant.images],
            "parameters": variant.parameters.model_dump(exclude_none=True),
        }
        if include_parsed:
            result["parsed"] = variant.model_dump(exclude_none=True)
        return result

    # For multiple variants or weighted variants, return array format
    results = []
    for variant in variants:
        prompt = variant.prompt
        result = {
            "text": prompt.text,
            "images": [str(img.url) for img in prompt.images],
            "parameters": prompt.parameters.model_dump(exclude_none=True),
            "weight": variant.weight,
        }
        if include_parsed:
            result["parsed"] = prompt.model_dump(exclude_none=True)
        results.append(result)
    return {"variants": results}
</file>

<file path="src/midjargon/engines/midjourney/parser/exceptions.py">
"""
Custom exceptions for the Midjourney parser.
"""


class ParserError(Exception):
    """Base parser exception."""


class ValidationError(ParserError):
    """Validation-related errors."""


class ParameterValidationError(ValidationError):
    """Specific parameter validation failure."""

    def __init__(self, param_name: str, value: str, reason: str) -> None:
        """Initialize parameter validation error.

        Args:
            param_name: Name of the parameter that failed validation
            value: Invalid value
            reason: Reason for validation failure
        """
        self.param_name = param_name
        self.value = value
        self.reason = reason
        super().__init__(f"Invalid value for {param_name}: {value} - {reason}")
</file>

<file path=".github/copilot-instructions.md">
<guidelines for python>
1. WHEN YOU WRITE PYTHON: 

a. CORE STYLE: Follow PEP 8 for consistent formatting & naming. Write clear, descriptive names for functions & variables. Keep code simple & explicit (PEP 20). Prioritize readability over cleverness. 
b. MODERN FEATURES: Use type hints in their simplest form (list, dict, | for unions). Write clear, imperative docstrings (PEP 257). Employ f-strings for string formatting. Use structural pattern matching where appropriate. 
c. CODE STRUCTURE: Extract repeated logic into focused functions. Handle errors explicitly and gracefully. Keep functions small and single-purpose. Prefer flat over nested structures. 
d. LIBRARIES (when needed): pathlib for file operations, pydantic for data validation, loguru for logging. Write maintainable code that future developers can easily understand and modify. 
e. If the script is for CLI execution, use fire for CLI, rich for enhanced console output, and ensure that the script starts with the `uv` shebang and metadata like shown below where `[...]` is a list of Python dependency specifiers, like `["fire", "rich"]`: 

```
#!/usr/bin/env -S uv run 
# /// script
# dependencies = [...]
# ///
```

f. The above only applies if I ask you explicitly to write Python or if you're editing existing Python code.
</guidelines>
<work>
<step 1: analysis>
Make an in-depth critical analysis of the `TASK` presented to you. Read the content of the @TODO.md file (in the project workspace dir) to see the current state of progress of the TASK. Then make an in-depth critical analysis of the inputs presented. 
</step>
<step 2: gather up-to-date insights>
Consult the @Web if you can. Consult the most up-to-date @Docs and run `hatch fmt; hatch test`. 
</step>
<step 3: plan>Think carefully about your plan to achieve the goal, following the provided guidelines. Write out general principles, then propose specific changes. 
</step>
<step 4: pre-implementation>
Once youve analyzed the TASK request and the inputs, youve gathered up-to-date insights and ran the `hatch` tests and checks and once youve made a careful plan  write the entire plan into the file @TODO.md (in the project workspace folder)  be very detailed and specific. 
</step>
<step 5: implementation>
You can start implementing the plan. Whenever youve made larger edits to Python files, run `hatch fmt; hatch test` to see how your changes impacted the @Codebase , then refine your plan. Keep progress documentation in @TODO.md (in the project workspace folder) , remove completed items. Work until you CLEAR the @TODO.md !     
</step>
</work>


<codebase-summary>
 README.md
 TODO.md # CHECK HERE FOR THE CURRENT STATE OF PROGRESS OF THE TASK
 dist
 docs
  midjourney-docs.md # DOCUMENTATION FOR THE MIDJOURNEY ENGINE
  refactoring-ideas.md # IGNORE
  specification.md # MIDJARGON SPEC
 package.toml
 pyproject.toml # PACKAGE CONFIG
 src
  midjargon
      __init__.py
      __main__.py
      cli # CLI CODE
       __init__.py
       main.py
      core # PROVIDER-NEUTRAL CODE
       __init__.py
       converter.py
       input.py
       parameters.py
       parser.py
       permutations.py
       type_defs.py
      engines # PROVIDER-SPECIFIC CODE
          __init__.py
          base.py
          fal # FAL (dicts)
           __init__.py
           converter.py
          midjourney # MIDJOURNEY (pydantic)
              ____parser-OLD.py
              __init__.py
              constants.py
              models.py
              parser
                  __init__.py
                  core.py
                  exceptions.py
                  parameters.py
                  validation.py
 tests
  __init__.py
  cli
   __init__.py
   test_main.py
  conftest.py
  core
   __init__.py
   test_input.py
   test_parameters.py
   test_permutations.py
  engines
   __init__.py
   midjourney
    __init__.py
    test_parser.py
   test_base.py
  integration
   __init__.py
   test_workflow.py
  test_package.py
  tests
</codebase-summary>
</file>

<file path="docs/specification.md">
# **Midjourney Prompt Format Specification**

_2025-02-06 by Adam Twardoch, not affiliated with Midjourney_

Midjourney prompts use midjargon, a structured syntax to instruct the Midjourney models to generate images. A prompt consists of three main sections, in order:

1. **Image Reference (Optional)**
2. **Text Description (Required if no image is provided)**
3. **Parameters (Optional)**

Each section has defined syntax and placement requirements. Advanced features such as multi-prompts with weights, permutation prompts, personalization, and style or character references are integrated into the text description and parameters.

Midjourney supports two distinct types of stylizations. The official Midjourney documentation often ambiguously calls both style: 

- Style reference
- Personalization

## Parameters

Parameters are modifiers appended at the end of the prompt that adjust various aspects of image generation. Parameters always begin with two hyphens `--` and may accept a value. The order of parameters (after the text description) is flexible.

Terms that follow a parameter `--a` are treated as its arguments (values). If `--a` is directly followed by another parameter `--b`, then `--a` is considered a boolean flag. 

---

## Choosing the model

### Midjourney series (`--v` or `--version`)

Uses the specified version of the general Midjourney model series. 

#### Syntax

```
--v <version_number>
```

#### Values

- `5`, `5.1`, `5.2`, `6`, `6.1`

> Example

```
--v 6
```

### Niji series (`--niji`)

Uses the specified version of the Niji model series, optimized for anime and illustrative styles.

#### Syntax

```
--niji <version_number>
```

- Values: `5`, `6`

> Example

```
--niji 6
```

### Model mode (`--style`)

Applies specific model mode. 

```
--style <mode_name>
```

- Mode name can be `raw`, it reduces automatic personalization.

> Example

```
--style raw
```

## Using images

### Image references

One or more direct image URLs or attachments used to influence the generated image's style, color, composition, and content.

Must appear at the very **start** of the prompt.

Each image can be:

- A direct image URL ending with `.png`, `.jpg`, `.jpeg`, `.gif`, or `.webp`.
- An attached image in Discord or uploaded via the Midjourney web interface.

Multiple images are separated by whitespace.

> Example

```
https://example.com/image1.jpg https://example.com/image2.png
```

#### Image weight (`--iw`)

`--iw <value>`

Adjusts the influence of all image references relative to the text prompt. 

- Value Range `0.0` to `3.0` (float)
- Default: `1.0` (varies by model)

> Example

```
--iw 1.5
```

As with other parameters, `--iw` must be placed after the text description, even though it refers to the image references that are placed at the very start of the prompt.

### Character reference (`--cref`)

`--cref <url1> [<url2> ...]`

Uses images as character references to maintain consistency.

#### Character weight (`--cw`)

Adjusts the strength of the character reference.

`--cw <value>`

- Value range: `0` to `100` (integer)
- Default: `100`

The character weight `0` typically only copies the face. 

> Example

```
--cref https://example.com/character.jpg --cw 50
```

### Style reference (`--sref`)

The `--sref` parameter uses images as style references without influencing content. It applies the visual characteristics of a specific images or stylization code. 

In effect, it pulls the generated image towards a specific look that is expressed explicitly (via the image) or less directly (via the stylization code).

```
--sref <url|code> [<url|code> ...]
```

One or more image URLs or a specific stylization CODE (the CODE acts as a shorthand for a predefined image reference)

#### Style weight (`--sw`)

Adjusts the strength of the style reference.

`--sw <value>`

- Value Range: `0` to `1000` (integer)

#### Style version (`--sv`)

Selects different style reference algorithms.

`--sv <value>`

- Values: `1`, `2`, `3`, `4`

> Example

```
--sref https://example.com/style.jpg --sw 200 --sv 2
```

#### Random style reference

`--sref random`

Generates a random style reference.

### Persona reference (`--p`)

References one or more personas, personalized style profiles, which pull the generated image towards the preferences or a general style of a particular user or moodboard, with the degree controlled by `--s`.

- Without specifying a persona code, `--p` uses your current personalization profile.
- Providing one or more persona codes of a personalization profile or moodboard (e.g., `--p p123456789`) applies a specific personalization.

#### Personalization weight (`--s`)

```
--stylize <value>
```

The `--s` (`--stylize`, or personalization weight) parameter controls the degree of personalization. 

- If a persona with a code is provided, the `--s` parameter controls how much the generated image will be pulled towards that persona.
- If the personalization switch is used (`--p`) without a code, the `--s` parameter controls how much the generated image will be pulled towards your current personalization profile.
- If the personalization switch is not used (no `--p` at all), the `--s` parameter controls how much the generated image will be pulled towards the models general persona (overall aesthetic preference).

- Value range: `0` to `1000` (integer)
- Default: `100`

The value of `0` applies minimal personalization, though certain influence of the model remains. To reduce the model influence, and have purer personalization use `--style raw` together with a low `--s` value.

> Example:

```
--p p123456789 --s 500 --style raw
```

## Describing the image

A natural language description of the desired image, specifying the subject, mood, style, and other artistic details.

### Clarity & specificity

Use specific adjectives, nouns, and phrases. Describe the subject, medium, environment, lighting, color, mood, and composition.

### Positive framing

Emphasize what should appear in the image rather than what should be excluded (exclusions are handled by the `--no` parameter).

### Tokenization

The text is internally tokenized; word order and precision are important.

### Text generation

Use double quotation marks `"` around words or phrases to specify exact text you want to appear in the image.

> Example

```
A neon sign that says "Open"
```

### Negative text description (`--no`)

Signals to the model elements or aspects that you dont want to see in the image. 

```
--no <item1, item2, ...>
```

- Value: Comma-separated list of terms

> Example:

```
--no cars, trees, watermarks
```

## Image layout

### Aspect ratio (`--ar`)

Sets the width-to-height ratio of the image

```
--ar <width>:<height>
```

- Value: Two integers separated by a colon
- Default: `1:1`

> Example:

```
--ar 16:9
```

### Tile (`--tile`)

Creates images that are seamlessly tileable

```
--tile
```

- Value: None (boolean flag)

> Example:

```
--tile
```

---

## Separating and prioritizing

Use a double colon `::` to separate concepts, optionally followed by a weight. If omitted, the weight defaults to 1.

```
concept1 ::<weight1> concept2 ::<weight2> ...
```

- Weight values can be floating-point numbers within the range `-10.0` to `10.0`.
- Negative weights (e.g., `::-0.5`) de-emphasize or exclude a concept.

### Purpose

This syntax allows you to balance and blend different concepts in one prompt. Weights are normalized internally to maintain their proportional relationships.

### Examples

```
futuristic city ::2 cyberpunk skyline ::1
beautiful landscape ::1.5 mountains ::-0.5 water
serene lake ::2 foggy mountains ::1
portrait ::1.5 dramatic lighting ::1 dark background ::0.8
still life painting ::1 fruit ::-0.5
```

---

## Variation

### Chaos (`--chaos` or `--c`)

Controls variation or unpredictability in the output

```
--chaos <value>
```

- Value range: `0` to `100` (integer)
- Default: `0`

> Example

```
--chaos 50
```

### Weird (`--weird` or `--w`)

Introduces unconventional aesthetics

```
--weird <value>
```

- Value range: `0` to `3000` (integer)
- Default: `0`

> Example

```
--weird 1000
```

---

## Generation process

### Seed (`--seed`)

Sets a specific seed to reproduce outcomes

```
--seed <value>
```

- Value range: `0` to `4294967295` (integer)

> Example:

```
--seed 123456789
```

### Prompt permutation

Prompt permutation allows you to quickly generate multiple prompts by including comma-separated options within curly braces `{}`. The surrounding fixed text is repeated with each provided option to create separate prompt variations.

Enclose a comma-separated list of options within curly braces. 

```
A {red, blue, green} car
```

This expands to 3 prompts:

- `A red car`
- `A blue car`
- `A green car`

Repeat permutations.

```
A {red, blue} {car, truck} with {chrome, matte} finish
```

This expands to 222=8 prompts. 

Permute parameters.

```
portrait --ar {1:1, 16:9} --s {100, 500, 1000}
```

This expands to 23=6 prompts. 

Nest permutations.

```
{realistic, artistic} scene --v {5.2, 6 {, --style raw}} 
```

This expands to 2(2+1)=6 prompts:

- `realistic scene --v 5.2`
- `realistic scene --v 6`
- `realistic scene --v 6 --style raw`
- `artistic scene --v 5.2`
- `artistic scene --v 6`
- `artistic scene --v 6 --style raw`

Within a permutation group, use commas to separate portions, prefix a comma with a backslash to actually have it in the expanded prompt.

```
A {bright\, vibrant, dark\, moody} atmosphere
```

This expands to 2 prompts:

- `A bright, vibrant atmosphere`
- `A dark, moody atmosphere`

The total number of permutations may be limited based on subscription tier. Permutation prompts are only available in Fast Mode.

Permutation is great for exploring various syntaxes and prompt structures: 

```
beautiful woman{::, ::2, ::0.3, \,} sports car
```

expands into

- `beautiful woman:: sports car`
- `beautiful woman::2 sports car`
- `beautiful woman::0.3 sports car`
- `beautiful woman, sports car`



### Repeat (`--repeat` or `--r`)

The `--r` parameter produces multiple prompts, similarly to prompt permutation, but the multiplication happens on the model side. It can be combined with permutation prompts.

If a prompt includes the `--r` parameter, the model runs the same prompt multiple times to generate variations. It can be used with `--sref random` to generate different style references each time. 

```
--repeat <number>
```

- Value range: Basic Subscribers: 24, Standard Subscribers: 210, Pro/Mega Subscribers: 240

> Example:

```
--repeat 5
```

## Quality and speed

### Quality (`--quality` or `--q`)

Controls the time spent generating an image; affects detail

```
--quality <value>
```

- Values: `0.25`, `0.5`, `1` (default)

> Example

```
--quality 0.5
```

#### Turbo Mode (`--turbo`)

Generates images faster using additional GPU resources

```
--turbo
```

- Value: None (boolean flag)

#### Relax Mode (`--relax`)

Generates images in relaxed mode without consuming GPU time

```
--relax
```

- Value: None (boolean flag)

### Stop (`--stop`)

Stops image generation at a specified percentage of completion for different artistic effects

```
--stop <value>
```

- Value range: `10` to `100` (integer)
- Default: `100`

> Example:

```
--stop 80
```

---

## Summary

- **Order matters**: Image prompts come first (if used), followed by the text description, and then all parameters.
- **Parameter prefix**: Every parameter starts with `--` and, if required, is followed by a space and its value.
- **Advanced techniques**: Use multi-prompts with `::` and permutation prompts with `{}` to fine-tune creative direction and generate multiple variations.
- **Personalization and references**: `--sw` controls the weight of the style reference (`--sref`). `--s` controls the weight of personalization (`--p`, or of the default persona when `--p` is not provided). Style reference and personalization operate independently: each pulls the image in a distinct stylistic direction. To test the full effect of style reference without personalization influence, use: `--style raw --s 0`.
- **Model and feature dependencies**: Some parameters (e.g., `--iw`, `--sv`, `--p`, permutation prompts) are model-specific or depend on the subscription tier or mode (e.g., Fast Mode).
- **Text generation**: Use double quotation marks `"` to specify exact text to appear in the image.

## Prompt examples

1. **Basic Text-Only Prompt:**

```
/imagine prompt: A serene sunset over the ocean
```

2. **Prompt with Image URLs, Text, and Parameters:**

```
/imagine prompt: https://example.com/inspiration.jpg A portrait of a wise old man --style raw --v 5.1
```

3. **Prompt with Character and Style References:**

```
/imagine prompt: A hero in battle --cref https://example.com/hero.png --cw 75 --sref https://example.com/style.jpg --sw 150
```

4. **Multi-Prompt with Weighting:**

```
/imagine prompt: futuristic city ::2 cyberpunk skyline ::1 --chaos 20
```

5. **Permutation Prompt for Multiple Variations:**

```
/imagine prompt: A {red, blue, green} bird on a {flower, leaf} --ar {16:9, 1:1}
```

6. **Prompt with Personalization and Parameters:**

```
/imagine prompt: A vibrant garden in spring --p p123456789 --stylize 500 --seed 987654321
```

7. **Complex Mixed Prompt:**

```
/imagine prompt: {realistic, artistic} portrait of a {young, old} {man, woman} --style {raw, expressive} --v 6 --ar 1:1 --stylize {100, 1000}
```

8. **Prompt with Exclusions and Turbo Mode:**

```
/imagine prompt: A futuristic landscape at dusk --ar 21:9 --stylize 300 --chaos 50 --seed 987654321 --no buildings, cars --turbo
```

---

## Notes for parser implementers

### Parsing order

1. **Permutation:**

- Process all permutation groups `{...}`.
- Handle nested permutations.
- Expand into individual prompts.
- `a{b, c}d` should expand to `abd` `acd`. The spaces right around the `{` and `}` should be treated as they are. Spaces around the separating commas can be collapsed fully, as if there is no space.
- `\{` `\}` `\,` must produce the literal `{` `}` `,` in the expanded permutations

2. **Image referece:**

- Identify and validate image URLs or attachments at the start.
- Check for supported file formats.
- Handle multiple images.

3. **Text description:**

- Extract main prompt text.
- Segment text by weight markers `::`.
- Handle escaped characters.
- Identify text in double quotes `"` for explicit text generation.

4. **Parameter Processing:**

- Extract parameters starting with `--`.
- Parse parameter values.
- Handle boolean flags.
- Validate parameter ranges.
- Values should be typically strings, unless its obviously an int or float. Version "number" should be kept a string.

### Boolean Parameters

- If a parameter is followed by another parameter (e.g., `--tile --ar 16:9`), it's treated as a boolean flag.

### Multi-Value Parameters

- Some parameters accept multiple values (e.g., `--no cars, trees`).

### Parameter Validation

- Numeric ranges are enforced.
- Aspect ratios must be valid integers.
- Version numbers must be supported.
- Style names and codes must be recognized.

### Error handling

The parser should handle common errors gracefully:

- Invalid URL formats.
- Malformed permutation syntax.
- Invalid parameter values.
- Missing required components.
- Unsupported parameter combinations.
</file>

<file path="src/midjargon/engines/fal/_fal.py">
"""
fal.py

Provides functions to convert Midjourney prompts to Fal.ai format.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from midjargon.core.type_defs import MidjargonDict


def to_fal_dict(midjargon_dict: MidjargonDict) -> dict[str, Any]:
    """
    Convert a MidjargonDict to Fal.ai format.

    Args:
        midjargon_dict: Dictionary to convert.

    Returns:
        Dictionary in Fal.ai format.
    """
    result = {
        "prompt": midjargon_dict.get("text", ""),
        "negative_prompt": midjargon_dict.get("negative_prompt"),
        "width": 1024,  # Default width
        "height": 1024,  # Default height
        "num_inference_steps": 50,  # Default steps
        "guidance_scale": 7.5,  # Default guidance scale
        "seed": midjargon_dict.get("seed"),
    }

    # Handle aspect ratio
    if "aspect_width" in midjargon_dict and "aspect_height" in midjargon_dict:
        width = midjargon_dict["aspect_width"]
        height = midjargon_dict["aspect_height"]
        if isinstance(width, int) and isinstance(height, int):
            # Scale to maintain aspect ratio while keeping max dimension at 1024
            if width > height:
                result["width"] = 1024
                result["height"] = int(1024 * (height / width))
            else:
                result["height"] = 1024
                result["width"] = int(1024 * (width / height))

    # Handle other parameters
    if "chaos" in midjargon_dict:
        chaos = midjargon_dict["chaos"]
        if isinstance(chaos, int | float):
            result["guidance_scale"] = max(1.0, 15.0 - (chaos / 10))

    if "stop" in midjargon_dict:
        stop = midjargon_dict["stop"]
        if isinstance(stop, int | float):
            result["num_inference_steps"] = min(100, max(10, int(stop / 2)))

    return result
</file>

<file path="src/midjargon/engines/fal/fal.py">
#!/usr/bin/env python3
# this_file: src/midjargon/engines/fal/fal.py
from __future__ import annotations

from typing import Any

from pydantic import BaseModel, HttpUrl, computed_field


class FalPrompt(BaseModel):
    """Fal.ai prompt model with all parameters."""

    text: str
    image_prompts: list[HttpUrl] = []
    negative_prompt: str | None = None
    num_inference_steps: int | None = 50
    guidance_scale: float | None = 7.5
    width: int | None = 1024
    height: int | None = 1024
    seed: int | None = None
    scheduler: str | None = None
    extra_params: dict[str, Any] = {}

    @computed_field
    def images(self) -> list[HttpUrl]:
        """Get image URLs."""
        return self.image_prompts

    @computed_field
    def parameters(self) -> dict[str, Any]:
        """Get all parameters as a dictionary."""
        params = self.model_dump(exclude={"text", "image_prompts", "extra_params"})
        return {k: v for k, v in params.items() if v is not None}

    def to_string(self) -> str:
        """Convert prompt to string format."""
        parts = [self.text]

        # Add image prompts
        for url in self.image_prompts:
            parts.append(str(url))

        # Add parameters
        params = []
        for field, value in self.model_dump(exclude_unset=True).items():
            if field in {"text", "image_prompts", "extra_params"} or value is None:
                continue
            if isinstance(value, bool) and value:
                params.append(f"--{field}")
            elif isinstance(value, list) and value:
                for v in value:
                    params.append(f"--{field} {v}")
            else:
                params.append(f"--{field} {value}")

        # Add extra parameters
        for key, value in self.extra_params.items():
            if value is None:
                params.append(f"--{key}")
            else:
                params.append(f"--{key} {value}")

        if params:
            parts.append(" ".join(params))

        return " ".join(parts)


class FalParser:
    """Parser for converting between Fal.ai prompt formats."""

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.

        Args:
            prompt_dict: Dictionary containing prompt data.

        Returns:
            FalPrompt instance.

        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)

        # Extract known fields
        known_fields = set(FalPrompt.model_fields)

        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value

        # Create prompt with all parameters
        return FalPrompt(text=text, **params, extra_params=extra_params)


def parse_fal_dict(prompt_dict: dict[str, Any]) -> FalPrompt:
    """Convert a dictionary to a FalPrompt.

    Args:
        prompt_dict: Dictionary containing prompt data.

    Returns:
        FalPrompt instance.
    """
    parser = FalParser()
    return parser.parse_dict(prompt_dict)
</file>

<file path="src/midjargon/engines/midjourney/parser/validation.py">
"""
Validation utilities for the Midjourney parser.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any, ClassVar, TypeVar

from midjargon.engines.midjourney.constants import (VALID_NIJI_VERSIONS,
                                                    VALID_VERSIONS)
from midjargon.engines.midjourney.parser.exceptions import ValidationError

if TYPE_CHECKING:
    from collections.abc import Callable

T = TypeVar("T")


def validate_version_pattern(value: str) -> bool:
    """Validate version string pattern.

    Args:
        value: Version string to validate

    Returns:
        True if valid, False otherwise
    """
    if value.lower().startswith("niji"):
        parts = value.split()
        return len(parts) == 1 or (len(parts) > 1 and parts[1] in VALID_NIJI_VERSIONS)
    version = value[1:] if value.startswith("v") else value
    return version in VALID_VERSIONS


def validate_image_reference(value: str) -> bool:
    """Validate image reference URL or path.

    Args:
        value: Image reference to validate

    Returns:
        True if valid, False otherwise
    """
    return any(value.lower().endswith(ext) for ext in (".jpg", ".jpeg", ".png", ".gif"))


class ValidatorRegistry:
    """Registry of validation functions."""

    _validators: ClassVar[dict[str, Callable[..., bool]]] = {
        "range": lambda v, mn, mx: mn <= v <= mx,
        "version": validate_version_pattern,
        "image_ref": validate_image_reference,
    }

    @classmethod
    def validate(cls, name: str, value: Any, *args: Any) -> bool:
        """Validate a value using the registered validator.

        Args:
            name: Name of the validator to use
            value: Value to validate
            *args: Additional arguments for the validator

        Returns:
            True if validation passes

        Raises:
            ValidationError: If validator not found
        """
        validator = cls._validators.get(name)
        if not validator:
            msg = f"No validator found for {name}"
            raise ValidationError(msg)
        return validator(value, *args)

    @classmethod
    def register(cls, name: str, validator: Callable[..., bool]) -> None:
        """Register a new validator.

        Args:
            name: Name for the validator
            validator: Validation function
        """
        cls._validators[name] = validator
</file>

<file path="tests/test_core.py">
#!/usr/bin/env python3
# this_file: tests/test_core.py

import pytest
from midjargon import expand_midjargon_input
from midjargon.core.models import MidjourneyParameters, MidjourneyPrompt
from midjargon.core.parser import parse_midjargon_prompt
from midjargon.core.permutations import expand_permutations


def test_basic_prompt_parsing():
    """Test basic prompt parsing without parameters."""
    prompt = "a beautiful landscape"
    result = parse_midjargon_prompt(prompt)
    assert isinstance(result, MidjourneyPrompt)
    assert result.text == "a beautiful landscape"
    assert not result.image_prompts
    assert result.parameters == MidjourneyParameters()


def test_prompt_with_parameters():
    """Test prompt parsing with various parameters."""
    prompt = "a portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
    result = parse_midjargon_prompt(prompt)

    assert result.text == "a portrait"
    assert result.parameters.aspect == "16:9"
    assert result.parameters.stylize == 200
    assert result.parameters.chaos == 50
    assert result.parameters.version == "v6"


def test_prompt_with_image():
    """Test prompt parsing with image URLs."""
    prompt = "https://example.com/image.jpg a photo in this style"
    result = parse_midjargon_prompt(prompt)

    assert result.text == "a photo in this style"
    assert len(result.image_prompts) == 1
    assert str(result.image_prompts[0]) == "https://example.com/image.jpg"


def test_invalid_parameters():
    """Test handling of invalid parameters."""
    with pytest.raises(ValueError):
        parse_midjargon_prompt("test --invalid value")


def test_permutation_expansion():
    """Test permutation expansion."""
    prompt = "a {red, blue} bird on a {green, yellow} tree"
    results = expand_permutations(prompt)

    assert len(results) == 4
    assert "a red bird on a green tree" in results
    assert "a red bird on a yellow tree" in results
    assert "a blue bird on a green tree" in results
    assert "a blue bird on a yellow tree" in results


def test_escaped_permutations():
    """Test handling of escaped characters in permutations."""
    prompt = r"a {red\, orange, blue} bird"
    results = expand_permutations(prompt)

    assert len(results) == 2
    assert "a red, orange bird" in results
    assert "a blue bird" in results


def test_weighted_prompts():
    """Test handling of weighted prompts."""
    prompt = "first prompt::0.7 second prompt::0.3"
    results = expand_midjargon_input(prompt)

    assert len(results) == 2
    assert results[0].weight == 0.7
    assert results[1].weight == 0.3


def test_combined_features():
    """Test combination of multiple features."""
    prompt = "a {red, blue} bird::0.6 a {green, yellow} tree::0.4"
    results = expand_midjargon_input(prompt)

    assert len(results) == 4
    # Check first group
    red_blue = [r for r in results if "bird" in r.prompt.text]
    assert len(red_blue) == 2
    assert all("bird" in r.prompt.text for r in red_blue)
    assert all(r.weight == 0.6 for r in red_blue)

    # Check second group
    green_yellow = [r for r in results if "tree" in r.prompt.text]
    assert len(green_yellow) == 2
    assert all("tree" in r.prompt.text for r in green_yellow)
    assert all(r.weight == 0.4 for r in green_yellow)


def test_style_reference():
    """Test handling of style references."""
    # Test with code
    prompt = "test --sref p123456"
    result = parse_midjargon_prompt(prompt)
    assert result.style_reference
    assert result.style_reference[0].code == "p123456"

    # Test with URL
    prompt = "test --sref https://example.com/style.jpg"
    result = parse_midjargon_prompt(prompt)
    assert result.style_reference
    assert str(result.style_reference[0].url) == "https://example.com/style.jpg"


def test_character_reference():
    """Test handling of character references."""
    prompt = "test --cref https://example.com/char.jpg --cw 50"
    result = parse_midjargon_prompt(prompt)

    assert result.character_reference
    assert str(result.character_reference[0].url) == "https://example.com/char.jpg"
    assert result.character_weight == 50


def test_prompt_to_string():
    """Test conversion of prompt back to string format."""
    original = "a portrait --ar 16:9 --stylize 200"
    result = parse_midjargon_prompt(original)

    # Convert back to string
    output = result.to_string()

    # Parse again to verify equivalence
    reparsed = parse_midjargon_prompt(output)
    assert reparsed.text == result.text
    assert reparsed.parameters.model_dump() == result.parameters.model_dump()
</file>

<file path="ERRORS.txt">
cmd [1] | fd -e py -x pyupgrade --keep-runtime-typing --py310-plus
cmd [2] | ruff format .
32 files left unchanged
cmd [3] | ruff check --fix --unsafe-fixes .
src/midjargon/core/input.py:9:5: C901 `parse_weighted_prompt` is too complex (13 > 10)
   |
 9 | def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
   |     ^^^^^^^^^^^^^^^^^^^^^ C901
10 |     """Parse a prompt with optional weights.
   |

src/midjargon/core/input.py:54:89: E501 Line too long (92 > 88)
   |
52 |                     raise ValueError(msg)
53 |             except ValueError as e:
54 |                 msg = f"Invalid weight at position {weight_start}: {prompt[weight_start:i]}"
   |                                                                                         ^^^^ E501
55 |                 raise ValueError(msg) from e
   |

src/midjargon/core/input.py:82:89: E501 Line too long (101 > 88)
   |
81 | def expand_midjargon_input(prompt: str) -> list[PromptVariant]:
82 |     """Expand a midjourney prompt by processing permutations and returning a list of prompt variants.
   |                                                                                         ^^^^^^^^^^^^^ E501
83 |
84 |     Args:
   |

src/midjargon/core/models.py:32:9: C901 `_missing_` is too complex (16 > 10)
   |
31 |     @classmethod
32 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ C901
33 |         """Handle missing values by trying to normalize the input."""
34 |         try:
   |

src/midjargon/core/models.py:179:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
177 |             except ValueError as e:
178 |                 msg = f"Invalid aspect ratio format: {e}"
179 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^ B904
180 |         return v
    |

src/midjargon/core/models.py:197:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
195 |             except ValueError:
196 |                 msg = f"Invalid version value: {v}"
197 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^ B904
198 |         return v
    |

src/midjargon/core/models.py:213:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
211 |             except ValueError:
212 |                 msg = f"Invalid seed value: {v}"
213 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^ B904
214 |         return v
    |

src/midjargon/core/models.py:225:9: C901 `to_string` is too complex (32 > 10)
    |
223 |         return None
224 |
225 |     def to_string(self) -> str:
    |         ^^^^^^^^^ C901
226 |         """Convert parameters to string format."""
227 |         parts = []
    |

src/midjargon/core/parameters.py:68:5: E722 Do not use bare `except`
   |
66 |         result = urlparse(value)
67 |         return all([result.scheme, result.netloc])
68 |     except:
   |     ^^^^^^ E722
69 |         return False
   |

src/midjargon/core/parameters.py:72:5: C901 `convert_parameter_value` is too complex (22 > 10)
   |
72 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ C901
73 |     """Convert a parameter value to the appropriate type."""
74 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:101:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
 99 |         except ValueError:
100 |             msg = f"Invalid version value: {value}"
101 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
102 |
103 |     # Handle seed parameter
    |

src/midjargon/core/parameters.py:111:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
109 |         except ValueError:
110 |             msg = f"Invalid seed value: {value}"
111 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
112 |
113 |     # Handle integer parameters
    |

src/midjargon/core/parameters.py:119:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
117 |         except ValueError:
118 |             msg = f"Invalid integer value for {param}: {value}"
119 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
120 |
121 |     # Handle float parameters
    |

src/midjargon/core/parameters.py:136:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
134 |         except ValueError:
135 |             msg = f"Invalid numeric value for {param}: {value}"
136 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
137 |
138 |     # Handle style parameter
    |

src/midjargon/core/parameters.py:144:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
142 |         except ValueError:
143 |             msg = f"Invalid style value: {value}"
144 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
145 |
146 |     # Handle character and style references
    |

src/midjargon/core/parameters.py:159:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
157 |         except Exception as e:
158 |             msg = f"Invalid reference value for {param}: {value} ({str(e)})"
159 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
160 |
161 |     # Default case: return as string
    |

src/midjargon/core/parameters.py:165:5: C901 `parse_parameters` is too complex (14 > 10)
    |
165 | def parse_parameters(param_str: str) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^ C901
166 |     """Parse parameters from a string into a dictionary."""
167 |     if not param_str:
    |

src/midjargon/core/parameters.py:175:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
173 |     except ValueError as e:
174 |         msg = f"Failed to parse parameters: {e}"
175 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
176 |
177 |     result: dict[str, Any] = {}
    |

src/midjargon/core/parameters.py:208:21: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
206 |                 except Exception as e:
207 |                     msg = f"Failed to parse parameter {current_param}: {e}"
208 |                     raise ValueError(msg)
    |                     ^^^^^^^^^^^^^^^^^^^^^ B904
209 |
210 |             # Start new parameter
    |

src/midjargon/core/parameters.py:241:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
239 |         except Exception as e:
240 |             msg = f"Failed to parse parameter {current_param}: {e}"
241 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
242 |
243 |     return result
    |

src/midjargon/core/parser.py:67:5: C901 `parse_parameters` is too complex (30 > 10)
   |
67 | def parse_parameters(param_str: str) -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^ C901
68 |     """Parse parameter string into a dictionary.
   |

src/midjargon/core/permutations.py:127:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
125 |     except Exception as e:
126 |         msg = f"Failed to parse options at position {start}: {e!s}"
127 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
128 |
129 |     if not options:
    |

src/midjargon/core/permutations.py:145:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
143 |         except Exception as e:
144 |             msg = f"Failed to expand option '{option}': {e!s}"
145 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
146 |
147 |     return results
    |

src/midjargon/engines/midjourney/midjourney.py:31:9: C901 `parse_dict` is too complex (28 > 10)
   |
29 |         return HttpUrl(url)
30 |
31 |     def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
   |         ^^^^^^^^^^ C901
32 |         """Parse a dictionary into a MidjourneyPrompt.
   |

tests/cli/test_main.py:159:89: E501 Line too long (94 > 88)
    |
157 |         "https://example.com/img1.jpg https://example.com/img2.jpg "
158 |         "a {red, blue} bird on a {branch, rock} "
159 |         f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
    |                                                                                         ^^^^^^ E501
160 |     )
161 |     with StringIO() as capture_stdout:
    |

tests/conftest.py:18:89: E501 Line too long (95 > 88)
   |
16 |         "escaped_commas": "a {red\\, blue, green} bird",
17 |         "nested": "a {big {red, blue}, small green} bird",
18 |         "multiple_images": "https://example.com/1.jpg https://example.com/2.jpg forest --iw 2",
   |                                                                                         ^^^^^^^ E501
19 |     }
   |

Found 26 errors.
============================= test session starts ==============================
platform darwin -- Python 3.12.8, pytest-8.3.4, pluggy-1.5.0
rootdir: /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/midjargon
configfile: pyproject.toml
plugins: rerunfailures-14.0, anyio-4.8.0, mock-3.14.0, xdist-3.6.1
collected 91 items

tests/cli/test_main.py FFFFFFFFFFFFFFF                                   [ 16%]
tests/core/test_input.py FFFFFFFFFFFF                                    [ 29%]
tests/core/test_parameters.py FFFFFFFFFFFFFFFF                           [ 47%]
tests/core/test_parser.py FFFFF.....                                     [ 58%]
tests/engines/midjourney/test_midjourney_parser.py FFFF.FFFF...          [ 71%]
tests/integration/test_workflow.py F.FFFF..FFFFFF                        [ 86%]
tests/test_core.py .F.F....FF.                                           [ 98%]
tests/test_package.py .                                                  [100%]

=================================== FAILURES ===================================
______________________________ test_basic_prompt _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096fa510>

    def test_basic_prompt(cli):
        """Test basic prompt processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT}",
                json_output=True,
            )
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:58: TypeError
______________________________ test_permutations _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x108babd70>

    def test_permutations(cli):
        """Test permutation processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x1096a3c40>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_raw_output ________________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096b8560>

    def test_raw_output(cli):
        """Test raw output mode."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"a photo --stylize {STYLIZE_VALUE}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:86: TypeError
_________________________ test_json_output_formatting __________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096b9070>

    def test_json_output_formatting(cli):
        """Test JSON output formatting."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:98: TypeError
______________________________ test_invalid_input ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096b9880>

    def test_invalid_input(cli):
        """Test handling of invalid input."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:110: TypeError
__________________________ test_parameter_validation ___________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096ba1e0>

    def test_parameter_validation(cli):
        """Test parameter validation."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a photo --stylize {STYLIZE_VALUE * 20}", json_output=True
            )  # Over max
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:120: TypeError
___________________________ test_image_url_handling ____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096bab70>

    def test_image_url_handling(cli):
        """Test handling of image URLs."""
        url = "https://example.com/image.jpg"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"{url} a fusion", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:133: TypeError
_____________________________ test_no_color_output _____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096bb740>

    def test_no_color_output(cli):
        """Test no-color output mode."""
        Console(force_terminal=False)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True, no_color=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:147: TypeError
_____________________________ test_complex_prompt ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x109660230>

    def test_complex_prompt(cli):
        """Test complex prompt with multiple features."""
        prompt = (
            "https://example.com/img1.jpg https://example.com/img2.jpg "
            "a {red, blue} bird on a {branch, rock} "
            f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
        )
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(prompt, json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:163: TypeError
________________________ test_personalization_parameter ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096607a0>

    def test_personalization_parameter(cli):
        """Test personalization parameter handling in different forms."""
        # Test flag form (--p)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --p", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:180: TypeError
_______________________ test_numeric_range_permutations ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x109006030>

    def test_numeric_range_permutations(cli):
        """Test handling of numeric parameters in permutations."""
        # Test stylize parameter range
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:210: TypeError
______________________ test_nested_parameter_permutations ______________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096bb320>

    def test_nested_parameter_permutations(cli):
        """Test handling of nested permutations with parameters."""
        # Test personalization with nested options
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("smooth edges {, --p {, CODE1}} --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:237: TypeError
_______________________________ test_mj_command ________________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096baf60>

    def test_mj_command(cli):
        """Test Midjourney prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.mj("a serene landscape --ar 16:9 --stylize 100", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x109672440>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_fal_command _______________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x1096ba6f0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x1096ba3f0>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0.0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096ba6f0>

    def test_fal_command(cli):
        """Test Fal.ai prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal("a serene landscape --ar 16:9 --stylize 100", json_output=True)

tests/cli/test_main.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x1096ba6f0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
______________________________ test_perm_command _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1096b91f0>

    def test_perm_command(cli):
        """Test permutation expansion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird on a {branch, rock}", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x109671840>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_basic_input _______________________________

    def test_basic_input():
        """Test basic input without permutations."""
        result = expand_midjargon_input("a simple prompt")
        assert len(result) == 1
>       assert result[0] == "a simple prompt"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a simple prompt', image_prompts=[], parameters=MidjourneyParameters(versio...on=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0) == 'a simple prompt'

tests/core/test_input.py:15: AssertionError
___________________________ test_single_permutation ____________________________

    def test_single_permutation():
        """Test input with a single permutation."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], parameters=MidjourneyParameters(version=No...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:22: AssertionError
_______________________________ test_empty_input _______________________________

    def test_empty_input():
        """Test empty input handling."""
>       result = expand_midjargon_input("")

tests/core/test_input.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:94: in expand_midjargon_input
    weighted_prompts = parse_weighted_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = ''

    def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
        """Parse a prompt with optional weights.
    
        Args:
            prompt: Raw prompt string with optional weights.
    
        Returns:
            List of (prompt, weight) tuples.
    
        Raises:
            ValueError: If prompt is empty or invalid.
        """
        if not prompt or not prompt.strip():
            msg = "Empty prompt"
>           raise ValueError(msg)
E           ValueError: Empty prompt

src/midjargon/core/input.py:23: ValueError
__________________________ test_multiple_permutations __________________________

    def test_multiple_permutations():
        """Test input with multiple permutations."""
        result = expand_midjargon_input("a {red, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_3
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], parameters=MidjourneyParameters(version=No...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:37: AssertionError
___________________________ test_nested_permutations ___________________________

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
>               results.extend(expand_permutations(new_s))

src/midjargon/core/permutations.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a red {cat'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 6

src/midjargon/core/permutations.py:119: ValueError

During handling of the above exception, another exception occurred:

    def test_nested_permutations():
        """Test input with nested permutations."""
>       result = expand_midjargon_input("a {red {cat, dog}, blue bird}")

tests/core/test_input.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:100: in expand_midjargon_input
    expanded = expand_permutations(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
                results.extend(expand_permutations(new_s))
            except Exception as e:
                msg = f"Failed to expand option '{option}': {e!s}"
>               raise ValueError(msg)
E               ValueError: Failed to expand option 'red {cat': Unclosed brace at position 6

src/midjargon/core/permutations.py:145: ValueError
_____________________________ test_escaped_braces ______________________________

    def test_escaped_braces():
        """Test input with escaped braces."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], parameters=MidjourneyParameters...on=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:55: AssertionError
_____________________________ test_escaped_commas ______________________________

    def test_escaped_commas():
        """Test input with escaped commas."""
        result = expand_midjargon_input(r"a {red\, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red, blue bird" in result
E       AssertionError: assert 'a red, blue bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red, blue bird', image_prompts=[], parameters=MidjourneyParameters(vers...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:62: AssertionError
____________________________ test_unmatched_braces _____________________________

    def test_unmatched_braces():
        """Test input with unmatched braces."""
>       result = expand_midjargon_input("a {red, blue bird")

tests/core/test_input.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:100: in expand_midjargon_input
    expanded = expand_permutations(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red, blue bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 2

src/midjargon/core/permutations.py:119: ValueError
____________________________ test_empty_permutation ____________________________

    def test_empty_permutation():
        """Test input with empty permutation options."""
>       result = expand_midjargon_input("a {} bird")

tests/core/test_input.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:100: in expand_midjargon_input
    expanded = expand_permutations(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {} bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
>           raise ValueError(msg)
E           ValueError: Empty permutation group at position 2

src/midjargon/core/permutations.py:131: ValueError
___________________________ test_whitespace_handling ___________________________

    def test_whitespace_handling():
        """Test input with various whitespace patterns."""
        result = expand_midjargon_input("a {  red  ,  blue  } bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], parameters=MidjourneyParameters(version=No...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:84: AssertionError
_________________________ test_expand_midjargon_input __________________________

    def test_expand_midjargon_input():
        """Test expand_midjargon_input function to verify prompt expansion."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == 2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], parameters=MidjourneyParameters(version=No...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:92: AssertionError
_______________________ test_handling_escaped_characters _______________________

    def test_handling_escaped_characters():
        """Test handling of escaped characters in expand_midjargon_input."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], parameters=MidjourneyParameters...on=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:112: AssertionError
_________________________ test_basic_parameter_parsing _________________________

    def test_basic_parameter_parsing():
        """Test parsing of basic parameters."""
        param_str = "--ar 16:9 --stylize 100"
        params = parse_parameters(param_str)
>       assert params["aspect"] == "16:9"
E       KeyError: 'aspect'

tests/core/test_parameters.py:13: KeyError
_____________________________ test_flag_parameters _____________________________

    def test_flag_parameters():
        """Test parsing of flag parameters (without values)."""
        param_str = "--tile --turbo --relax"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:21: AssertionError
_____________________ test_parameter_with_multiple_values ______________________

    def test_parameter_with_multiple_values():
        """Test parsing parameters that accept multiple values."""
        param_str = "--no blur,cars,watermark"
        params = parse_parameters(param_str)
>       assert params["no"] == "blur,cars,watermark"
E       AssertionError: assert ['blur,cars,watermark'] == 'blur,cars,watermark'

tests/core/test_parameters.py:30: AssertionError
__________________________ test_parameter_with_spaces __________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            if value is None:
                return True
            val_lower = value.lower()
            if val_lower in {"true", "1", "yes", "on"}:
                return True
            if val_lower in {"false", "0", "no", "off"}:
                return False
            return bool(value)
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            if value.lower() == "niji":
                return "niji"
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle seed parameter
        if param == "seed":
            if value.lower() in SPECIAL_SEED_VALUES:
                return value.lower()
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid seed value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
>                           value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )

src/midjargon/core/parameters.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            if value is None:
                return True
            val_lower = value.lower()
            if val_lower in {"true", "1", "yes", "on"}:
                return True
            if val_lower in {"false", "0", "no", "off"}:
                return False
            return bool(value)
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            if value.lower() == "niji":
                return "niji"
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle seed parameter
        if param == "seed":
            if value.lower() in SPECIAL_SEED_VALUES:
                return value.lower()
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid seed value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:144: ValueError

During handling of the above exception, another exception occurred:

    def test_parameter_with_spaces():
        """Test parsing parameters with values containing spaces."""
        param_str = '--style "raw photo" --seed 123456'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
>                       raise ValueError(msg)
E                       ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:208: ValueError
____________________________ test_mixed_parameters _____________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            if value is None:
                return True
            val_lower = value.lower()
            if val_lower in {"true", "1", "yes", "on"}:
                return True
            if val_lower in {"false", "0", "no", "off"}:
                return False
            return bool(value)
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            if value.lower() == "niji":
                return "niji"
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle seed parameter
        if param == "seed":
            if value.lower() in SPECIAL_SEED_VALUES:
                return value.lower()
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid seed value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
>                   value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )

src/midjargon/core/parameters.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            if value is None:
                return True
            val_lower = value.lower()
            if val_lower in {"true", "1", "yes", "on"}:
                return True
            if val_lower in {"false", "0", "no", "off"}:
                return False
            return bool(value)
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            if value.lower() == "niji":
                return "niji"
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle seed parameter
        if param == "seed":
            if value.lower() in SPECIAL_SEED_VALUES:
                return value.lower()
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid seed value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:144: ValueError

During handling of the above exception, another exception occurred:

    def test_mixed_parameters():
        """Test parsing a mix of different parameter types."""
        param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
                    value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )
                    result[current_param] = value
            except Exception as e:
                msg = f"Failed to parse parameter {current_param}: {e}"
>               raise ValueError(msg)
E               ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:241: ValueError
__________________________ test_shorthand_parameters ___________________________

    def test_shorthand_parameters():
        """Test parsing of shorthand parameter names."""
        param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
        params = parse_parameters(param_str)
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:55: AssertionError
_________________________ test_niji_version_parameter __________________________

    def test_niji_version_parameter():
        """Test parsing of niji version parameter."""
        # Test basic niji
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:66: AssertionError
____________________________ test_version_parameter ____________________________

    def test_version_parameter():
        """Test parsing of version parameter."""
        # Test v parameter
        params = parse_parameters("--v 5.2")
>       assert params["version"] == "5.2"
E       AssertionError: assert <MidjourneyVe....V5_2: 'v5.2'> == '5.2'
E         
E         - 5.2
E         + v5.2
E         ? +

tests/core/test_parameters.py:77: AssertionError
________________________ test_personalization_parameter ________________________

    def test_personalization_parameter():
        """Test parsing of personalization parameter."""
        # Test basic p parameter
        params = parse_parameters("--p")
>       assert params["personalization"] is None  # Flag without value is None
E       assert True is None

tests/core/test_parameters.py:84: AssertionError
__________________________ test_reference_parameters ___________________________

    def test_reference_parameters():
        """Test parsing of reference parameters."""
        param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
        params = parse_parameters(param_str)
>       assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
E       AssertionError: assert [CharacterRef..., weight=1.0)] == ['img1.jpg', 'img2.jpg']
E         
E         At index 0 diff: CharacterReference(url=None, code='img1.jpg', weight=1.0) != 'img1.jpg'
E         Use -v to get more diff

tests/core/test_parameters.py:107: AssertionError
_____________________________ test_parameter_order _____________________________

    def test_parameter_order():
        """Test that parameter order is preserved in output."""
        param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
        params = parse_parameters(param_str)
        keys = list(params.keys())
>       assert keys == ["seed", "aspect", "chaos", "tile"]
E       AssertionError: assert ['seed', 'asp...haos', 'tile'] == ['seed', 'asp...haos', 'tile']
E         
E         At index 1 diff: 'aspect_ratio' != 'aspect'
E         Use -v to get more diff

tests/core/test_parameters.py:116: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameter formats."""
>       with pytest.raises(ValueError, match="Empty parameter name"):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/core/test_parameters.py:121: Failed
________________________ test_flag_parameters_handling _________________________

    def test_flag_parameters_handling():
        """Test handling of flag parameters in parse_parameters."""
        param_str = "--tile --turbo --relax --video --remix"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:138: AssertionError
___________________________ test_special_seed_values ___________________________

    def test_special_seed_values():
        """Test handling of special seed values."""
        # Test random seed
        params = parse_parameters("--seed random")
        assert params["seed"] == "random"
    
        # Test numeric seed
        params = parse_parameters("--seed 12345")
>       assert params["seed"] == "12345"
E       AssertionError: assert 12345 == '12345'

tests/core/test_parameters.py:165: AssertionError
_________________________ test_reference_url_handling __________________________

    def test_reference_url_handling():
        """Test handling of URLs in reference parameters."""
        # Test character reference with quoted URL containing spaces
        params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
>       assert params["character_reference"] == [
            "https://example.com/image with spaces.jpg"
        ]
E       AssertionError: assert [CharacterRef..., weight=1.0)] == ['https://exa...h spaces.jpg']
E         
E         At index 0 diff: CharacterReference(url=HttpUrl('https://example.com/image%20with%20spaces.jpg'), code=None, weight=1.0) != 'https://example.com/image with spaces.jpg'
E         Use -v to get more diff

tests/core/test_parameters.py:172: AssertionError
__________________________ test_niji_version_handling __________________________

    def test_niji_version_handling():
        """Test handling of niji version parameter variations."""
        # Test basic niji
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:185: AssertionError
__________________________ test_basic_prompt_parsing ___________________________

    def test_basic_prompt_parsing():
        """Test basic prompt parsing."""
        prompt = "a beautiful landscape --ar 16:9 --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a beautiful landscape"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:18: KeyError
__________________________ test_prompt_with_image_url __________________________

    def test_prompt_with_image_url():
        """Test prompt parsing with image URL."""
        prompt = f"{IMAGE_URL} a mystical forest --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a mystical forest"
>       assert result["images"] == [IMAGE_URL]
E       KeyError: 'images'

tests/core/test_parser.py:27: KeyError
_____________________ test_prompt_with_multiple_image_urls _____________________

    def test_prompt_with_multiple_image_urls():
        """Test prompt parsing with multiple image URLs."""
        image_urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
        prompt = f"{image_urls[0]} {image_urls[1]} a serene landscape --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a serene landscape"
>       assert result["images"] == image_urls
E       KeyError: 'images'

tests/core/test_parser.py:40: KeyError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a futuristic city --ar 16:9 --stylize 100 --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a futuristic city"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:49: KeyError
______________________ test_prompt_with_empty_parameters _______________________

    def test_prompt_with_empty_parameters():
        """Test prompt parsing with empty parameters."""
        prompt = "a landscape photo --tile --no blur,cars"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a landscape photo"
>       assert result["tile"] is None
E       assert False is None

tests/core/test_parser.py:59: AssertionError
___________________________ test_numeric_parameters ____________________________

    def test_numeric_parameters():
        """Test parsing of numeric parameters."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict(
            {
                "text": "a photo",
                "stylize": str(STYLIZE_VALUE),
                "seed": str(SEED_VALUE),
                "chaos": str(CHAOS_VALUE),
            }
        )
    
        assert prompt.text == "a photo"
        assert prompt.stylize == float(STYLIZE_VALUE)
>       assert prompt.seed == SEED_VALUE
E       AssertionError: assert '12345' == 12345
E        +  where '12345' = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).seed

tests/engines/midjourney/test_midjourney_parser.py:39: AssertionError
____________________________ test_style_parameters _____________________________

    def test_style_parameters():
        """Test parsing of style parameters."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict(
            {"text": "a photo", "style": "raw", "version": VERSION_NUMBER}
        )
    
        assert prompt.text == "a photo"
        assert prompt.style == "raw"
>       assert prompt.version == f"v{VERSION_NUMBER}"
E       AssertionError: assert '5.2' == 'v5.2'
E         
E         - v5.2
E         ? -
E         + 5.2

tests/engines/midjourney/test_midjourney_parser.py:52: AssertionError
______________________________ test_aspect_ratio _______________________________

    def test_aspect_ratio():
        """Test parsing of aspect ratio."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict({"text": "a photo", "ar": "16:9"})
    
        assert prompt.text == "a photo"
>       assert prompt.aspect_width == 16
E       AssertionError: assert None == 16
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:61: AssertionError
______________________________ test_image_prompts ______________________________

    def test_image_prompts():
        """Test parsing of image prompts."""
        parser = MidjourneyParser()
        urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
        prompt = parser.parse_dict({"text": "a fusion", "image_prompts": urls})
    
        assert prompt.text == "a fusion"
        assert len(prompt.image_prompts) == 2
>       assert all(isinstance(url, HttpUrl) for url in prompt.image_prompts)
E       assert False
E        +  where False = all(<generator object test_image_prompts.<locals>.<genexpr> at 0x1096c1c40>)

tests/engines/midjourney/test_midjourney_parser.py:77: AssertionError
__________________________ test_parameter_conversion ___________________________

    def test_parameter_conversion():
        """Test parameter value conversion."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict(
            {
                "text": "a photo",
                "stylize": str(STYLIZE_VALUE),
                "seed": str(SEED_VALUE),
                "image_weight": str(IMAGE_WEIGHT_VALUE),
            }
        )
    
        assert prompt.text == "a photo"
        assert prompt.stylize == float(STYLIZE_VALUE)
>       assert prompt.seed == SEED_VALUE
E       AssertionError: assert '12345' == 12345
E        +  where '12345' = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1...peat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={'image_weight': '2.0'}), weight=1.0).seed

tests/engines/midjourney/test_midjourney_parser.py:110: AssertionError
_____________________________ test_invalid_values ______________________________

    def test_invalid_values():
        """Test handling of invalid parameter values."""
        parser = MidjourneyParser()
    
        # Invalid aspect ratio - now accepts any value
        result = parser.parse_dict({"text": "a photo", "ar": "999:999"})
>       assert result.aspect_width == 999
E       AssertionError: assert None == 999
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:120: AssertionError
______________________________ test_empty_values _______________________________

    def test_empty_values():
        """Test handling of empty values."""
        parser = MidjourneyParser()
    
        # Empty text
        with pytest.raises(ValueError, match="Empty prompt"):
            parser.parse_dict({"text": ""})
    
        # Empty image list
        prompt = parser.parse_dict({"text": "a photo", "image_prompts": []})
        assert prompt.text == "a photo"
        assert not prompt.image_prompts
    
        # None values
>       prompt = parser.parse_dict({"text": "a photo", "stylize": None})

tests/engines/midjourney/test_midjourney_parser.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x109d303b0>
prompt_dict = {}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Handle image prompts
        image_prompts = []
        raw_image_prompts = prompt_dict.pop("image_prompts", [])
        for img in raw_image_prompts:
            if isinstance(img, str):
                image_prompts.append(ImageReference(url=self._parse_url(img)))
            elif isinstance(img, dict):
                if "url" in img and isinstance(img["url"], str):
                    img["url"] = self._parse_url(img["url"])
                image_prompts.append(ImageReference(**img))
            elif isinstance(img, ImageReference):
                image_prompts.append(img)
    
        # Handle parameters
        params = MidjourneyParameters()
    
        # Handle aspect ratio
        if "ar" in prompt_dict:
            params.aspect_ratio = prompt_dict.pop("ar")
        elif "aspect_ratio" in prompt_dict:
            params.aspect_ratio = prompt_dict.pop("aspect_ratio")
        elif "aspect" in prompt_dict:
            params.aspect_ratio = prompt_dict.pop("aspect")
        elif all(k in prompt_dict for k in ["aspect_width", "aspect_height"]):
            params.aspect_width = int(prompt_dict.pop("aspect_width"))
            params.aspect_height = int(prompt_dict.pop("aspect_height"))
    
        # Handle version
        if "v" in prompt_dict:
            params.version = prompt_dict.pop("v")
        elif "version" in prompt_dict:
            params.version = prompt_dict.pop("version")
    
        # Handle style
        if "style" in prompt_dict:
            params.style = prompt_dict.pop("style")
    
        # Handle numeric parameters
        if "s" in prompt_dict:
            params.stylize = float(prompt_dict.pop("s"))
        elif "stylize" in prompt_dict:
>           params.stylize = float(prompt_dict.pop("stylize"))
E           TypeError: float() argument must be a string or a real number, not 'NoneType'

src/midjargon/engines/midjourney/midjourney.py:90: TypeError
____________________________ test_version_parameter ____________________________

    def test_version_parameter():
        """Test parsing of version parameter."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict(
            {
                "text": "a photo",
                "version": "6",
            }
        )
    
        assert prompt.text == "a photo"
>       assert prompt.version == "v6"
E       AssertionError: assert '6' == 'v6'
E         
E         - v6
E         + 6

tests/engines/midjourney/test_midjourney_parser.py:160: AssertionError
_____________________________ test_basic_workflow ______________________________

    def test_basic_workflow():
        """Test basic prompt processing workflow."""
        prompt = "a portrait --ar 16:9 --stylize 200"
        results = process_prompt(prompt)
    
        assert len(results) == 1
        assert results[0]["text"] == "a portrait"
>       assert results[0]["aspect_ratio"] == "16:9"
E       AssertionError: assert None == '16:9'

tests/integration/test_workflow.py:39: AssertionError
_____________________________ test_image_workflow ______________________________

    def test_image_workflow():
        """Test workflow with image URLs."""
        prompt = "https://example.com/image.jpg a portrait"
        results = process_prompt(prompt)
    
        assert len(results) == 1
>       assert len(results[0]["image_prompts"]) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/integration/test_workflow.py:59: AssertionError
___________________________ test_parameter_workflow ____________________________

    def test_parameter_workflow():
        """Test workflow with various parameters."""
        prompt = "portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
        results = process_prompt(prompt)
    
        assert len(results) == 1
        assert results[0]["text"] == "portrait"
>       assert results[0]["aspect_ratio"] == "16:9"
E       AssertionError: assert None == '16:9'

tests/integration/test_workflow.py:70: AssertionError
_________________________ test_new_parameters_workflow _________________________

    def test_new_parameters_workflow():
        """Test workflow with newer parameters."""
        prompt = "portrait --cref https://example.com/char.jpg --cw 50"
        results = process_prompt(prompt)
    
        assert len(results) == 1
>       assert len(results[0]["character_reference"]) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/integration/test_workflow.py:82: AssertionError
________________________ test_weighted_prompts_workflow ________________________

    def test_weighted_prompts_workflow():
        """Test workflow with weighted prompts."""
        prompt = "first prompt::0.7 second prompt::0.3"
        results = process_prompt(prompt)
    
        assert len(results) == 2
        weights = [r.get("weight", 1.0) for r in results]
>       assert 0.7 in weights
E       assert 0.7 in [1.0, 1.0]

tests/integration/test_workflow.py:93: AssertionError
______________________ test_permutations_with_parameters _______________________

    def test_permutations_with_parameters():
        """Test permutations with parameters."""
        prompt = "photo {modern, vintage} --ar {1:1, 16:9} --s 100"
        results = process_prompt(prompt)
    
        # Convert results to set of tuples for easier comparison
        result_tuples = {
            (r["text"].strip(), r["aspect_ratio"], r["stylize"]) for r in results
        }
    
        expected = {
            ("photo modern", "1:1", 100),
            ("photo modern", "16:9", 100),
            ("photo vintage", "1:1", 100),
            ("photo vintage", "16:9", 100),
        }
>       assert result_tuples == expected
E       AssertionError: assert {('photo mode... None, 100.0)} == {('photo mode..., '1:1', 100)}
E         
E         Extra items in the left set:
E         ('photo vintage', None, 100.0)
E         ('photo modern', None, 100.0)
E         Extra items in the right set:
E         ('photo vintage', '16:9', 100)
E         ('photo modern', '1:1', 100)...
E         
E         ...Full output truncated (3 lines hidden), use '-vv' to show

tests/integration/test_workflow.py:139: AssertionError
____________________ test_permutations_with_flag_parameters ____________________

    def test_permutations_with_flag_parameters():
        """Test permutations with flag parameters (no value) are handled correctly."""
        prompt = "photo {, --tile} {, --turbo}"
        results = process_prompt(prompt)
    
        # Convert results to set of tuples for easier comparison
        result_tuples = {
            (r["text"].strip(), r.get("tile", False), r.get("turbo", False))
            for r in results
        }
    
        expected = {
            ("photo", False, False),
            ("photo", False, True),
            ("photo", True, False),
            ("photo", True, True),
        }
>       assert result_tuples == expected
E       AssertionError: assert {('photo', False, False)} == {('photo', Fa..., True, True)}
E         
E         Extra items in the right set:
E         ('photo', True, True)
E         ('photo', False, True)
E         ('photo', True, False)
E         Use -v to get more diff

tests/integration/test_workflow.py:159: AssertionError
__________________ test_permutations_with_complex_parameters ___________________

    def test_permutations_with_complex_parameters():
        """Test permutations with complex parameter combinations."""
        prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
        results = process_prompt(prompt)
    
        # Convert results to set of tuples for easier comparison
        result_tuples = {
            (
                r["text"].strip(),
                (
                    r["personalization"][0]
                    if isinstance(r.get("personalization", []), list)
                    else r.get("personalization")
                ),
                f"{r['aspect_width']}:{r['aspect_height']}",
                r["stylize"],
            )
            for r in results
        }
    
        expected = {
            ("portrait modern", None, "1:1", 100),
            ("portrait modern", "custom", "1:1", 100),
            ("portrait modern", None, "16:9", 100),
            ("portrait modern", "custom", "16:9", 100),
            ("portrait vintage", None, "1:1", 100),
            ("portrait vintage", "custom", "1:1", 100),
            ("portrait vintage", None, "16:9", 100),
            ("portrait vintage", "custom", "16:9", 100),
        }
>       assert result_tuples == expected
E       AssertionError: assert {('portrait m...None', 100.0)} == {('portrait m...9', 100), ...}
E         
E         Extra items in the left set:
E         ('portrait vintage', False, 'None:None', 100.0)
E         ('portrait modern', False, 'None:None', 100.0)
E         Extra items in the right set:
E         ('portrait modern', None, '1:1', 100)
E         ('portrait modern', 'custom', '16:9', 100)...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

tests/integration/test_workflow.py:192: AssertionError
_____________________________ test_cli_mj_command ______________________________

    def test_cli_mj_command():
        """Test Midjourney prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.mj(prompt, json_output=True)
            sys.stdout = sys.__stdout__
            output = capture_stdout.getvalue()
>       assert "serene landscape" in output
E       AssertionError: assert 'serene landscape' in ''

tests/integration/test_workflow.py:204: AssertionError
_____________________________ test_cli_fal_command _____________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x109d42d20>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x109d42b40>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0.0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

    def test_cli_fal_command():
        """Test Fal.ai prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal(prompt, json_output=True)

tests/integration/test_workflow.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x109d42d20>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
____________________________ test_cli_perm_command _____________________________

    def test_cli_perm_command():
        """Test permutation expansion using CLI."""
        cli = MidjargonCLI()
        prompt = "a {red, blue} bird on a {branch, rock}"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm(prompt, json_output=True)
            sys.stdout = sys.__stdout__
            output = capture_stdout.getvalue()
>       assert "red" in output
E       AssertionError: assert 'red' in ''

tests/integration/test_workflow.py:232: AssertionError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
        result = parse_midjargon_prompt(prompt)
    
        assert result.text == "a portrait"
>       assert result.parameters.aspect == "16:9"
E       AssertionError: assert None == '16:9'
E        +  where None = MidjourneyParameters(version=None, style=None, stylize=100.0, chaos=0.0, weird=0.0, seed=None, aspect_width=None, aspe...e_weight=None, style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}).aspect
E        +    where MidjourneyParameters(version=None, style=None, stylize=100.0, chaos=0.0, weird=0.0, seed=None, aspect_width=None, aspe...e_weight=None, style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}) = MidjourneyPrompt(text='a portrait', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, styliz..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).parameters

tests/test_core.py:31: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameters."""
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_core.py:49: Failed
_____________________________ test_style_reference _____________________________

    def test_style_reference():
        """Test handling of style references."""
        # Test with code
        prompt = "test --sref p123456"
        result = parse_midjargon_prompt(prompt)
>       assert result.style_reference
E       AssertionError: assert []
E        +  where [] = MidjourneyPrompt(text='test', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=100...., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).style_reference

tests/test_core.py:109: AssertionError
___________________________ test_character_reference ___________________________

    def test_character_reference():
        """Test handling of character references."""
        prompt = "test --cref https://example.com/char.jpg --cw 50"
        result = parse_midjargon_prompt(prompt)
    
>       assert result.character_reference
E       AssertionError: assert []
E        +  where [] = MidjourneyPrompt(text='test', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=100...., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).character_reference

tests/test_core.py:124: AssertionError
=========================== short test summary info ============================
FAILED tests/cli/test_main.py::test_basic_prompt - TypeError: MidjargonCLI.js...
FAILED tests/cli/test_main.py::test_permutations - ValueError: No JSON found ...
FAILED tests/cli/test_main.py::test_raw_output - TypeError: MidjargonCLI.json...
FAILED tests/cli/test_main.py::test_json_output_formatting - TypeError: Midja...
FAILED tests/cli/test_main.py::test_invalid_input - TypeError: MidjargonCLI.j...
FAILED tests/cli/test_main.py::test_parameter_validation - TypeError: Midjarg...
FAILED tests/cli/test_main.py::test_image_url_handling - TypeError: Midjargon...
FAILED tests/cli/test_main.py::test_no_color_output - TypeError: MidjargonCLI...
FAILED tests/cli/test_main.py::test_complex_prompt - TypeError: MidjargonCLI....
FAILED tests/cli/test_main.py::test_personalization_parameter - TypeError: Mi...
FAILED tests/cli/test_main.py::test_numeric_range_permutations - TypeError: M...
FAILED tests/cli/test_main.py::test_nested_parameter_permutations - TypeError...
FAILED tests/cli/test_main.py::test_mj_command - ValueError: No JSON found in...
FAILED tests/cli/test_main.py::test_fal_command - SystemExit: 1
FAILED tests/cli/test_main.py::test_perm_command - ValueError: No JSON found ...
FAILED tests/core/test_input.py::test_basic_input - AssertionError: assert Pr...
FAILED tests/core/test_input.py::test_single_permutation - AssertionError: as...
FAILED tests/core/test_input.py::test_empty_input - ValueError: Empty prompt
FAILED tests/core/test_input.py::test_multiple_permutations - AssertionError:...
FAILED tests/core/test_input.py::test_nested_permutations - ValueError: Faile...
FAILED tests/core/test_input.py::test_escaped_braces - AssertionError: assert...
FAILED tests/core/test_input.py::test_escaped_commas - AssertionError: assert...
FAILED tests/core/test_input.py::test_unmatched_braces - ValueError: Unclosed...
FAILED tests/core/test_input.py::test_empty_permutation - ValueError: Empty p...
FAILED tests/core/test_input.py::test_whitespace_handling - AssertionError: a...
FAILED tests/core/test_input.py::test_expand_midjargon_input - AssertionError...
FAILED tests/core/test_input.py::test_handling_escaped_characters - Assertion...
FAILED tests/core/test_parameters.py::test_basic_parameter_parsing - KeyError...
FAILED tests/core/test_parameters.py::test_flag_parameters - assert True is None
FAILED tests/core/test_parameters.py::test_parameter_with_multiple_values - A...
FAILED tests/core/test_parameters.py::test_parameter_with_spaces - ValueError...
FAILED tests/core/test_parameters.py::test_mixed_parameters - ValueError: Fai...
FAILED tests/core/test_parameters.py::test_shorthand_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_niji_version_parameter - Assertion...
FAILED tests/core/test_parameters.py::test_version_parameter - AssertionError...
FAILED tests/core/test_parameters.py::test_personalization_parameter - assert...
FAILED tests/core/test_parameters.py::test_reference_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_parameter_order - AssertionError: ...
FAILED tests/core/test_parameters.py::test_invalid_parameters - Failed: DID N...
FAILED tests/core/test_parameters.py::test_flag_parameters_handling - assert ...
FAILED tests/core/test_parameters.py::test_special_seed_values - AssertionErr...
FAILED tests/core/test_parameters.py::test_reference_url_handling - Assertion...
FAILED tests/core/test_parameters.py::test_niji_version_handling - AssertionE...
FAILED tests/core/test_parser.py::test_basic_prompt_parsing - KeyError: 'aspect'
FAILED tests/core/test_parser.py::test_prompt_with_image_url - KeyError: 'ima...
FAILED tests/core/test_parser.py::test_prompt_with_multiple_image_urls - KeyE...
FAILED tests/core/test_parser.py::test_prompt_with_parameters - KeyError: 'as...
FAILED tests/core/test_parser.py::test_prompt_with_empty_parameters - assert ...
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_numeric_parameters
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_style_parameters
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_aspect_ratio
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_image_prompts
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_parameter_conversion
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_invalid_values
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_empty_values
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_version_parameter
FAILED tests/integration/test_workflow.py::test_basic_workflow - AssertionErr...
FAILED tests/integration/test_workflow.py::test_image_workflow - assert 0 == 1
FAILED tests/integration/test_workflow.py::test_parameter_workflow - Assertio...
FAILED tests/integration/test_workflow.py::test_new_parameters_workflow - ass...
FAILED tests/integration/test_workflow.py::test_weighted_prompts_workflow - a...
FAILED tests/integration/test_workflow.py::test_permutations_with_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_flag_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_complex_parameters
FAILED tests/integration/test_workflow.py::test_cli_mj_command - AssertionErr...
FAILED tests/integration/test_workflow.py::test_cli_fal_command - SystemExit: 1
FAILED tests/integration/test_workflow.py::test_cli_perm_command - AssertionE...
FAILED tests/test_core.py::test_prompt_with_parameters - AssertionError: asse...
FAILED tests/test_core.py::test_invalid_parameters - Failed: DID NOT RAISE <c...
FAILED tests/test_core.py::test_style_reference - AssertionError: assert []
FAILED tests/test_core.py::test_character_reference - AssertionError: assert []
======================== 71 failed, 20 passed in 3.43s =========================
</file>

<file path="package.toml">
# Package configuration
[package]
include_cli = true      # Include CLI boilerplate
include_logging = true  # Include logging setup
use_pydantic = true     # Use Pydantic for data validation
use_rich = true         # Use Rich for terminal output

[features]
mkdocs = false          # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows
</file>

<file path="TODO2.md">
# TODO
</file>

<file path="src/midjargon/engines/midjourney/parser/__init__.py">
"""
Midjourney parser package.
"""

from midjargon.engines.midjourney.parser.core import MidjourneyParser
from midjargon.engines.midjourney.parser.exceptions import (
    ParameterValidationError, ParserError, ValidationError)
from midjargon.engines.midjourney.parser.parameters import ParameterHandler
from midjargon.engines.midjourney.parser.validation import ValidatorRegistry

__all__ = [
    "MidjourneyParser",
    "ParameterHandler",
    "ParameterValidationError",
    "ParserError",
    "ValidationError",
    "ValidatorRegistry",
]
</file>

<file path="src/midjargon/engines/midjourney/parser/parameters.py">
"""
Parameter handling for the Midjourney parser.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any, TypeVar

from midjargon.engines.midjourney.constants import (CHAOS_RANGE,
                                                    CHARACTER_WEIGHT_RANGE,
                                                    DEFAULT_CHAOS,
                                                    DEFAULT_CHARACTER_WEIGHT,
                                                    DEFAULT_IMAGE_WEIGHT,
                                                    DEFAULT_QUALITY,
                                                    DEFAULT_STOP,
                                                    DEFAULT_STYLE_VERSION,
                                                    DEFAULT_STYLIZE,
                                                    DEFAULT_WEIRD,
                                                    IMAGE_WEIGHT_RANGE,
                                                    QUALITY_RANGE,
                                                    REPEAT_RANGE, SEED_RANGE,
                                                    STOP_RANGE,
                                                    STYLE_VERSION_RANGE,
                                                    STYLE_WEIGHT_RANGE,
                                                    STYLIZE_RANGE, WEIRD_RANGE)
from midjargon.engines.midjourney.parser.exceptions import \
    ParameterValidationError
from midjargon.engines.midjourney.parser.validation import ValidatorRegistry

if TYPE_CHECKING:
    from collections.abc import Callable

T = TypeVar("T")


@dataclass(frozen=True)
class ParameterConfig:
    """Configuration for a parameter."""

    name: str
    handler: Callable[[str], Any]
    validator: Callable[[Any], bool]
    default: Any
    aliases: list[str] = field(default_factory=list)
    range: tuple[float, float] | None = None


def handle_integer(value: str) -> int:
    """Convert string value to integer.

    Args:
        value: String value to convert

    Returns:
        Integer value

    Raises:
        ValueError: If conversion fails
    """
    return int(float(value))


def handle_float(value: str) -> float:
    """Convert string value to float.

    Args:
        value: String value to convert

    Returns:
        Float value

    Raises:
        ValueError: If conversion fails
    """
    return float(value)


class ParameterHandler:
    """Handler for parameter processing."""

    def __init__(self) -> None:
        """Initialize parameter handler."""
        self.validators = ValidatorRegistry()
        self._init_parameter_configs()
        self.flag_params = {
            "turbo",
            "relax",
            "tile",
            "p",
            "personalization",
        }

    def _init_parameter_configs(self) -> None:
        """Initialize parameter configurations."""
        self.configs: dict[str, ParameterConfig] = {
            "stylize": ParameterConfig(
                name="stylize",
                handler=handle_integer,
                validator=lambda v: self.validators.validate(
                    "range", v, *STYLIZE_RANGE
                ),
                default=DEFAULT_STYLIZE,
                aliases=["s"],
                range=STYLIZE_RANGE,
            ),
            "chaos": ParameterConfig(
                name="chaos",
                handler=handle_integer,
                validator=lambda v: self.validators.validate("range", v, *CHAOS_RANGE),
                default=DEFAULT_CHAOS,
                aliases=["c"],
                range=CHAOS_RANGE,
            ),
            "weird": ParameterConfig(
                name="weird",
                handler=handle_integer,
                validator=lambda v: self.validators.validate("range", v, *WEIRD_RANGE),
                default=DEFAULT_WEIRD,
                aliases=["w"],
                range=WEIRD_RANGE,
            ),
            "image_weight": ParameterConfig(
                name="image_weight",
                handler=handle_float,
                validator=lambda v: self.validators.validate(
                    "range", v, *IMAGE_WEIGHT_RANGE
                ),
                default=DEFAULT_IMAGE_WEIGHT,
                aliases=["iw"],
                range=IMAGE_WEIGHT_RANGE,
            ),
            "quality": ParameterConfig(
                name="quality",
                handler=handle_float,
                validator=lambda v: self.validators.validate(
                    "range", v, *QUALITY_RANGE
                ),
                default=DEFAULT_QUALITY,
                aliases=["q"],
                range=QUALITY_RANGE,
            ),
            "character_weight": ParameterConfig(
                name="character_weight",
                handler=handle_float,
                validator=lambda v: self.validators.validate(
                    "range", v, *CHARACTER_WEIGHT_RANGE
                ),
                default=DEFAULT_CHARACTER_WEIGHT,
                aliases=["cw"],
                range=CHARACTER_WEIGHT_RANGE,
            ),
            "style_weight": ParameterConfig(
                name="style_weight",
                handler=handle_float,
                validator=lambda v: self.validators.validate(
                    "range", v, *STYLE_WEIGHT_RANGE
                ),
                default=None,
                aliases=["sw"],
                range=STYLE_WEIGHT_RANGE,
            ),
            "style_version": ParameterConfig(
                name="style_version",
                handler=handle_integer,
                validator=lambda v: self.validators.validate(
                    "range", v, *STYLE_VERSION_RANGE
                ),
                default=DEFAULT_STYLE_VERSION,
                aliases=["sv"],
                range=STYLE_VERSION_RANGE,
            ),
            "repeat": ParameterConfig(
                name="repeat",
                handler=handle_integer,
                validator=lambda v: self.validators.validate("range", v, *REPEAT_RANGE),
                default=None,
                aliases=["r"],
                range=REPEAT_RANGE,
            ),
            "seed": ParameterConfig(
                name="seed",
                handler=handle_integer,
                validator=lambda v: self.validators.validate("range", v, *SEED_RANGE),
                default=None,
                range=SEED_RANGE,
            ),
            "stop": ParameterConfig(
                name="stop",
                handler=handle_integer,
                validator=lambda v: self.validators.validate("range", v, *STOP_RANGE),
                default=DEFAULT_STOP,
                range=STOP_RANGE,
            ),
        }

    def process(self, param_name: str, raw_value: Any) -> Any:
        """Process a parameter value.

        Args:
            param_name: Name of the parameter
            raw_value: Raw value to process

        Returns:
            Processed value

        Raises:
            ParameterValidationError: If validation fails
        """
        # Handle flag parameters
        if param_name in self.flag_params:
            if raw_value is None:
                return True
            return bool(raw_value)

        # Get parameter config
        config = self._get_config(param_name)
        if not config:
            return raw_value

        # Handle None values
        if raw_value is None:
            return None

        try:
            # Convert value
            value = config.handler(str(raw_value))
        except ValueError as e:
            msg = f"Invalid numeric value: {e!s}"
            raise ParameterValidationError(param_name, str(raw_value), msg) from e

        # Validate value
        if not config.validator(value):
            if config.range:
                msg = f"Invalid numeric value for {param_name}: {raw_value} - Value must be between {config.range[0]} and {config.range[1]}"
            else:
                msg = f"Invalid numeric value for {param_name}: {raw_value}"
            raise ParameterValidationError(param_name, str(raw_value), msg)

        return value

    def _get_config(self, param_name: str) -> ParameterConfig | None:
        """Get parameter configuration.

        Args:
            param_name: Name of the parameter

        Returns:
            Parameter configuration or None if not found
        """
        # Check direct name match
        if param_name in self.configs:
            return self.configs[param_name]

        # Check aliases
        for config in self.configs.values():
            if param_name in config.aliases:
                return config

        return None

    def get_default(self, param_name: str) -> Any:
        """Get default value for a parameter.

        Args:
            param_name: Name of the parameter

        Returns:
            Default value for the parameter
        """
        config = self._get_config(param_name)
        return config.default if config else None
</file>

<file path="tests/core/test_parser.py">
"""Tests for prompt parsing functionality."""

from midjargon.core.parser import parse_midjargon_prompt_to_dict

# Test constants
ASPECT_RATIO = "16:9"
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
IMAGE_URL = "https://example.com/image.jpg"


def test_basic_prompt_parsing():
    """Test basic prompt parsing."""
    prompt = "a beautiful landscape --ar 16:9 --stylize 100"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a beautiful landscape"
    assert result["aspect"] == ASPECT_RATIO
    assert result["stylize"] == STYLIZE_VALUE


def test_prompt_with_image_url():
    """Test prompt parsing with image URL."""
    prompt = f"{IMAGE_URL} a mystical forest --chaos 50"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a mystical forest"
    assert result["images"] == [IMAGE_URL]
    assert result["chaos"] == CHAOS_VALUE


def test_prompt_with_multiple_image_urls():
    """Test prompt parsing with multiple image URLs."""
    image_urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = f"{image_urls[0]} {image_urls[1]} a serene landscape --stylize 100"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a serene landscape"
    assert result["images"] == image_urls
    assert result["stylize"] == STYLIZE_VALUE


def test_prompt_with_parameters():
    """Test prompt parsing with various parameters."""
    prompt = "a futuristic city --ar 16:9 --stylize 100 --chaos 50"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a futuristic city"
    assert result["aspect"] == ASPECT_RATIO
    assert result["stylize"] == STYLIZE_VALUE
    assert result["chaos"] == CHAOS_VALUE


def test_prompt_with_empty_parameters():
    """Test prompt parsing with empty parameters."""
    prompt = "a landscape photo --tile --no blur,cars"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a landscape photo"
    assert result["tile"] is None
    assert result["no"] == "blur,cars"


def test_prompt_with_escaped_characters():
    """Test prompt parsing with escaped characters."""
    prompt = r"a \{red, blue\} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == r"a \{red, blue\} bird"


def test_prompt_with_nested_permutations():
    """Test prompt parsing with nested permutations."""
    prompt = "a {big {red, blue}, small green} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {big {red, blue}, small green} bird"


def test_prompt_with_unmatched_braces():
    """Test prompt parsing with unmatched braces."""
    prompt = "a {red, blue bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {red, blue bird"


def test_prompt_with_empty_permutation():
    """Test prompt parsing with empty permutation options."""
    prompt = "a {} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {} bird"


def test_prompt_with_whitespace_handling():
    """Test prompt parsing with various whitespace patterns."""
    prompt = "a {  red  ,  blue  } bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a { red , blue } bird"
</file>

<file path="tests/test_package.py">
"""Test suite for midjargon."""


def test_version():
    """Verify package exposes version."""
    import midjargon

    assert midjargon.__version__
</file>

<file path="midjargon.txt">
# Folder Tree Structure

.
 ERRORS.txt
 LICENSE
 LOG.md
 README.md
 TODO.md
 dist
 docs
  specification.md
 examples
  basic_usage.py
 package.toml
 pyproject.toml
 src
  midjargon
      __init__.py
      cli
       __init__.py
       main.py
      core
       __init__.py
       input.py
       main.py
       models.py
       parameters.py
       parser.py
       permutations.py
      engines
          __init__.py
          fal
           __init__.py
           fal.py
          midjourney
              __init__.py
              midjourney.py
              parser.py
 test-cases
  prompts-fal.txt
  prompts-in.txt
  prompts-json.txt
  prompts-mj.txt
  prompts-out.txt
  prompts-perm.txt
  prompts.sh
 tests
  __init__.py
  cli
   __init__.py
   test_main.py
  conftest.py
  core
   __init__.py
   test_input.py
   test_parameters.py
   test_parser.py
  engines
   __init__.py
   midjourney
       __init__.py
       test_midjourney_parser.py
  integration
   __init__.py
   test_workflow.py
  test_core.py
  test_package.py
 updateme.sh

18 directories, 48 files



# Folder: .

## File: .cursor/rules/midjargon.mdc (Size: 3.50 KB)

```
---
description: "Midjargon configuration documentation for folder structure."
globs: []
---

Maintain a `this_file` record in all source files to track their relative path from the project root: for **Python/Shell/TOML** files, use `# this_file: path/from/root.ext` as the first comment (after any shebang line `#!`), and for **Markdown** files, include `this_file: path/from/root.md` in the YAML front matter block at the document start. Update paths when moving files. Keep the entry as the first metadata element. Use Unix-style `/` path separators. Omit leading `./` in paths. *Example:* A Python file in `src/utils` would start with `#!/usr/bin/env python3\n# this_file: src/utils/helpers.py`.

# `midjargon`

`midjargon` is a hatch-managed Python library for parsing and manipulating Midjourney prompts using a specialized syntax. This tool helps you work with Midjourney prompts in a structured way, handling complex features like permutations, parameter validation, and image URL extraction.

<guidelines for python>
1. WHEN YOU WRITE PYTHON: 

a. CORE STYLE: Follow PEP 8 for consistent formatting & naming. Write clear, descriptive names for functions & variables. Keep code simple & explicit (PEP 20). Prioritize readability over cleverness. 
b. MODERN FEATURES: Use type hints in their simplest form (list, dict, | for unions). Write clear, imperative docstrings (PEP 257). Employ f-strings for string formatting. Use structural pattern matching where appropriate. 
c. CODE STRUCTURE: Extract repeated logic into focused functions. Handle errors explicitly and gracefully. Keep functions small and single-purpose. Prefer flat over nested structures. 
d. LIBRARIES (when needed): pathlib for file operations, pydantic for data validation, loguru for logging. Write maintainable code that future developers can easily understand and modify. 
e. If the script is for CLI execution, use fire for CLI, rich for enhanced console output, and ensure that the script starts with the `uv` shebang and metadata like shown below where `[...]` is a list of Python dependency specifiers, like `["fire", "rich"]`: 

```
#!/usr/bin/env -S uv run 
# /// script
# dependencies = [...]
# ///
```

f. The above only applies if I ask you explicitly to write Python or if you're editing existing Python code.
</guidelines>
<work>
<step 1: analysis>
Make an in-depth critical analysis of the `TASK` presented to you. Read the content of the @TODO.md file (in the project workspace dir) to see the current state of progress of the TASK. Then make an in-depth critical analysis of the inputs presented. 
</step>
<step 2: gather up-to-date insights>
Consult the @Web if you can. Consult the most up-to-date @Docs and run `sh updateme.sh`. 
</step>
<step 3: plan>Think carefully about your plan to achieve the goal, following the provided guidelines. Write out general principles, then propose specific changes. 
</step>
<step 4: pre-implementation>
Once youve analyzed the TASK request and the inputs, youve gathered up-to-date insights and ran the tests and checks and once youve made a careful plan  write the entire plan into the file @LOG.md (in the project workspace folder)  be very detailed and specific. 
</step>
<step 5: implementation>
You can start implementing the plan. Whenever youve made larger edits to Python files, run `sh updateme.sh` to see how your changes impacted the @Codebase , then refine your plan. Keep progress documentation in @LOG.md (in the project workspace folder) , remove completed items. Work until you CLEAR the @TODO.md !     
</step>
</work>
```

## File: .github/copilot-instructions.md (Size: 3.42 KB)

```

Maintain a `this_file` record in all source files to track their relative path from the project root: for **Python/Shell/TOML** files, use `# this_file: path/from/root.ext` as the first comment (after any shebang line `#!`), and for **Markdown** files, include `this_file: path/from/root.md` in the YAML front matter block at the document start. Update paths when moving files. Keep the entry as the first metadata element. Use Unix-style `/` path separators. Omit leading `./` in paths. *Example:* A Python file in `src/utils` would start with `#!/usr/bin/env python3\n# this_file: src/utils/helpers.py`.

# `midjargon`

`midjargon` is a hatch-managed Python library for parsing and manipulating Midjourney prompts using a specialized syntax. This tool helps you work with Midjourney prompts in a structured way, handling complex features like permutations, parameter validation, and image URL extraction.

<guidelines for python>
1. WHEN YOU WRITE PYTHON: 

a. CORE STYLE: Follow PEP 8 for consistent formatting & naming. Write clear, descriptive names for functions & variables. Keep code simple & explicit (PEP 20). Prioritize readability over cleverness. 
b. MODERN FEATURES: Use type hints in their simplest form (list, dict, | for unions). Write clear, imperative docstrings (PEP 257). Employ f-strings for string formatting. Use structural pattern matching where appropriate. 
c. CODE STRUCTURE: Extract repeated logic into focused functions. Handle errors explicitly and gracefully. Keep functions small and single-purpose. Prefer flat over nested structures. 
d. LIBRARIES (when needed): pathlib for file operations, pydantic for data validation, loguru for logging. Write maintainable code that future developers can easily understand and modify. 
e. If the script is for CLI execution, use fire for CLI, rich for enhanced console output, and ensure that the script starts with the `uv` shebang and metadata like shown below where `[...]` is a list of Python dependency specifiers, like `["fire", "rich"]`: 

```
#!/usr/bin/env -S uv run 
# /// script
# dependencies = [...]
# ///
```

f. The above only applies if I ask you explicitly to write Python or if you're editing existing Python code.
</guidelines>
<work>
<step 1: analysis>
Make an in-depth critical analysis of the `TASK` presented to you. Read the content of the @TODO.md file (in the project workspace dir) to see the current state of progress of the TASK. Then make an in-depth critical analysis of the inputs presented. 
</step>
<step 2: gather up-to-date insights>
Consult the @Web if you can. Consult the most up-to-date @Docs and run `sh updateme.sh`. 
</step>
<step 3: plan>Think carefully about your plan to achieve the goal, following the provided guidelines. Write out general principles, then propose specific changes. 
</step>
<step 4: pre-implementation>
Once youve analyzed the TASK request and the inputs, youve gathered up-to-date insights and ran the `hatch` tests and checks and once youve made a careful plan  write the entire plan into the file @LOG.md (in the project workspace folder)  be very detailed and specific. 
</step>
<step 5: implementation>
You can start implementing the plan. Whenever youve made larger edits to Python files, run `sh updateme.sh` to see how your changes impacted the @Codebase , then refine your plan. Keep progress documentation in @LOG.md (in the project workspace folder) , remove completed items. Work until you CLEAR the @TODO.md !     
</step>
</work>
```

## File: .github/workflows/push.yml (Size: 2.70 KB)

```
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/midjargon --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
```

## File: .github/workflows/release.yml (Size: 1.41 KB)

```
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/midjargon
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## File: .gitignore (Size: 3.42 KB)

```
!**/[Pp]ackages/build/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!?*.[Cc]ache/
!Directory.Build.rsp
!dist/.gitkeep
$tf/
*$py.class
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
**/[Pp]ackages/*
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim.layout
*.bim_*.settings
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.cover
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.egg
*.egg-info/
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.py,cover
*.py[cod]
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.swo
*.swp
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
*_autogen/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*~
.*crunch*.local.xml
._*
.axoCover/*
.builds
.cache
.coverage
.coverage.*
.cr/personal
.DS_Store
.DS_Store?
.eggs/
.env
.fake/
.history/
.hypothesis/
.idea/
.installed.cfg
.ionide/
.localhistory/
.mfractor/
.mypy_cache/
.nox/
.ntvs_analysis.dat
.paket/paket.exe
.pytest_cache/
.Python
.ruff_cache/
.sass-cache/
.Spotlight-V100
.tox/
.Trashes
.venv
.vs/
.vscode
.vscode/
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
__pycache__/
__version__.py
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
build/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
cover/
coverage*.info
coverage*.json
coverage*.xml
coverage.xml
csx/
CTestTestfile.cmake
develop-eggs/
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
downloads/
ecf/
eggs/
ehthumbs.db
env.bak/
env/
ENV/
FakesAssemblies/
FodyWeavers.xsd
Generated\ Files/
Generated_Code/
healthchecksdb
htmlcov/
install_manifest.txt
ipch/
lib/
lib64/
Makefile
MANIFEST
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nosetests.xml
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
parts/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
sdist/
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
Thumbs.db
UpgradeLog*.htm
UpgradeLog*.XML
var/
venv.bak/
venv/
wheels/
x64/
x86/
~$*
.aider*
/_private

_private
```

## File: .pre-commit-config.yaml (Size: 0.52 KB)

```
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
```

## File: ERRORS.txt (Size: 105.21 KB)

```
cmd [1] | fd -e py -x pyupgrade --keep-runtime-typing --py310-plus
cmd [2] | ruff format .
32 files left unchanged
cmd [3] | ruff check --fix --unsafe-fixes .
src/midjargon/core/input.py:9:5: C901 `parse_weighted_prompt` is too complex (13 > 10)
   |
 9 | def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
   |     ^^^^^^^^^^^^^^^^^^^^^ C901
10 |     """Parse a prompt with optional weights.
   |

src/midjargon/core/input.py:54:89: E501 Line too long (92 > 88)
   |
52 |                     raise ValueError(msg)
53 |             except ValueError as e:
54 |                 msg = f"Invalid weight at position {weight_start}: {prompt[weight_start:i]}"
   |                                                                                         ^^^^ E501
55 |                 raise ValueError(msg) from e
   |

src/midjargon/core/input.py:82:89: E501 Line too long (101 > 88)
   |
81 | def expand_midjargon_input(prompt: str) -> list[PromptVariant]:
82 |     """Expand a midjourney prompt by processing permutations and returning a list of prompt variants.
   |                                                                                         ^^^^^^^^^^^^^ E501
83 |
84 |     Args:
   |

src/midjargon/core/models.py:32:9: C901 `_missing_` is too complex (16 > 10)
   |
31 |     @classmethod
32 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ C901
33 |         """Handle missing values by trying to normalize the input."""
34 |         try:
   |

src/midjargon/core/models.py:179:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
177 |             except ValueError as e:
178 |                 msg = f"Invalid aspect ratio format: {e}"
179 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^ B904
180 |         return v
    |

src/midjargon/core/models.py:197:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
195 |             except ValueError:
196 |                 msg = f"Invalid version value: {v}"
197 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^ B904
198 |         return v
    |

src/midjargon/core/models.py:213:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
211 |             except ValueError:
212 |                 msg = f"Invalid seed value: {v}"
213 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^ B904
214 |         return v
    |

src/midjargon/core/models.py:225:9: C901 `to_string` is too complex (32 > 10)
    |
223 |         return None
224 |
225 |     def to_string(self) -> str:
    |         ^^^^^^^^^ C901
226 |         """Convert parameters to string format."""
227 |         parts = []
    |

src/midjargon/core/parameters.py:68:5: E722 Do not use bare `except`
   |
66 |         result = urlparse(value)
67 |         return all([result.scheme, result.netloc])
68 |     except:
   |     ^^^^^^ E722
69 |         return False
   |

src/midjargon/core/parameters.py:72:5: C901 `convert_parameter_value` is too complex (22 > 10)
   |
72 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ C901
73 |     """Convert a parameter value to the appropriate type."""
74 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:101:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
 99 |         except ValueError:
100 |             msg = f"Invalid version value: {value}"
101 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
102 |
103 |     # Handle seed parameter
    |

src/midjargon/core/parameters.py:111:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
109 |         except ValueError:
110 |             msg = f"Invalid seed value: {value}"
111 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
112 |
113 |     # Handle integer parameters
    |

src/midjargon/core/parameters.py:119:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
117 |         except ValueError:
118 |             msg = f"Invalid integer value for {param}: {value}"
119 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
120 |
121 |     # Handle float parameters
    |

src/midjargon/core/parameters.py:136:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
134 |         except ValueError:
135 |             msg = f"Invalid numeric value for {param}: {value}"
136 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
137 |
138 |     # Handle style parameter
    |

src/midjargon/core/parameters.py:144:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
142 |         except ValueError:
143 |             msg = f"Invalid style value: {value}"
144 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
145 |
146 |     # Handle character and style references
    |

src/midjargon/core/parameters.py:159:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
157 |         except Exception as e:
158 |             msg = f"Invalid reference value for {param}: {value} ({str(e)})"
159 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
160 |
161 |     # Default case: return as string
    |

src/midjargon/core/parameters.py:165:5: C901 `parse_parameters` is too complex (14 > 10)
    |
165 | def parse_parameters(param_str: str) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^ C901
166 |     """Parse parameters from a string into a dictionary."""
167 |     if not param_str:
    |

src/midjargon/core/parameters.py:175:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
173 |     except ValueError as e:
174 |         msg = f"Failed to parse parameters: {e}"
175 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
176 |
177 |     result: dict[str, Any] = {}
    |

src/midjargon/core/parameters.py:208:21: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
206 |                 except Exception as e:
207 |                     msg = f"Failed to parse parameter {current_param}: {e}"
208 |                     raise ValueError(msg)
    |                     ^^^^^^^^^^^^^^^^^^^^^ B904
209 |
210 |             # Start new parameter
    |

src/midjargon/core/parameters.py:241:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
239 |         except Exception as e:
240 |             msg = f"Failed to parse parameter {current_param}: {e}"
241 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
242 |
243 |     return result
    |

src/midjargon/core/parser.py:67:5: C901 `parse_parameters` is too complex (30 > 10)
   |
67 | def parse_parameters(param_str: str) -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^ C901
68 |     """Parse parameter string into a dictionary.
   |

src/midjargon/core/permutations.py:127:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
125 |     except Exception as e:
126 |         msg = f"Failed to parse options at position {start}: {e!s}"
127 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
128 |
129 |     if not options:
    |

src/midjargon/core/permutations.py:145:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
143 |         except Exception as e:
144 |             msg = f"Failed to expand option '{option}': {e!s}"
145 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
146 |
147 |     return results
    |

tests/cli/test_main.py:159:89: E501 Line too long (94 > 88)
    |
157 |         "https://example.com/img1.jpg https://example.com/img2.jpg "
158 |         "a {red, blue} bird on a {branch, rock} "
159 |         f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
    |                                                                                         ^^^^^^ E501
160 |     )
161 |     with StringIO() as capture_stdout:
    |

tests/conftest.py:18:89: E501 Line too long (95 > 88)
   |
16 |         "escaped_commas": "a {red\\, blue, green} bird",
17 |         "nested": "a {big {red, blue}, small green} bird",
18 |         "multiple_images": "https://example.com/1.jpg https://example.com/2.jpg forest --iw 2",
   |                                                                                         ^^^^^^^ E501
19 |     }
   |

Found 25 errors.
============================= test session starts ==============================
platform darwin -- Python 3.12.8, pytest-8.3.4, pluggy-1.5.0
rootdir: /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/midjargon
configfile: pyproject.toml
plugins: rerunfailures-14.0, anyio-4.8.0, mock-3.14.0, xdist-3.6.1
collected 91 items

tests/cli/test_main.py FFFFFFFFFFFFFFF                                   [ 16%]
tests/core/test_input.py FFFFFFFFFFFF                                    [ 29%]
tests/core/test_parameters.py FFFFFFFFFFFFFFFF                           [ 47%]
tests/core/test_parser.py FFFFF.....                                     [ 58%]
tests/engines/midjourney/test_midjourney_parser.py FFFFFFF.FFFF          [ 71%]
tests/integration/test_workflow.py F.FFFF..FFFFFF                        [ 86%]
tests/test_core.py .F.F....FF.                                           [ 98%]
tests/test_package.py .                                                  [100%]

=================================== FAILURES ===================================
______________________________ test_basic_prompt _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10e6c0230>

    def test_basic_prompt(cli):
        """Test basic prompt processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT}",
                json_output=True,
            )
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:58: TypeError
______________________________ test_permutations _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eb0cfb0>

    def test_permutations(cli):
        """Test permutation processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10ead3d00>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_raw_output ________________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10e9e2990>

    def test_raw_output(cli):
        """Test raw output mode."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"a photo --stylize {STYLIZE_VALUE}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:86: TypeError
_________________________ test_json_output_formatting __________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae4ad0>

    def test_json_output_formatting(cli):
        """Test JSON output formatting."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:98: TypeError
______________________________ test_invalid_input ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae5250>

    def test_invalid_input(cli):
        """Test handling of invalid input."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:110: TypeError
__________________________ test_parameter_validation ___________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae5bb0>

    def test_parameter_validation(cli):
        """Test parameter validation."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a photo --stylize {STYLIZE_VALUE * 20}", json_output=True
            )  # Over max
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:120: TypeError
___________________________ test_image_url_handling ____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae64e0>

    def test_image_url_handling(cli):
        """Test handling of image URLs."""
        url = "https://example.com/image.jpg"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"{url} a fusion", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:133: TypeError
_____________________________ test_no_color_output _____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae6f90>

    def test_no_color_output(cli):
        """Test no-color output mode."""
        Console(force_terminal=False)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True, no_color=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:147: TypeError
_____________________________ test_complex_prompt ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae7b90>

    def test_complex_prompt(cli):
        """Test complex prompt with multiple features."""
        prompt = (
            "https://example.com/img1.jpg https://example.com/img2.jpg "
            "a {red, blue} bird on a {branch, rock} "
            f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
        )
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(prompt, json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:163: TypeError
________________________ test_personalization_parameter ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eaa00b0>

    def test_personalization_parameter(cli):
        """Test personalization parameter handling in different forms."""
        # Test flag form (--p)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --p", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:180: TypeError
_______________________ test_numeric_range_permutations ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10e9af440>

    def test_numeric_range_permutations(cli):
        """Test handling of numeric parameters in permutations."""
        # Test stylize parameter range
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:210: TypeError
______________________ test_nested_parameter_permutations ______________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae7fe0>

    def test_nested_parameter_permutations(cli):
        """Test handling of nested permutations with parameters."""
        # Test personalization with nested options
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("smooth edges {, --p {, CODE1}} --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:237: TypeError
_______________________________ test_mj_command ________________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae66c0>

    def test_mj_command(cli):
        """Test Midjourney prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.mj("a serene landscape --ar 16:9 --stylize 100", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10eaa6500>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_fal_command _______________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10eae5cd0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x10eae5f70>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0.0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae5cd0>

    def test_fal_command(cli):
        """Test Fal.ai prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal("a serene landscape --ar 16:9 --stylize 100", json_output=True)

tests/cli/test_main.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10eae5cd0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
______________________________ test_perm_command _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10eae5d30>

    def test_perm_command(cli):
        """Test permutation expansion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird on a {branch, rock}", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10eaa5900>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_basic_input _______________________________

    def test_basic_input():
        """Test basic input without permutations."""
        result = expand_midjargon_input("a simple prompt")
        assert len(result) == 1
>       assert result[0] == "a simple prompt"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a simple prompt', image_prompts=[], parameters=MidjourneyParameters(versio...on=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0) == 'a simple prompt'

tests/core/test_input.py:15: AssertionError
___________________________ test_single_permutation ____________________________

    def test_single_permutation():
        """Test input with a single permutation."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], parameters=MidjourneyParameters(version=No...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:22: AssertionError
_______________________________ test_empty_input _______________________________

    def test_empty_input():
        """Test empty input handling."""
>       result = expand_midjargon_input("")

tests/core/test_input.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:94: in expand_midjargon_input
    weighted_prompts = parse_weighted_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = ''

    def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
        """Parse a prompt with optional weights.
    
        Args:
            prompt: Raw prompt string with optional weights.
    
        Returns:
            List of (prompt, weight) tuples.
    
        Raises:
            ValueError: If prompt is empty or invalid.
        """
        if not prompt or not prompt.strip():
            msg = "Empty prompt"
>           raise ValueError(msg)
E           ValueError: Empty prompt

src/midjargon/core/input.py:23: ValueError
__________________________ test_multiple_permutations __________________________

    def test_multiple_permutations():
        """Test input with multiple permutations."""
        result = expand_midjargon_input("a {red, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_3
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], parameters=MidjourneyParameters(version=No...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:37: AssertionError
___________________________ test_nested_permutations ___________________________

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
>               results.extend(expand_permutations(new_s))

src/midjargon/core/permutations.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a red {cat'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 6

src/midjargon/core/permutations.py:119: ValueError

During handling of the above exception, another exception occurred:

    def test_nested_permutations():
        """Test input with nested permutations."""
>       result = expand_midjargon_input("a {red {cat, dog}, blue bird}")

tests/core/test_input.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:100: in expand_midjargon_input
    expanded = expand_permutations(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
                results.extend(expand_permutations(new_s))
            except Exception as e:
                msg = f"Failed to expand option '{option}': {e!s}"
>               raise ValueError(msg)
E               ValueError: Failed to expand option 'red {cat': Unclosed brace at position 6

src/midjargon/core/permutations.py:145: ValueError
_____________________________ test_escaped_braces ______________________________

    def test_escaped_braces():
        """Test input with escaped braces."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], parameters=MidjourneyParameters...on=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:55: AssertionError
_____________________________ test_escaped_commas ______________________________

    def test_escaped_commas():
        """Test input with escaped commas."""
        result = expand_midjargon_input(r"a {red\, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red, blue bird" in result
E       AssertionError: assert 'a red, blue bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red, blue bird', image_prompts=[], parameters=MidjourneyParameters(vers...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:62: AssertionError
____________________________ test_unmatched_braces _____________________________

    def test_unmatched_braces():
        """Test input with unmatched braces."""
>       result = expand_midjargon_input("a {red, blue bird")

tests/core/test_input.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:100: in expand_midjargon_input
    expanded = expand_permutations(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red, blue bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 2

src/midjargon/core/permutations.py:119: ValueError
____________________________ test_empty_permutation ____________________________

    def test_empty_permutation():
        """Test input with empty permutation options."""
>       result = expand_midjargon_input("a {} bird")

tests/core/test_input.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:100: in expand_midjargon_input
    expanded = expand_permutations(text)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {} bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
>           raise ValueError(msg)
E           ValueError: Empty permutation group at position 2

src/midjargon/core/permutations.py:131: ValueError
___________________________ test_whitespace_handling ___________________________

    def test_whitespace_handling():
        """Test input with various whitespace patterns."""
        result = expand_midjargon_input("a {  red  ,  blue  } bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], parameters=MidjourneyParameters(version=No...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:84: AssertionError
_________________________ test_expand_midjargon_input __________________________

    def test_expand_midjargon_input():
        """Test expand_midjargon_input function to verify prompt expansion."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == 2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], parameters=MidjourneyParameters(version=No...n=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0)]

tests/core/test_input.py:92: AssertionError
_______________________ test_handling_escaped_characters _______________________

    def test_handling_escaped_characters():
        """Test handling of escaped characters in expand_midjargon_input."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], parameters=MidjourneyParameters...on=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:112: AssertionError
_________________________ test_basic_parameter_parsing _________________________

    def test_basic_parameter_parsing():
        """Test parsing of basic parameters."""
        param_str = "--ar 16:9 --stylize 100"
        params = parse_parameters(param_str)
>       assert params["aspect"] == "16:9"
E       KeyError: 'aspect'

tests/core/test_parameters.py:13: KeyError
_____________________________ test_flag_parameters _____________________________

    def test_flag_parameters():
        """Test parsing of flag parameters (without values)."""
        param_str = "--tile --turbo --relax"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:21: AssertionError
_____________________ test_parameter_with_multiple_values ______________________

    def test_parameter_with_multiple_values():
        """Test parsing parameters that accept multiple values."""
        param_str = "--no blur,cars,watermark"
        params = parse_parameters(param_str)
>       assert params["no"] == "blur,cars,watermark"
E       AssertionError: assert ['blur,cars,watermark'] == 'blur,cars,watermark'

tests/core/test_parameters.py:30: AssertionError
__________________________ test_parameter_with_spaces __________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            if value is None:
                return True
            val_lower = value.lower()
            if val_lower in {"true", "1", "yes", "on"}:
                return True
            if val_lower in {"false", "0", "no", "off"}:
                return False
            return bool(value)
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            if value.lower() == "niji":
                return "niji"
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle seed parameter
        if param == "seed":
            if value.lower() in SPECIAL_SEED_VALUES:
                return value.lower()
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid seed value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
>                           value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )

src/midjargon/core/parameters.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            if value is None:
                return True
            val_lower = value.lower()
            if val_lower in {"true", "1", "yes", "on"}:
                return True
            if val_lower in {"false", "0", "no", "off"}:
                return False
            return bool(value)
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            if value.lower() == "niji":
                return "niji"
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle seed parameter
        if param == "seed":
            if value.lower() in SPECIAL_SEED_VALUES:
                return value.lower()
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid seed value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:144: ValueError

During handling of the above exception, another exception occurred:

    def test_parameter_with_spaces():
        """Test parsing parameters with values containing spaces."""
        param_str = '--style "raw photo" --seed 123456'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
>                       raise ValueError(msg)
E                       ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:208: ValueError
____________________________ test_mixed_parameters _____________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            if value is None:
                return True
            val_lower = value.lower()
            if val_lower in {"true", "1", "yes", "on"}:
                return True
            if val_lower in {"false", "0", "no", "off"}:
                return False
            return bool(value)
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            if value.lower() == "niji":
                return "niji"
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle seed parameter
        if param == "seed":
            if value.lower() in SPECIAL_SEED_VALUES:
                return value.lower()
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid seed value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:141: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
>                   value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )

src/midjargon/core/parameters.py:235: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            if value is None:
                return True
            val_lower = value.lower()
            if val_lower in {"true", "1", "yes", "on"}:
                return True
            if val_lower in {"false", "0", "no", "off"}:
                return False
            return bool(value)
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            if value.lower() == "niji":
                return "niji"
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle seed parameter
        if param == "seed":
            if value.lower() in SPECIAL_SEED_VALUES:
                return value.lower()
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid seed value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:144: ValueError

During handling of the above exception, another exception occurred:

    def test_mixed_parameters():
        """Test parsing a mix of different parameter types."""
        param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
                    value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )
                    result[current_param] = value
            except Exception as e:
                msg = f"Failed to parse parameter {current_param}: {e}"
>               raise ValueError(msg)
E               ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:241: ValueError
__________________________ test_shorthand_parameters ___________________________

    def test_shorthand_parameters():
        """Test parsing of shorthand parameter names."""
        param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
        params = parse_parameters(param_str)
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:55: AssertionError
_________________________ test_niji_version_parameter __________________________

    def test_niji_version_parameter():
        """Test parsing of niji version parameter."""
        # Test basic niji
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:66: AssertionError
____________________________ test_version_parameter ____________________________

    def test_version_parameter():
        """Test parsing of version parameter."""
        # Test v parameter
        params = parse_parameters("--v 5.2")
>       assert params["version"] == "5.2"
E       AssertionError: assert <MidjourneyVe....V5_2: 'v5.2'> == '5.2'
E         
E         - 5.2
E         + v5.2
E         ? +

tests/core/test_parameters.py:77: AssertionError
________________________ test_personalization_parameter ________________________

    def test_personalization_parameter():
        """Test parsing of personalization parameter."""
        # Test basic p parameter
        params = parse_parameters("--p")
>       assert params["personalization"] is None  # Flag without value is None
E       assert True is None

tests/core/test_parameters.py:84: AssertionError
__________________________ test_reference_parameters ___________________________

    def test_reference_parameters():
        """Test parsing of reference parameters."""
        param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
        params = parse_parameters(param_str)
>       assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
E       AssertionError: assert [CharacterRef..., weight=1.0)] == ['img1.jpg', 'img2.jpg']
E         
E         At index 0 diff: CharacterReference(url=None, code='img1.jpg', weight=1.0) != 'img1.jpg'
E         Use -v to get more diff

tests/core/test_parameters.py:107: AssertionError
_____________________________ test_parameter_order _____________________________

    def test_parameter_order():
        """Test that parameter order is preserved in output."""
        param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
        params = parse_parameters(param_str)
        keys = list(params.keys())
>       assert keys == ["seed", "aspect", "chaos", "tile"]
E       AssertionError: assert ['seed', 'asp...haos', 'tile'] == ['seed', 'asp...haos', 'tile']
E         
E         At index 1 diff: 'aspect_ratio' != 'aspect'
E         Use -v to get more diff

tests/core/test_parameters.py:116: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameter formats."""
>       with pytest.raises(ValueError, match="Empty parameter name"):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/core/test_parameters.py:121: Failed
________________________ test_flag_parameters_handling _________________________

    def test_flag_parameters_handling():
        """Test handling of flag parameters in parse_parameters."""
        param_str = "--tile --turbo --relax --video --remix"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:138: AssertionError
___________________________ test_special_seed_values ___________________________

    def test_special_seed_values():
        """Test handling of special seed values."""
        # Test random seed
        params = parse_parameters("--seed random")
        assert params["seed"] == "random"
    
        # Test numeric seed
        params = parse_parameters("--seed 12345")
>       assert params["seed"] == "12345"
E       AssertionError: assert 12345 == '12345'

tests/core/test_parameters.py:165: AssertionError
_________________________ test_reference_url_handling __________________________

    def test_reference_url_handling():
        """Test handling of URLs in reference parameters."""
        # Test character reference with quoted URL containing spaces
        params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
>       assert params["character_reference"] == [
            "https://example.com/image with spaces.jpg"
        ]
E       AssertionError: assert [CharacterRef..., weight=1.0)] == ['https://exa...h spaces.jpg']
E         
E         At index 0 diff: CharacterReference(url=HttpUrl('https://example.com/image%20with%20spaces.jpg'), code=None, weight=1.0) != 'https://example.com/image with spaces.jpg'
E         Use -v to get more diff

tests/core/test_parameters.py:172: AssertionError
__________________________ test_niji_version_handling __________________________

    def test_niji_version_handling():
        """Test handling of niji version parameter variations."""
        # Test basic niji
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:185: AssertionError
__________________________ test_basic_prompt_parsing ___________________________

    def test_basic_prompt_parsing():
        """Test basic prompt parsing."""
        prompt = "a beautiful landscape --ar 16:9 --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a beautiful landscape"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:18: KeyError
__________________________ test_prompt_with_image_url __________________________

    def test_prompt_with_image_url():
        """Test prompt parsing with image URL."""
        prompt = f"{IMAGE_URL} a mystical forest --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a mystical forest"
>       assert result["images"] == [IMAGE_URL]
E       KeyError: 'images'

tests/core/test_parser.py:27: KeyError
_____________________ test_prompt_with_multiple_image_urls _____________________

    def test_prompt_with_multiple_image_urls():
        """Test prompt parsing with multiple image URLs."""
        image_urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
        prompt = f"{image_urls[0]} {image_urls[1]} a serene landscape --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a serene landscape"
>       assert result["images"] == image_urls
E       KeyError: 'images'

tests/core/test_parser.py:40: KeyError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a futuristic city --ar 16:9 --stylize 100 --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a futuristic city"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:49: KeyError
______________________ test_prompt_with_empty_parameters _______________________

    def test_prompt_with_empty_parameters():
        """Test prompt parsing with empty parameters."""
        prompt = "a landscape photo --tile --no blur,cars"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a landscape photo"
>       assert result["tile"] is None
E       assert False is None

tests/core/test_parser.py:59: AssertionError
___________________________ test_numeric_parameters ____________________________

    def test_numeric_parameters():
        """Test parsing of numeric parameters."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict(
            {
                "text": "a photo",
                "stylize": str(STYLIZE_VALUE),
                "seed": str(SEED_VALUE),
                "chaos": str(CHAOS_VALUE),
            }
        )
    
        assert prompt.text == "a photo"
        assert prompt.stylize == float(STYLIZE_VALUE)
>       assert prompt.seed == SEED_VALUE
E       AssertionError: assert None == 12345
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).seed

tests/engines/midjourney/test_midjourney_parser.py:39: AssertionError
____________________________ test_style_parameters _____________________________

    def test_style_parameters():
        """Test parsing of style parameters."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict(
            {"text": "a photo", "style": "raw", "version": VERSION_NUMBER}
        )
    
        assert prompt.text == "a photo"
>       assert prompt.style == "raw"
E       AssertionError: assert None == 'raw'
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).style

tests/engines/midjourney/test_midjourney_parser.py:51: AssertionError
______________________________ test_aspect_ratio _______________________________

    def test_aspect_ratio():
        """Test parsing of aspect ratio."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict({"text": "a photo", "ar": "16:9"})
    
        assert prompt.text == "a photo"
>       assert prompt.aspect_width == 16
E       AssertionError: assert None == 16
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:61: AssertionError
______________________________ test_image_prompts ______________________________

    def test_image_prompts():
        """Test parsing of image prompts."""
        parser = MidjourneyParser()
        urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
>       prompt = parser.parse_dict({"text": "a fusion", "image_prompts": urls})

tests/engines/midjourney/test_midjourney_parser.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x10f1894c0>
prompt_dict = {'image_prompts': ['https://example.com/image1.jpg', 'https://example.com/image2.jpg']}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E       image_prompts.0
E         Input should be a valid dictionary or instance of ImageReference [type=model_type, input_value='https://example.com/image1.jpg', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.10/v/model_type
E       image_prompts.1
E         Input should be a valid dictionary or instance of ImageReference [type=model_type, input_value='https://example.com/image2.jpg', input_type=str]
E           For further information visit https://errors.pydantic.dev/2.10/v/model_type

src/midjargon/engines/midjourney/midjourney.py:45: ValidationError
____________________________ test_extra_parameters _____________________________

    def test_extra_parameters():
        """Test handling of unknown parameters."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict(
            {
                "text": "a photo",
                "unknown": "value",
                "flag": None,
            }
        )
    
        assert prompt.text == "a photo"
>       assert prompt.extra_params == {"unknown": "value", "flag": None}
E       AssertionError: assert {} == {'flag': None...own': 'value'}
E         
E         Right contains 2 more items:
E         {'flag': None, 'unknown': 'value'}
E         Use -v to get more diff

tests/engines/midjourney/test_midjourney_parser.py:93: AssertionError
__________________________ test_parameter_conversion ___________________________

    def test_parameter_conversion():
        """Test parameter value conversion."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict(
            {
                "text": "a photo",
                "stylize": str(STYLIZE_VALUE),
                "seed": str(SEED_VALUE),
                "image_weight": str(IMAGE_WEIGHT_VALUE),
            }
        )
    
        assert prompt.text == "a photo"
        assert prompt.stylize == float(STYLIZE_VALUE)
>       assert prompt.seed == SEED_VALUE
E       AssertionError: assert None == 12345
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).seed

tests/engines/midjourney/test_midjourney_parser.py:110: AssertionError
_____________________________ test_invalid_values ______________________________

    def test_invalid_values():
        """Test handling of invalid parameter values."""
        parser = MidjourneyParser()
    
        # Invalid aspect ratio - now accepts any value
        result = parser.parse_dict({"text": "a photo", "ar": "999:999"})
>       assert result.aspect_width == 999
E       AssertionError: assert None == 999
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:120: AssertionError
____________________________ test_version_parameter ____________________________

    def test_version_parameter():
        """Test parsing of version parameter."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict(
            {
                "text": "a photo",
                "version": "6",
            }
        )
    
        assert prompt.text == "a photo"
>       assert prompt.version == "v6"
E       AssertionError: assert None == 'v6'
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).version

tests/engines/midjourney/test_midjourney_parser.py:160: AssertionError
__________________________ test_multiple_permutations __________________________

    def test_multiple_permutations():
        """Test handling of multiple permutations."""
        parser = MidjourneyParser()
    
        # Test with parameter permutations
        input_dicts = [
            {"text": "smooth edges", "stylize": "75"},
            {"text": "smooth edges", "stylize": "300"},
            {"text": "smooth edges", "stylize": "75", "personalization": True},
            {"text": "smooth edges", "stylize": "300", "personalization": True},
        ]
    
        results = [parser.parse_dict(d) for d in input_dicts]
        assert len(results) == 4
    
        # Verify each permutation is handled correctly
        result_tuples = {(r.text.strip(), r.stylize, r.personalization) for r in results}
    
        expected = {
            ("smooth edges", 75.0, False),
            ("smooth edges", 300.0, False),
            ("smooth edges", 75.0, True),
            ("smooth edges", 300.0, True),
        }
    
>       assert result_tuples == expected
E       AssertionError: assert {('smooth edg...100.0, False)} == {('smooth edg... 300.0, True)}
E         
E         Extra items in the left set:
E         ('smooth edges', 100.0, False)
E         Extra items in the right set:
E         ('smooth edges', 300.0, False)
E         ('smooth edges', 75.0, False)
E         ('smooth edges', 300.0, True)
E         ('smooth edges', 75.0, True)
E         Use -v to get more diff

tests/engines/midjourney/test_midjourney_parser.py:188: AssertionError
________________________ test_personalization_parameter ________________________

    def test_personalization_parameter():
        """Test parsing of personalization parameter."""
        parser = MidjourneyParser()
    
        # Test flag with True value
        prompt = parser.parse_dict({"text": "a photo", "personalization": True})
>       assert prompt.personalization is True
E       AssertionError: assert False is True
E        +  where False = MidjourneyPrompt(text='a photo', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=1..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).personalization

tests/engines/midjourney/test_midjourney_parser.py:220: AssertionError
_______________________________ test_edge_cases ________________________________

    def test_edge_cases():
        """Test handling of edge cases in Midjourney parser."""
        parser = MidjourneyParser()
    
        # Test empty prompt
        with pytest.raises(ValueError, match="Empty prompt"):
            parser.parse_dict({"text": ""})
    
        # Test prompt with only spaces
        with pytest.raises(ValueError, match="Empty prompt"):
            parser.parse_dict({"text": "   "})
    
        # Test prompt with special characters
        prompt = parser.parse_dict({"text": "a photo with special characters !@#$%^&*()"})
        assert prompt.text == "a photo with special characters !@#$%^&*()"
    
        # Test prompt with long text
        long_text = "a" * 1000
        prompt = parser.parse_dict({"text": long_text})
        assert prompt.text == long_text
    
        # Test prompt with mixed types in extra parameters
        prompt = parser.parse_dict(
            {
                "text": "a photo",
                "extra1": "123",
                "extra2": "45.67",
                "extra3": "true",
                "extra4": None,
                "extra5": "item1",
            }
        )
>       assert prompt.extra_params["extra1"] == "123"
E       KeyError: 'extra1'

tests/engines/midjourney/test_midjourney_parser.py:259: KeyError
_____________________________ test_basic_workflow ______________________________

    def test_basic_workflow():
        """Test basic prompt processing workflow."""
        prompt = "a portrait --ar 16:9 --stylize 200"
        results = process_prompt(prompt)
    
        assert len(results) == 1
        assert results[0]["text"] == "a portrait"
>       assert results[0]["aspect_ratio"] == "16:9"
E       AssertionError: assert None == '16:9'

tests/integration/test_workflow.py:39: AssertionError
_____________________________ test_image_workflow ______________________________

    def test_image_workflow():
        """Test workflow with image URLs."""
        prompt = "https://example.com/image.jpg a portrait"
        results = process_prompt(prompt)
    
        assert len(results) == 1
>       assert len(results[0]["image_prompts"]) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/integration/test_workflow.py:59: AssertionError
___________________________ test_parameter_workflow ____________________________

    def test_parameter_workflow():
        """Test workflow with various parameters."""
        prompt = "portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
        results = process_prompt(prompt)
    
        assert len(results) == 1
        assert results[0]["text"] == "portrait"
>       assert results[0]["aspect_ratio"] == "16:9"
E       AssertionError: assert None == '16:9'

tests/integration/test_workflow.py:70: AssertionError
_________________________ test_new_parameters_workflow _________________________

    def test_new_parameters_workflow():
        """Test workflow with newer parameters."""
        prompt = "portrait --cref https://example.com/char.jpg --cw 50"
        results = process_prompt(prompt)
    
        assert len(results) == 1
>       assert len(results[0]["character_reference"]) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/integration/test_workflow.py:82: AssertionError
________________________ test_weighted_prompts_workflow ________________________

    def test_weighted_prompts_workflow():
        """Test workflow with weighted prompts."""
        prompt = "first prompt::0.7 second prompt::0.3"
        results = process_prompt(prompt)
    
        assert len(results) == 2
        weights = [r.get("weight", 1.0) for r in results]
>       assert 0.7 in weights
E       assert 0.7 in [1.0, 1.0]

tests/integration/test_workflow.py:93: AssertionError
______________________ test_permutations_with_parameters _______________________

    def test_permutations_with_parameters():
        """Test permutations with parameters."""
        prompt = "photo {modern, vintage} --ar {1:1, 16:9} --s 100"
        results = process_prompt(prompt)
    
        # Convert results to set of tuples for easier comparison
        result_tuples = {
            (r["text"].strip(), r["aspect_ratio"], r["stylize"]) for r in results
        }
    
        expected = {
            ("photo modern", "1:1", 100),
            ("photo modern", "16:9", 100),
            ("photo vintage", "1:1", 100),
            ("photo vintage", "16:9", 100),
        }
>       assert result_tuples == expected
E       AssertionError: assert {('photo mode... None, 100.0)} == {('photo mode..., '1:1', 100)}
E         
E         Extra items in the left set:
E         ('photo vintage', None, 100.0)
E         ('photo modern', None, 100.0)
E         Extra items in the right set:
E         ('photo vintage', '16:9', 100)
E         ('photo modern', '16:9', 100)...
E         
E         ...Full output truncated (3 lines hidden), use '-vv' to show

tests/integration/test_workflow.py:139: AssertionError
____________________ test_permutations_with_flag_parameters ____________________

    def test_permutations_with_flag_parameters():
        """Test permutations with flag parameters (no value) are handled correctly."""
        prompt = "photo {, --tile} {, --turbo}"
        results = process_prompt(prompt)
    
        # Convert results to set of tuples for easier comparison
        result_tuples = {
            (r["text"].strip(), r.get("tile", False), r.get("turbo", False))
            for r in results
        }
    
        expected = {
            ("photo", False, False),
            ("photo", False, True),
            ("photo", True, False),
            ("photo", True, True),
        }
>       assert result_tuples == expected
E       AssertionError: assert {('photo', False, False)} == {('photo', Fa..., True, True)}
E         
E         Extra items in the right set:
E         ('photo', True, False)
E         ('photo', True, True)
E         ('photo', False, True)
E         Use -v to get more diff

tests/integration/test_workflow.py:159: AssertionError
__________________ test_permutations_with_complex_parameters ___________________

    def test_permutations_with_complex_parameters():
        """Test permutations with complex parameter combinations."""
        prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
        results = process_prompt(prompt)
    
        # Convert results to set of tuples for easier comparison
        result_tuples = {
            (
                r["text"].strip(),
                (
                    r["personalization"][0]
                    if isinstance(r.get("personalization", []), list)
                    else r.get("personalization")
                ),
                f"{r['aspect_width']}:{r['aspect_height']}",
                r["stylize"],
            )
            for r in results
        }
    
        expected = {
            ("portrait modern", None, "1:1", 100),
            ("portrait modern", "custom", "1:1", 100),
            ("portrait modern", None, "16:9", 100),
            ("portrait modern", "custom", "16:9", 100),
            ("portrait vintage", None, "1:1", 100),
            ("portrait vintage", "custom", "1:1", 100),
            ("portrait vintage", None, "16:9", 100),
            ("portrait vintage", "custom", "16:9", 100),
        }
>       assert result_tuples == expected
E       AssertionError: assert {('portrait m...None', 100.0)} == {('portrait v...1', 100), ...}
E         
E         Extra items in the left set:
E         ('portrait modern', False, 'None:None', 100.0)
E         ('portrait vintage', False, 'None:None', 100.0)
E         Extra items in the right set:
E         ('portrait vintage', None, '16:9', 100)
E         ('portrait vintage', None, '1:1', 100)...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

tests/integration/test_workflow.py:192: AssertionError
_____________________________ test_cli_mj_command ______________________________

    def test_cli_mj_command():
        """Test Midjourney prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.mj(prompt, json_output=True)
            sys.stdout = sys.__stdout__
            output = capture_stdout.getvalue()
>       assert "serene landscape" in output
E       AssertionError: assert 'serene landscape' in ''

tests/integration/test_workflow.py:204: AssertionError
_____________________________ test_cli_fal_command _____________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10ea824b0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x10ea81040>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0.0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

    def test_cli_fal_command():
        """Test Fal.ai prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal(prompt, json_output=True)

tests/integration/test_workflow.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10ea824b0>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
____________________________ test_cli_perm_command _____________________________

    def test_cli_perm_command():
        """Test permutation expansion using CLI."""
        cli = MidjargonCLI()
        prompt = "a {red, blue} bird on a {branch, rock}"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm(prompt, json_output=True)
            sys.stdout = sys.__stdout__
            output = capture_stdout.getvalue()
>       assert "red" in output
E       AssertionError: assert 'red' in ''

tests/integration/test_workflow.py:232: AssertionError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
        result = parse_midjargon_prompt(prompt)
    
        assert result.text == "a portrait"
>       assert result.parameters.aspect == "16:9"
E       AssertionError: assert None == '16:9'
E        +  where None = MidjourneyParameters(version=None, style=None, stylize=100.0, chaos=0.0, weird=0.0, seed=None, aspect_width=None, aspe...e_weight=None, style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}).aspect
E        +    where MidjourneyParameters(version=None, style=None, stylize=100.0, chaos=0.0, weird=0.0, seed=None, aspect_width=None, aspe...e_weight=None, style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}) = MidjourneyPrompt(text='a portrait', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, styliz..., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).parameters

tests/test_core.py:31: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameters."""
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_core.py:49: Failed
_____________________________ test_style_reference _____________________________

    def test_style_reference():
        """Test handling of style references."""
        # Test with code
        prompt = "test --sref p123456"
        result = parse_midjargon_prompt(prompt)
>       assert result.style_reference
E       AssertionError: assert []
E        +  where [] = MidjourneyPrompt(text='test', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=100...., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).style_reference

tests/test_core.py:109: AssertionError
___________________________ test_character_reference ___________________________

    def test_character_reference():
        """Test handling of character references."""
        prompt = "test --cref https://example.com/char.jpg --cw 50"
        result = parse_midjargon_prompt(prompt)
    
>       assert result.character_reference
E       AssertionError: assert []
E        +  where [] = MidjourneyPrompt(text='test', image_prompts=[], parameters=MidjourneyParameters(version=None, style=None, stylize=100...., style_version=2, repeat=None, personalization=False, quality=1.0, negative_prompt=None, extra_params={}), weight=1.0).character_reference

tests/test_core.py:124: AssertionError
=========================== short test summary info ============================
FAILED tests/cli/test_main.py::test_basic_prompt - TypeError: MidjargonCLI.js...
FAILED tests/cli/test_main.py::test_permutations - ValueError: No JSON found ...
FAILED tests/cli/test_main.py::test_raw_output - TypeError: MidjargonCLI.json...
FAILED tests/cli/test_main.py::test_json_output_formatting - TypeError: Midja...
FAILED tests/cli/test_main.py::test_invalid_input - TypeError: MidjargonCLI.j...
FAILED tests/cli/test_main.py::test_parameter_validation - TypeError: Midjarg...
FAILED tests/cli/test_main.py::test_image_url_handling - TypeError: Midjargon...
FAILED tests/cli/test_main.py::test_no_color_output - TypeError: MidjargonCLI...
FAILED tests/cli/test_main.py::test_complex_prompt - TypeError: MidjargonCLI....
FAILED tests/cli/test_main.py::test_personalization_parameter - TypeError: Mi...
FAILED tests/cli/test_main.py::test_numeric_range_permutations - TypeError: M...
FAILED tests/cli/test_main.py::test_nested_parameter_permutations - TypeError...
FAILED tests/cli/test_main.py::test_mj_command - ValueError: No JSON found in...
FAILED tests/cli/test_main.py::test_fal_command - SystemExit: 1
FAILED tests/cli/test_main.py::test_perm_command - ValueError: No JSON found ...
FAILED tests/core/test_input.py::test_basic_input - AssertionError: assert Pr...
FAILED tests/core/test_input.py::test_single_permutation - AssertionError: as...
FAILED tests/core/test_input.py::test_empty_input - ValueError: Empty prompt
FAILED tests/core/test_input.py::test_multiple_permutations - AssertionError:...
FAILED tests/core/test_input.py::test_nested_permutations - ValueError: Faile...
FAILED tests/core/test_input.py::test_escaped_braces - AssertionError: assert...
FAILED tests/core/test_input.py::test_escaped_commas - AssertionError: assert...
FAILED tests/core/test_input.py::test_unmatched_braces - ValueError: Unclosed...
FAILED tests/core/test_input.py::test_empty_permutation - ValueError: Empty p...
FAILED tests/core/test_input.py::test_whitespace_handling - AssertionError: a...
FAILED tests/core/test_input.py::test_expand_midjargon_input - AssertionError...
FAILED tests/core/test_input.py::test_handling_escaped_characters - Assertion...
FAILED tests/core/test_parameters.py::test_basic_parameter_parsing - KeyError...
FAILED tests/core/test_parameters.py::test_flag_parameters - assert True is None
FAILED tests/core/test_parameters.py::test_parameter_with_multiple_values - A...
FAILED tests/core/test_parameters.py::test_parameter_with_spaces - ValueError...
FAILED tests/core/test_parameters.py::test_mixed_parameters - ValueError: Fai...
FAILED tests/core/test_parameters.py::test_shorthand_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_niji_version_parameter - Assertion...
FAILED tests/core/test_parameters.py::test_version_parameter - AssertionError...
FAILED tests/core/test_parameters.py::test_personalization_parameter - assert...
FAILED tests/core/test_parameters.py::test_reference_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_parameter_order - AssertionError: ...
FAILED tests/core/test_parameters.py::test_invalid_parameters - Failed: DID N...
FAILED tests/core/test_parameters.py::test_flag_parameters_handling - assert ...
FAILED tests/core/test_parameters.py::test_special_seed_values - AssertionErr...
FAILED tests/core/test_parameters.py::test_reference_url_handling - Assertion...
FAILED tests/core/test_parameters.py::test_niji_version_handling - AssertionE...
FAILED tests/core/test_parser.py::test_basic_prompt_parsing - KeyError: 'aspect'
FAILED tests/core/test_parser.py::test_prompt_with_image_url - KeyError: 'ima...
FAILED tests/core/test_parser.py::test_prompt_with_multiple_image_urls - KeyE...
FAILED tests/core/test_parser.py::test_prompt_with_parameters - KeyError: 'as...
FAILED tests/core/test_parser.py::test_prompt_with_empty_parameters - assert ...
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_numeric_parameters
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_style_parameters
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_aspect_ratio
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_image_prompts
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_extra_parameters
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_parameter_conversion
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_invalid_values
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_version_parameter
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_multiple_permutations
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_personalization_parameter
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_edge_cases - ...
FAILED tests/integration/test_workflow.py::test_basic_workflow - AssertionErr...
FAILED tests/integration/test_workflow.py::test_image_workflow - assert 0 == 1
FAILED tests/integration/test_workflow.py::test_parameter_workflow - Assertio...
FAILED tests/integration/test_workflow.py::test_new_parameters_workflow - ass...
FAILED tests/integration/test_workflow.py::test_weighted_prompts_workflow - a...
FAILED tests/integration/test_workflow.py::test_permutations_with_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_flag_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_complex_parameters
FAILED tests/integration/test_workflow.py::test_cli_mj_command - AssertionErr...
FAILED tests/integration/test_workflow.py::test_cli_fal_command - SystemExit: 1
FAILED tests/integration/test_workflow.py::test_cli_perm_command - AssertionE...
FAILED tests/test_core.py::test_prompt_with_parameters - AssertionError: asse...
FAILED tests/test_core.py::test_invalid_parameters - Failed: DID NOT RAISE <c...
FAILED tests/test_core.py::test_style_reference - AssertionError: assert []
FAILED tests/test_core.py::test_character_reference - AssertionError: assert []
======================== 74 failed, 17 passed in 1.01s =========================
```

## File: LICENSE (Size: 1.04 KB)

```
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## File: LOG.md (Size: 3.51 KB)

```
---
this_file: LOG.md
---
# Implementation Log

## Current Status (2024-03-21)

### Immediate Focus

Starting work on Priority 0: Critical Model Fixes
1. Model validation issues discovered:
   -  Image reference validation failing
     - Invalid input type for image_prompts
     - URL validation issues
   -  Parameter parsing failing
     - Aspect ratio not being set
     - Flag parameters not working
     - Reference parameters not working
   -  Model validation issues
     - Missing attribute access
     - Validation rules not working
2. Test suite status:
   -  15 tests passing
   -  76 tests failing
   - Major failure categories:
     - Image reference validation
     - Parameter parsing
     - CLI implementation
     - Permutation handling
3. Next steps:
   - [ ] Fix image reference handling
   - [ ] Fix parameter parsing
   - [ ] Fix model validation

### Recent Changes

1. Model Implementation []
   -  Fixed model validator syntax
     - Updated to Pydantic v2 style
     - Fixed validator signatures
     - Added proper validation mode
   -  Added missing methods
     - Added to_string() method
     - Added property access
     - Fixed model_dump
   -  Still failing
     - Image reference validation
     - Parameter parsing
     - Model validation

2. Test Analysis []
   -  Ran full test suite
   -  Analyzed test failures
   -  Identified critical issues:
     - Image reference validation
     - Parameter parsing
     - Model validation
   -  Created detailed fix plan

### Next Steps

1. Fix Image Reference Handling
   - Update extract_image_urls
   - Fix image reference validation
   - Add proper URL validation

2. Fix Parameter Parsing
   - Fix aspect ratio handling
   - Fix flag parameter handling
   - Fix reference parameter parsing

3. Fix Model Validation
   - Fix validation rules
   - Fix attribute access
   - Fix parameter handling

### Remaining Issues

1. Parser Implementation []
   -  Image URL handling in parser needs fixing
   -  Parameter extraction needs improvement
   -  Model instantiation with parameters needs fixing

2. CLI Implementation []
   -  JSON output formatting
   -  Command implementations
   -  Parameter handling
   -  Output formatting

3. Test Suite []
   -  Identified failing tests
   -  Analyzed failure patterns
   -  76 tests still failing
   - [ ] Planning fixes for each category

### Dependencies Status []

All core dependencies are in place and working as expected:
- pydantic>=2.0.0
- rich>=13.0.0
- fire>=0.5.0
- python-box>=7.3.2
- fal-client>=0.5.8

### Development Guidelines Status

1. Type Safety []
   -  Fixed model validation syntax
   -  Image reference validation failing
   -  Parameter validation failing
   - [ ] Planning comprehensive fixes

2. Code Quality []
   -  Fixed validator implementations
   -  Parser implementation needs work
   -  CLI implementation needs work
   - [ ] Planning improvements

3. Testing []
   -  Test suite running
   -  Test failures analyzed
   -  76 tests failing
   - [ ] Planning fixes

4. Documentation []
   -  Updated model documentation
   -  CLI documentation incomplete
   -  Parameter documentation needed
   - [ ] Planning updates

## Notes

The immediate focus is on fixing the image reference validation and parameter parsing issues. These are blocking proper functionality and causing most test failures. After fixing these core issues, we'll move on to the CLI implementation and permutation handling fixes.
```

## File: README.md (Size: 3.63 KB)

```
---
this_file: README.md
---

# Midjargon

`midjargon` is a powerful Python library designed to simplify the parsing and manipulation of Midjourney-style prompts. 

Midjourney uses a specialized syntax for prompts, which we call midjargon. It allows for `{}` permutation and for specifying of parameters using an `--` prefix. This syntax is useful for other applications, such as constructing prompts for Flux models. 

The `midjargon` package reads midjargon prompts, deconstructs them into manageable components, ensuring type-safe operations and comprehensive validation. It also converts midjargon prompts into other formats, such as Fal.ai, and serializes them back into the Midjourney format.

_Its work in progress, but already pretty usable._

## Features

- **Robust Prompt Parsing**:
  - Parses Midjourney prompts into structured components (text, parameters, image URLs)
  - Type-safe parsing with comprehensive validation
  - Supports complex prompt structures and syntax

- **Advanced Permutation Support**:
  - Handles nested permutations in curly braces `{option1, option2}`
  - Supports escaped characters in permutations (e.g., `\,` for literal commas)
  - Automatically expands all possible combinations

- **Comprehensive Parameter Handling**:
  - Validates parameter names and values
  - Supports numeric ranges and type conversion
  - Processes boolean flags and multi-value parameters

- **Image URL Processing**:
  - Extracts and validates image URLs
  - Supports multiple image inputs and file extensions

- **Multi-prompt Support**:
  - Handles weighted prompts using `::`
  - Processes multiple variations in a single input

- **Type Safety**:
  - Full type hints throughout the codebase
  - Pydantic models for robust validation

- **Rich CLI Interface**:
  - Fire-based command-line interface with rich output
  - CLI commands for converting prompts to different formats (Midjourney, Fal.ai)
  - JSON output option for automation

## Installation

```bash
pip install midjargon
```

## Quick Start

### Basic Usage

```python
from midjargon import parse_midjourney_dict, expand_midjargon_input

# Parse a simple prompt
prompt = "a serene landscape --ar 16:9 --stylize 100"
result = expand_midjargon_input(prompt)[0]
validated = parse_midjourney_dict(result)
```

### CLI Usage

Midjargon exposes a single CLI interface with multiple commands. Here are some examples:

```bash
# You can run the tool with uv without installing dependencies: 
uv run midjargon

# You can also run it directly: 
midjargon

# Or using your Python interpreter:
python -m midjargon
```

To get help on the commands: 

```bash
# Help for Fal.ai conversion (convert prompt to Fal.ai format)
midjargon fal --help

# Help for Midjourney conversion
midjargon mj --help

# Help for JSON parsing (MidjargonDict output)
midjargon json --help

# Help for permutation expansion
midjargon perm --help
```

You can also run commands directly:

```bash
# Convert prompt to Fal.ai format:
midjargon fal "a portrait of a cat --ar 1:1"

# Parse prompt to MidjargonDict:
midjargon json "a futuristic city --chaos 20 --stylize 200"

# Convert prompt to Midjourney format:
midjargon mj "a landscape --ar 16:9 --tile"

# Expand prompt permutations:
midjargon perm "a {red, blue} bird on a tree"
```

## Project Structure

TODO: Add a file tree

## Contributing

Contributions are welcome! Please submit a pull request with your changes.

### Development Setup

1. Clone the repository
2. Install dependencies:
   ```bash
   uv pip install --system --upgrade ".[all]"
   ```
3. Run tests:
   ```bash
   hatch test
   ```
4. Format code:
   ```bash
   hatch fmt
   ```

## License

MIT License - See LICENSE file for details
```

## File: TODO.md (Size: 11.86 KB)

```
---
this_file: TODO.md
---
# Midjargon Package Implementation Plan

## Priority 0: Python Version and Build System Fixes [IMMEDIATE]

### 0.1 Fix Python Version Compatibility [CRITICAL]
- [ ] Update Python version requirements in pyproject.toml
  - [ ] Change requires-python to ">=3.10" to match current environment
  - [ ] Update tool.ruff.target-version to "py310"
  - [ ] Update tool.mypy.python_version to "3.10"
  - [ ] Remove Python 3.10 from tool.hatch.envs.all.matrix (since we'll support it)
  - Detailed steps:
    1. [ ] Edit pyproject.toml:
       ```toml
       [project]
       requires-python = ">=3.10"
       
       [tool.ruff]
       target-version = "py310"
       
       [tool.mypy]
       python_version = "3.10"
       ```
    2. [ ] Update tool.hatch.envs.all.matrix to only include 3.11 and 3.12

### 0.2 Fix Build System Configuration [CRITICAL]
- [ ] Update build system dependencies
  - [ ] Verify hatchling and hatch-vcs versions
  - [ ] Add missing development dependencies
  - [ ] Fix dependency resolution issues
  - Detailed steps:
    1. [ ] Check and update build-system.requires versions
    2. [ ] Add any missing dev dependencies to tool.rye.dev-dependencies
    3. [ ] Verify all dependency versions are compatible

## Priority 1: Critical Model and Parser Fixes

### 1.1 Fix Pydantic Model Implementation [CRITICAL]
- [ ] Fix MidjourneyPrompt model validation issues
  - [ ] Fix character_reference and style_reference list validation
  - [ ] Ensure proper type conversion for list fields
  - [ ] Add proper validation for empty lists
  - [ ] Fix extra_params handling in model_dump()
  - [ ] Fix aspect ratio handling and validation
  - [ ] Fix computed_field for images property
  - [ ] Fix parameters property implementation
  - Detailed steps:
    1. [ ] Update src/midjargon/core/models.py:
       - [ ] Add proper validators for character_reference and style_reference
       - [ ] Implement proper type conversion for list fields
       - [ ] Add validation for empty lists with custom error messages
       - [ ] Fix model_dump() method to handle extra_params correctly
       - [ ] Add proper aspect ratio validation with regex pattern
       - [ ] Fix computed_field decorator usage for images property
       - [ ] Implement parameters property with proper caching

### 1.2 Fix Parameter Parsing [CRITICAL]
- [ ] Fix parse_parameters function
  - [ ] Fix type conversion for numeric parameters
  - [ ] Fix flag parameter handling (True/False values)
  - [ ] Fix list parameter parsing (character_reference, style_reference)
  - [ ] Fix aspect ratio parameter parsing
  - [ ] Add proper validation for all parameter types
  - [ ] Fix version parameter handling
  - Detailed steps:
    1. [ ] Update src/midjargon/core/parameters.py:
       - [ ] Add proper numeric type conversion with error handling
       - [ ] Implement consistent flag parameter handling
       - [ ] Fix list parameter parsing with proper delimiter handling
       - [ ] Add regex validation for aspect ratio
       - [ ] Add comprehensive parameter validation
       - [ ] Implement version parameter normalization

### 1.3 Fix Core Parser [CRITICAL]
- [ ] Fix parse_midjargon_prompt function
  - [ ] Fix parameter extraction and validation
  - [ ] Fix image URL extraction
  - [ ] Fix text part extraction
  - [ ] Add proper error handling and messages
  - [ ] Fix model instantiation with parameters
  - Detailed steps:
    1. [ ] Update src/midjargon/core/parser.py:
       - [ ] Implement robust parameter extraction
       - [ ] Add proper URL validation for images
       - [ ] Fix text extraction with proper escaping
       - [ ] Add detailed error messages
       - [ ] Fix model instantiation with validated parameters

## Priority 2: Code Quality Fixes

### 2.1 Fix Linting Issues
- [ ] Fix FBT001/FBT002 issues in CLI
  - [ ] Replace boolean positional arguments with proper flags
  - [ ] Use dataclasses or Pydantic models for CLI options
- [ ] Fix complexity issues
  - [ ] Refactor `parse_weighted_prompt` (C901)
  - [ ] Refactor `convert_parameter_value` (C901)
  - [ ] Refactor `parse_parameters` (C901)
- [ ] Fix error handling
  - [ ] Replace bare excepts with specific exception handling
  - [ ] Add proper error chaining with `raise ... from`
  - [ ] Add descriptive error messages

### 2.2 Fix Type Safety
- [ ] Add proper type hints throughout
- [ ] Fix unused arguments (ARG003)
- [ ] Add validation for all input parameters
- [ ] Add runtime type checking where necessary

## Priority 3: Core Functionality Fixes

### 3.1 Fix Permutation Handling
- [ ] Fix expand_midjargon_input function
  - [ ] Fix weighted prompt handling
  - [ ] Fix nested permutation groups
  - [ ] Fix whitespace handling
  - [ ] Fix escape character handling
  - [ ] Add proper validation for permutation syntax

### 3.2 Fix Input Processing
- [ ] Fix input validation and sanitization
  - [ ] Add proper URL validation
  - [ ] Fix multi-prompt handling
  - [ ] Fix weight parsing
  - [ ] Add proper input sanitization
  - [ ] Fix escape character handling

### 3.3 Fix CLI Implementation
- [ ] Fix command implementations
  - [ ] Fix 'mj' command
  - [ ] Fix 'fal' command
  - [ ] Fix 'perm' command
  - [ ] Fix JSON output formatting
  - [ ] Add proper error handling

## Priority 4: Engine-Specific Fixes

### 4.1 Fix Midjourney Engine
- [ ] Fix MidjourneyParser implementation
  - [ ] Fix parameter mapping
  - [ ] Fix type conversion
  - [ ] Fix validation
  - [ ] Fix reference handling

### 4.2 Fix Fal.ai Engine
- [ ] Fix FalParser implementation
  - [ ] Fix parameter mapping
  - [ ] Fix type conversion
  - [ ] Fix validation
  - [ ] Fix reference handling

## Priority 5: Testing and Documentation

### 5.1 Fix Test Suite
- [ ] Fix core functionality tests
  - [ ] Fix parameter parsing tests
  - [ ] Fix model validation tests
  - [ ] Fix permutation tests
  - [ ] Add missing edge cases

### 5.2 Update Documentation
- [ ] Update API documentation
  - [ ] Document model attributes
  - [ ] Document parameter handling
  - [ ] Document CLI commands
  - [ ] Add error handling guide

## Implementation Order

1. Start with Priority 0: Fix missing exports (IMMEDIATE)
   - This is blocking the test suite from running
   - Add missing exports to __init__.py

2. Move to Priority 1: Critical Model and Parser Fixes
   - Fix MidjourneyPrompt model validation issues
   - Fix parameter parsing
   - Fix core parser implementation

3. Address Priority 2: Code Quality Fixes
   - Fix linting issues
   - Improve type safety
   - Clean up error handling

4. Then proceed with remaining priorities in order

## Current Focus

The immediate focus should be on fixing the missing exports in __init__.py:
1. Add `expand_midjargon_input` to exports
2. Add `PromptVariant` to exports
3. Verify all necessary types and functions are exported

## Dependencies
- pydantic (>=2.0.0)
- rich (>=13.0.0)
- fire (>=0.5.0)
- python-box (>=7.3.2)
- fal-client (>=0.5.8)

## Development Guidelines
1. Maintain type safety
2. Follow code quality standards
3. Add comprehensive tests
4. Keep documentation updated
5. Consider performance
6. Handle errors gracefully

## Priority 0: Model Implementation Fixes [IMMEDIATE]

### 0.1 Fix MidjourneyPrompt Model [CRITICAL]
- [ ] Add missing methods to MidjourneyPrompt class
  - [ ] Implement `to_string()` method
  - [ ] Fix model validation for image references
  - [ ] Add proper attribute access for parameters
  - Detailed steps:
    1. [ ] Update src/midjargon/core/models.py:
       ```python
       def to_string(self) -> str:
           """Convert prompt back to string format."""
           parts = [self.text]
           if self.image_prompts:
               parts = [str(img) for img in self.image_prompts] + parts
           if self.parameters:
               parts.append(self.parameters.to_string())
           return " ".join(parts)
       ```
    2. [ ] Fix image reference validation in model definition
    3. [ ] Add proper parameter attribute access

### 0.2 Fix MidjourneyParameters Model [CRITICAL]
- [ ] Add missing attributes to MidjourneyParameters class
  - [ ] Add `aspect` property
  - [ ] Add `style_reference` handling
  - [ ] Add `character_reference` handling
  - [ ] Fix parameter validation
  - Detailed steps:
    1. [ ] Update parameter model in src/midjargon/core/models.py
    2. [ ] Add computed properties for convenience access
    3. [ ] Fix parameter validation rules

### 0.3 Fix Parameter Parsing [CRITICAL]
- [ ] Fix parameter parsing in core/parameters.py
  - [ ] Fix flag parameter handling
  - [ ] Fix numeric parameter validation
  - [ ] Fix reference parameter parsing
  - [ ] Add proper error handling
  - Detailed steps:
    1. [ ] Update parameter parsing logic
    2. [ ] Add proper validation for all parameter types
    3. [ ] Improve error messages

## Priority 1: CLI Implementation Fixes

### 1.1 Fix CLI Commands [HIGH]
- [ ] Fix CLI command implementations
  - [ ] Fix JSON output formatting
  - [ ] Fix command error handling
  - [ ] Fix parameter handling in commands
  - Detailed steps:
    1. [ ] Update src/midjargon/cli/main.py
    2. [ ] Fix JSON serialization
    3. [ ] Add proper error handling
    4. [ ] Fix parameter processing

### 1.2 Fix Integration Tests [HIGH]
- [ ] Fix integration test failures
  - [ ] Fix workflow tests
  - [ ] Fix CLI command tests
  - [ ] Fix parameter handling tests
  - Detailed steps:
    1. [ ] Update test assertions
    2. [ ] Fix test data
    3. [ ] Add missing test cases

## Priority 2: Core Functionality Fixes

### 2.1 Fix Permutation Handling
- [ ] Fix expand_midjargon_input function
  - [ ] Fix weighted prompt handling
  - [ ] Fix nested permutation groups
  - [ ] Fix whitespace handling
  - [ ] Fix escape character handling
  - [ ] Add proper validation for permutation syntax

### 2.2 Fix Input Processing
- [ ] Fix input validation and sanitization
  - [ ] Add proper URL validation
  - [ ] Fix multi-prompt handling
  - [ ] Fix weight parsing
  - [ ] Add proper input sanitization
  - [ ] Fix escape character handling

### 2.3 Fix CLI Implementation
- [ ] Fix command implementations
  - [ ] Fix 'mj' command
  - [ ] Fix 'fal' command
  - [ ] Fix 'perm' command
  - [ ] Fix JSON output formatting
  - [ ] Add proper error handling

### 2.4 Fix Engine-Specific Implementations
- [ ] Fix MidjourneyParser implementation
  - [ ] Fix parameter mapping
  - [ ] Fix type conversion
  - [ ] Fix validation
  - [ ] Fix reference handling

- [ ] Fix FalParser implementation
  - [ ] Fix parameter mapping
  - [ ] Fix type conversion
  - [ ] Fix validation
  - [ ] Fix reference handling

## Priority 3: Testing and Documentation

### 3.1 Fix Test Suite
- [ ] Fix core functionality tests
  - [ ] Fix parameter parsing tests
  - [ ] Fix model validation tests
  - [ ] Fix permutation tests
  - [ ] Add missing edge cases

### 3.2 Update Documentation
- [ ] Update API documentation
  - [ ] Document model attributes
  - [ ] Document parameter handling
  - [ ] Document CLI commands
  - [ ] Add error handling guide

## Implementation Order

1. Start with Priority 0: Fix missing exports (IMMEDIATE)
   - This is blocking the test suite from running
   - Add missing exports to __init__.py

2. Move to Priority 1: Critical Model and Parser Fixes
   - Fix MidjourneyPrompt model validation issues
   - Fix parameter parsing
   - Fix core parser implementation

3. Address Priority 2: Code Quality Fixes
   - Fix linting issues
   - Improve type safety
   - Clean up error handling

4. Then proceed with remaining priorities in order

## Current Focus

The immediate focus should be on fixing the missing exports in __init__.py:
1. Add `expand_midjargon_input` to exports
2. Add `PromptVariant` to exports
3. Verify all necessary types and functions are exported

## Dependencies
- pydantic (>=2.0.0)
- rich (>=13.0.0)
- fire (>=0.5.0)
- python-box (>=7.3.2)
- fal-client (>=0.5.8)

## Development Guidelines
1. Maintain type safety
2. Follow code quality standards
3. Add comprehensive tests
4. Keep documentation updated
5. Consider performance
6. Handle errors gracefully
```

## File: dist/.gitkeep (Size: 0.00 KB)

```

```

## File: docs/specification.md (Size: 15.07 KB)

```
---
this_file: docs/specification.md
---

# **Midjourney Prompt Format Specification**

_2025-02-06 by Adam Twardoch, not affiliated with Midjourney_

Midjourney prompts use midjargon, a structured syntax to instruct the Midjourney models to generate images. A prompt consists of three main sections, in order:

1. **Image Reference (Optional)**
2. **Text Description (Required if no image is provided)**
3. **Parameters (Optional)**

Each section has defined syntax and placement requirements. Advanced features such as multi-prompts with weights, permutation prompts, personalization, and style or character references are integrated into the text description and parameters.

Midjourney supports two distinct types of stylizations. The official Midjourney documentation often ambiguously calls both style: 

- Style reference
- Personalization

## Parameters

Parameters are modifiers appended at the end of the prompt that adjust various aspects of image generation. Parameters always begin with two hyphens `--` and may accept a value. The order of parameters (after the text description) is flexible.

Terms that follow a parameter `--a` are treated as its arguments (values). If `--a` is directly followed by another parameter `--b`, then `--a` is considered a boolean flag. 

---

## Choosing the model

### Midjourney series (`--v` or `--version`)

Uses the specified version of the general Midjourney model series. 

#### Syntax

```
--v <version_number>
```

#### Values

- `5`, `5.1`, `5.2`, `6`, `6.1`

> Example

```
--v 6
```

### Niji series (`--niji`)

Uses the specified version of the Niji model series, optimized for anime and illustrative styles.

#### Syntax

```
--niji <version_number>
```

- Values: `5`, `6`

> Example

```
--niji 6
```

### Model mode (`--style`)

Applies specific model mode. 

```
--style <mode_name>
```

- Mode name can be `raw`, it reduces automatic personalization.

> Example

```
--style raw
```

## Using images

### Image references

One or more direct image URLs or attachments used to influence the generated image's style, color, composition, and content.

Must appear at the very **start** of the prompt.

Each image can be:

- A direct image URL ending with `.png`, `.jpg`, `.jpeg`, `.gif`, or `.webp`.
- An attached image in Discord or uploaded via the Midjourney web interface.

Multiple images are separated by whitespace.

> Example

```
https://example.com/image1.jpg https://example.com/image2.png
```

#### Image weight (`--iw`)

`--iw <value>`

Adjusts the influence of all image references relative to the text prompt. 

- Value Range `0.0` to `3.0` (float)
- Default: `1.0` (varies by model)

> Example

```
--iw 1.5
```

As with other parameters, `--iw` must be placed after the text description, even though it refers to the image references that are placed at the very start of the prompt.

### Character reference (`--cref`)

`--cref <url1> [<url2> ...]`

Uses images as character references to maintain consistency.

#### Character weight (`--cw`)

Adjusts the strength of the character reference.

`--cw <value>`

- Value range: `0` to `100` (integer)
- Default: `100`

The character weight `0` typically only copies the face. 

> Example

```
--cref https://example.com/character.jpg --cw 50
```

### Style reference (`--sref`)

The `--sref` parameter uses images as style references without influencing content. It applies the visual characteristics of a specific images or stylization code. 

In effect, it pulls the generated image towards a specific look that is expressed explicitly (via the image) or less directly (via the stylization code).

```
--sref <url|code> [<url|code> ...]
```

One or more image URLs or a specific stylization CODE (the CODE acts as a shorthand for a predefined image reference)

#### Style weight (`--sw`)

Adjusts the strength of the style reference.

`--sw <value>`

- Value Range: `0` to `1000` (integer)

#### Style version (`--sv`)

Selects different style reference algorithms.

`--sv <value>`

- Values: `1`, `2`, `3`, `4`

> Example

```
--sref https://example.com/style.jpg --sw 200 --sv 2
```

#### Random style reference

`--sref random`

Generates a random style reference.

### Persona reference (`--p`)

References one or more personas, personalized style profiles, which pull the generated image towards the preferences or a general style of a particular user or moodboard, with the degree controlled by `--s`.

- Without specifying a persona code, `--p` uses your current personalization profile.
- Providing one or more persona codes of a personalization profile or moodboard (e.g., `--p p123456789`) applies a specific personalization.

#### Personalization weight (`--s`)

```
--stylize <value>
```

The `--s` (`--stylize`, or personalization weight) parameter controls the degree of personalization. 

- If a persona with a code is provided, the `--s` parameter controls how much the generated image will be pulled towards that persona.
- If the personalization switch is used (`--p`) without a code, the `--s` parameter controls how much the generated image will be pulled towards your current personalization profile.
- If the personalization switch is not used (no `--p` at all), the `--s` parameter controls how much the generated image will be pulled towards the models general persona (overall aesthetic preference).

- Value range: `0` to `1000` (integer)
- Default: `100`

The value of `0` applies minimal personalization, though certain influence of the model remains. To reduce the model influence, and have purer personalization use `--style raw` together with a low `--s` value.

> Example:

```
--p p123456789 --s 500 --style raw
```

## Describing the image

A natural language description of the desired image, specifying the subject, mood, style, and other artistic details.

### Clarity & specificity

Use specific adjectives, nouns, and phrases. Describe the subject, medium, environment, lighting, color, mood, and composition.

### Positive framing

Emphasize what should appear in the image rather than what should be excluded (exclusions are handled by the `--no` parameter).

### Tokenization

The text is internally tokenized; word order and precision are important.

### Text generation

Use double quotation marks `"` around words or phrases to specify exact text you want to appear in the image.

> Example

```
A neon sign that says "Open"
```

### Negative text description (`--no`)

Signals to the model elements or aspects that you dont want to see in the image. 

```
--no <item1, item2, ...>
```

- Value: Comma-separated list of terms

> Example:

```
--no cars, trees, watermarks
```

## Image layout

### Aspect ratio (`--ar`)

Sets the width-to-height ratio of the image

```
--ar <width>:<height>
```

- Value: Two integers separated by a colon
- Default: `1:1`

> Example:

```
--ar 16:9
```

### Tile (`--tile`)

Creates images that are seamlessly tileable

```
--tile
```

- Value: None (boolean flag)

> Example:

```
--tile
```

---

## Separating and prioritizing

Use a double colon `::` to separate concepts, optionally followed by a weight. If omitted, the weight defaults to 1.

```
concept1 ::<weight1> concept2 ::<weight2> ...
```

- Weight values can be floating-point numbers within the range `-10.0` to `10.0`.
- Negative weights (e.g., `::-0.5`) de-emphasize or exclude a concept.

### Purpose

This syntax allows you to balance and blend different concepts in one prompt. Weights are normalized internally to maintain their proportional relationships.

### Examples

```
futuristic city ::2 cyberpunk skyline ::1
beautiful landscape ::1.5 mountains ::-0.5 water
serene lake ::2 foggy mountains ::1
portrait ::1.5 dramatic lighting ::1 dark background ::0.8
still life painting ::1 fruit ::-0.5
```

---

## Variation

### Chaos (`--chaos` or `--c`)

Controls variation or unpredictability in the output

```
--chaos <value>
```

- Value range: `0` to `100` (integer)
- Default: `0`

> Example

```
--chaos 50
```

### Weird (`--weird` or `--w`)

Introduces unconventional aesthetics

```
--weird <value>
```

- Value range: `0` to `3000` (integer)
- Default: `0`

> Example

```
--weird 1000
```

---

## Generation process

### Seed (`--seed`)

Sets a specific seed to reproduce outcomes

```
--seed <value>
```

- Value range: `0` to `4294967295` (integer)

> Example:

```
--seed 123456789
```

### Prompt permutation

Prompt permutation allows you to quickly generate multiple prompts by including comma-separated options within curly braces `{}`. The surrounding fixed text is repeated with each provided option to create separate prompt variations.

Enclose a comma-separated list of options within curly braces. 

```
A {red, blue, green} car
```

This expands to 3 prompts:

- `A red car`
- `A blue car`
- `A green car`

Repeat permutations.

```
A {red, blue} {car, truck} with {chrome, matte} finish
```

This expands to 222=8 prompts. 

Permute parameters.

```
portrait --ar {1:1, 16:9} --s {100, 500, 1000}
```

This expands to 23=6 prompts. 

Nest permutations.

```
{realistic, artistic} scene --v {5.2, 6 {, --style raw}} 
```

This expands to 2(2+1)=6 prompts:

- `realistic scene --v 5.2`
- `realistic scene --v 6`
- `realistic scene --v 6 --style raw`
- `artistic scene --v 5.2`
- `artistic scene --v 6`
- `artistic scene --v 6 --style raw`

Within a permutation group, use commas to separate portions, prefix a comma with a backslash to actually have it in the expanded prompt.

```
A {bright\, vibrant, dark\, moody} atmosphere
```

This expands to 2 prompts:

- `A bright, vibrant atmosphere`
- `A dark, moody atmosphere`

The total number of permutations may be limited based on subscription tier. Permutation prompts are only available in Fast Mode.

Permutation is great for exploring various syntaxes and prompt structures: 

```
beautiful woman{::, ::2, ::0.3, \,} sports car
```

expands into

- `beautiful woman:: sports car`
- `beautiful woman::2 sports car`
- `beautiful woman::0.3 sports car`
- `beautiful woman, sports car`



### Repeat (`--repeat` or `--r`)

The `--r` parameter produces multiple prompts, similarly to prompt permutation, but the multiplication happens on the model side. It can be combined with permutation prompts.

If a prompt includes the `--r` parameter, the model runs the same prompt multiple times to generate variations. It can be used with `--sref random` to generate different style references each time. 

```
--repeat <number>
```

- Value range: Basic Subscribers: 24, Standard Subscribers: 210, Pro/Mega Subscribers: 240

> Example:

```
--repeat 5
```

## Quality and speed

### Quality (`--quality` or `--q`)

Controls the time spent generating an image; affects detail

```
--quality <value>
```

- Values: `0.25`, `0.5`, `1` (default)

> Example

```
--quality 0.5
```

#### Turbo Mode (`--turbo`)

Generates images faster using additional GPU resources

```
--turbo
```

- Value: None (boolean flag)

#### Relax Mode (`--relax`)

Generates images in relaxed mode without consuming GPU time

```
--relax
```

- Value: None (boolean flag)

### Stop (`--stop`)

Stops image generation at a specified percentage of completion for different artistic effects

```
--stop <value>
```

- Value range: `10` to `100` (integer)
- Default: `100`

> Example:

```
--stop 80
```

---

## Summary

- **Order matters**: Image prompts come first (if used), followed by the text description, and then all parameters.
- **Parameter prefix**: Every parameter starts with `--` and, if required, is followed by a space and its value.
- **Advanced techniques**: Use multi-prompts with `::` and permutation prompts with `{}` to fine-tune creative direction and generate multiple variations.
- **Personalization and references**: `--sw` controls the weight of the style reference (`--sref`). `--s` controls the weight of personalization (`--p`, or of the default persona when `--p` is not provided). Style reference and personalization operate independently: each pulls the image in a distinct stylistic direction. To test the full effect of style reference without personalization influence, use: `--style raw --s 0`.
- **Model and feature dependencies**: Some parameters (e.g., `--iw`, `--sv`, `--p`, permutation prompts) are model-specific or depend on the subscription tier or mode (e.g., Fast Mode).
- **Text generation**: Use double quotation marks `"` to specify exact text to appear in the image.

## Prompt examples

1. **Basic Text-Only Prompt:**

```
/imagine prompt: A serene sunset over the ocean
```

2. **Prompt with Image URLs, Text, and Parameters:**

```
/imagine prompt: https://example.com/inspiration.jpg A portrait of a wise old man --style raw --v 5.1
```

3. **Prompt with Character and Style References:**

```
/imagine prompt: A hero in battle --cref https://example.com/hero.png --cw 75 --sref https://example.com/style.jpg --sw 150
```

4. **Multi-Prompt with Weighting:**

```
/imagine prompt: futuristic city ::2 cyberpunk skyline ::1 --chaos 20
```

5. **Permutation Prompt for Multiple Variations:**

```
/imagine prompt: A {red, blue, green} bird on a {flower, leaf} --ar {16:9, 1:1}
```

6. **Prompt with Personalization and Parameters:**

```
/imagine prompt: A vibrant garden in spring --p p123456789 --stylize 500 --seed 987654321
```

7. **Complex Mixed Prompt:**

```
/imagine prompt: {realistic, artistic} portrait of a {young, old} {man, woman} --style {raw, expressive} --v 6 --ar 1:1 --stylize {100, 1000}
```

8. **Prompt with Exclusions and Turbo Mode:**

```
/imagine prompt: A futuristic landscape at dusk --ar 21:9 --stylize 300 --chaos 50 --seed 987654321 --no buildings, cars --turbo
```

---

## Notes for parser implementers

### Parsing order

1. **Permutation:**

- Process all permutation groups `{...}`.
- Handle nested permutations.
- Expand into individual prompts.
- `a{b, c}d` should expand to `abd` `acd`. The spaces right around the `{` and `}` should be treated as they are. Spaces around the separating commas can be collapsed fully, as if there is no space.
- `\{` `\}` `\,` must produce the literal `{` `}` `,` in the expanded permutations

2. **Image referece:**

- Identify and validate image URLs or attachments at the start.
- Check for supported file formats.
- Handle multiple images.

3. **Text description:**

- Extract main prompt text.
- Segment text by weight markers `::`.
- Handle escaped characters.
- Identify text in double quotes `"` for explicit text generation.

4. **Parameter Processing:**

- Extract parameters starting with `--`.
- Parse parameter values.
- Handle boolean flags.
- Validate parameter ranges.
- Values should be typically strings, unless its obviously an int or float. Version "number" should be kept a string.

### Boolean Parameters

- If a parameter is followed by another parameter (e.g., `--tile --ar 16:9`), it's treated as a boolean flag.

### Multi-Value Parameters

- Some parameters accept multiple values (e.g., `--no cars, trees`).

### Parameter Validation

- Numeric ranges are enforced.
- Aspect ratios must be valid integers.
- Version numbers must be supported.
- Style names and codes must be recognized.

### Error handling

The parser should handle common errors gracefully:

- Invalid URL formats.
- Malformed permutation syntax.
- Invalid parameter values.
- Missing required components.
- Unsupported parameter combinations.
```

## File: examples/basic_usage.py (Size: 2.71 KB)

```
#!/usr/bin/env python3
# this_file: examples/basic_usage.py

"""
Example script demonstrating basic usage of the midjargon package.
"""

from rich.console import Console
from rich.panel import Panel

from midjargon import expand_midjargon_input, parse_midjargon_prompt

console = Console()


def main():
    # Example 1: Basic prompt parsing
    console.print("\n[bold blue]Example 1: Basic Prompt[/]")
    prompt = "a beautiful landscape --ar 16:9 --stylize 200"
    result = parse_midjargon_prompt(prompt)
    console.print(
        Panel(
            f"Text: {result.text}\n"
            f"Aspect Ratio: {result.parameters.aspect}\n"
            f"Stylize: {result.parameters.stylize}"
        )
    )

    # Example 2: Using image references
    console.print("\n[bold blue]Example 2: Image Reference[/]")
    prompt = "https://example.com/image.jpg a photo in this style --stylize 100"
    result = parse_midjargon_prompt(prompt)
    console.print(
        Panel(
            f"Text: {result.text}\n"
            f"Image URL: {result.images[0].url if result.images else 'None'}\n"
            f"Stylize: {result.parameters.stylize}"
        )
    )

    # Example 3: Permutations
    console.print("\n[bold blue]Example 3: Permutations[/]")
    prompt = "a {red, blue} bird on a {green, yellow} tree"
    variants = expand_midjargon_input(prompt)
    for i, variant in enumerate(variants, 1):
        console.print(f"Variant {i}: {variant.prompt.text}")

    # Example 4: Weighted prompts
    console.print("\n[bold blue]Example 4: Weighted Prompts[/]")
    prompt = "first style::0.7 second style::0.3"
    variants = expand_midjargon_input(prompt)
    for variant in variants:
        console.print(Panel(f"Text: {variant.prompt.text}\nWeight: {variant.weight}"))

    # Example 5: Style references
    console.print("\n[bold blue]Example 5: Style References[/]")
    prompt = "test --sref p123456 --sw 200"
    result = parse_midjargon_prompt(prompt)
    if result.parameters.style_reference:
        console.print(
            Panel(
                f"Text: {result.text}\n"
                f"Style Code: {result.parameters.style_reference.code}\n"
                f"Weight: {result.parameters.style_reference.weight}"
            )
        )

    # Example 6: Combined features
    console.print("\n[bold blue]Example 6: Combined Features[/]")
    prompt = "a {vintage, modern} {portrait, landscape}::0.6 another style::0.4"
    variants = expand_midjargon_input(prompt)
    console.print(f"Total variants: {len(variants)}")
    for i, variant in enumerate(variants, 1):
        console.print(
            Panel(
                f"Variant {i}:\nText: {variant.prompt.text}\nWeight: {variant.weight}"
            )
        )


if __name__ == "__main__":
    main()
```

## File: package.toml (Size: 0.43 KB)

```
# Package configuration
# this_file: package.toml
[package]
include_cli = true      # Include CLI boilerplate
include_logging = true  # Include logging setup
use_pydantic = true     # Use Pydantic for data validation
use_rich = true         # Use Rich for terminal output

[features]
mkdocs = false          # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows
```

## File: pyproject.toml (Size: 4.21 KB)

```
# this_file: pyproject.toml
[project]
name = "midjargon"
version = "0.1.0"
description = "A package for parsing and manipulating Midjourney-style prompts"
requires-python = ">=3.10"
readme = "README.md"
license = { text = "Apache-2.0" }
dependencies = [
    "pydantic>=2.0.0",
    "rich>=13.0.0",
    "fire>=0.5.0",
    "python-box>=7.3.2",
    "fal-client>=0.5.8",
]

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.optional-dependencies]
test = [
    "pytest>=8.0.0",
    "pytest-cov>=4.1.0",
]

[project.urls]
Documentation = "https://github.com/twardoch/midjargon#readme"
Issues = "https://github.com/twardoch/midjargon/issues"
Source = "https://github.com/twardoch/midjargon"

[project.scripts]
midjargon = "midjargon.__main__:main"

[build-system]
requires = ["hatchling>=1.21.0", "hatch-vcs>=0.3.0"]
build-backend = "hatchling.build"

[tool.rye]
managed = true
dev-dependencies = [
    "black>=24.2.0",
    "pytest>=8.0.0",
    "pytest-cov>=4.1.0",
    "ruff>=0.2.0",
    "mypy>=1.8.0",
]

[tool.hatch.metadata]
allow-direct-references = true

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "C",  # flake8-comprehensions
    "B",  # flake8-bugbear
    "UP",  # pyupgrade
]
ignore = []

[tool.ruff.lint.isort]
known-first-party = ["midjargon"]

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[tool.coverage.paths]
midjargon = ["src/midjargon", "*/src/midjargon"]
tests = ["tests", "*/midjargon/tests"]

[tool.coverage.run]
branch = true
source = ["midjargon"]
parallel = true
source_pkgs = ["midjargon", "tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
]

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.pytest.ini_options]
testpaths = ["tests"]
filterwarnings = [
    "error",
    "ignore::DeprecationWarning",
    "ignore::UserWarning",
]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "rounds: Number of rounds",
]

[tool.hatch.build.hooks.vcs]
version-file = "src/midjargon/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/midjargon"]

[[tool.hatch.envs.all.matrix]]
python = ["3.11", "3.12"]

[tool.hatch.envs.default]
dependencies = ["pytest", "pytest-cov", "mypy>=1.0.0", "ruff>=0.1.0"]

[tool.hatch.envs.default.scripts]
lint = ["ruff check src/midjargon tests", "ruff format src/midjargon tests"]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/midjargon --cov=tests {args:tests}"
type-check = "mypy src/midjargon tests"

[tool.hatch.envs.lint]
dependencies = ["mypy>=1.0.0", "ruff>=0.1.0"]
detached = true

[tool.hatch.envs.lint.scripts]
all = ["style", "typing"]
fmt = ["fd -e py -x pyupgrade --keep-runtime-typing --py310-plus", "ruff format {args:.}", "ruff check --fix --unsafe-fixes {args:.}"]
style = ["fd -e py -x pyupgrade --keep-runtime-typing --py310-plus", "ruff format {args:.}", "ruff check --fix --unsafe-fixes {args:.}", "ruff format {args:.}"]
typing = "mypy --install-types --non-interactive {args:src/midjargon tests}"

[tool.hatch.envs.test]
dependencies = [
  "pytest>=7.0.0",
  "pytest-cov>=4.0.0",
  "midjargon[test]",
]

[tool.hatch.envs.test.scripts]
test = "pytest --cov=src/midjargon --cov-report=term-missing --cov-branch --no-cov-on-fail {args:tests}"
test-cov = "pytest --cov=src/midjargon --cov-report=term-missing --cov-branch --no-cov-on-fail {args:tests}"

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
]
```

## File: src/midjargon/__init__.py (Size: 0.81 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/__init__.py

"""Midjargon package for parsing and manipulating Midjourney-style prompts."""

__version__ = "0.1.0"

from midjargon.core.input import expand_midjargon_input
from midjargon.core.models import (
    CharacterReference,
    ImageReference,
    MidjourneyParameters,
    MidjourneyPrompt,
    MidjourneyVersion,
    PromptVariant,
    StyleMode,
    StyleReference,
)
from midjargon.core.parser import (
    parse_midjargon_prompt,
    parse_midjargon_prompt_to_dict,
)

__all__ = [
    "CharacterReference",
    "ImageReference",
    "MidjourneyParameters",
    "MidjourneyPrompt",
    "MidjourneyVersion",
    "PromptVariant",
    "StyleMode",
    "StyleReference",
    "expand_midjargon_input",
    "parse_midjargon_prompt",
    "parse_midjargon_prompt_to_dict",
]
```

## File: src/midjargon/cli/__init__.py (Size: 0.04 KB)

```
# this_file: src/midjargon/cli/__init__.py
```

## File: src/midjargon/cli/main.py (Size: 4.90 KB)

```
#!/usr/bin/env -S uv run
# this_file: src/midjargon/cli/main.py
# /// script
# dependencies = ["fire", "rich"]
# ///

import sys
from collections.abc import Sequence
from typing import Any

import fire
from rich.console import Console

from midjargon.core.input import expand_midjargon_input
from midjargon.core.models import PromptVariant
from midjargon.engines.fal import FalParser
from midjargon.engines.midjourney import MidjourneyParser

# Set up console for output
console = Console()
error_console = Console(stderr=True)


def format_json_output(variants: Sequence[PromptVariant]) -> list[dict[str, Any]]:
    """Format variants as JSON output."""
    return [variant.prompt.model_dump() for variant in variants]


def format_rich_output(variants: Sequence[PromptVariant]) -> str:
    """Format variants as rich text output."""
    if len(variants) == 1:
        return variants[0].prompt.to_string()
    return "\n".join(f"{i + 1}. {v.prompt.to_string()}" for i, v in enumerate(variants))


class MidjargonCLI:
    """CLI interface for midjargon."""

    def json(self, prompt: str, no_color: bool = False) -> None:
        """Parse a prompt to MidjargonDict format.

        Args:
            prompt: The prompt to parse.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            format_json_output(variants)
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.

        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
                mj_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(mj_prompt.model_dump())

            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    params = " ".join(
                        f"--{k} {v}"
                        for k, v in result.items()
                        if k not in {"text", "image_prompts", "extra_params"}
                        and v is not None
                    )
                    console.print(
                        f"{result['text']} {params}",
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.

        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())

            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)

    def perm(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Expand permutations in a prompt.

        Args:
            prompt: The prompt to expand.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            if json_output:
                format_json_output(variants)
            else:
                pass
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)


def main() -> None:
    """Main entry point."""
    try:
        fire.Fire(MidjargonCLI)
    except Exception as e:
        error_console.print(f"[red]Error:[/red] {e!s}")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

## File: src/midjargon/core/__init__.py (Size: 0.04 KB)

```
# this_file: src/midjargon/core/__init__.py
```

## File: src/midjargon/core/input.py (Size: 3.55 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/input.py

from midjargon.core.models import PromptVariant
from midjargon.core.parser import parse_midjargon_prompt
from midjargon.core.permutations import expand_permutations


def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
    """Parse a prompt with optional weights.

    Args:
        prompt: Raw prompt string with optional weights.

    Returns:
        List of (prompt, weight) tuples.

    Raises:
        ValueError: If prompt is empty or invalid.
    """
    if not prompt or not prompt.strip():
        msg = "Empty prompt"
        raise ValueError(msg)

    # Split on double colon and parse weights
    result = []
    current_prompt = []
    i = 0

    while i < len(prompt):
        if prompt[i : i + 2] == "::" and (i == 0 or prompt[i - 1] != "\\"):
            # Found weight separator
            text = "".join(current_prompt).strip()
            if not text:
                msg = "Empty prompt before weight"
                raise ValueError(msg)

            # Parse weight
            i += 2
            weight_start = i
            while i < len(prompt) and (prompt[i].isdigit() or prompt[i] == "."):
                i += 1

            if i == weight_start:
                msg = f"Missing weight after :: at position {i - 2}"
                raise ValueError(msg)

            try:
                weight = float(prompt[weight_start:i])
                if weight <= 0:
                    msg = f"Weight must be positive at position {weight_start}"
                    raise ValueError(msg)
            except ValueError as e:
                msg = f"Invalid weight at position {weight_start}: {prompt[weight_start:i]}"
                raise ValueError(msg) from e

            result.append((text, weight))
            current_prompt = []
        else:
            current_prompt.append(prompt[i])
            i += 1

    # Handle last part
    if current_prompt:
        text = "".join(current_prompt).strip()
        if text:
            result.append((text, 1.0))  # Default weight

    if not result:
        msg = "Empty prompt"
        raise ValueError(msg)

    # Normalize weights to sum to 1.0
    total_weight = sum(weight for _, weight in result)
    if total_weight > 0:
        result = [(text, weight / total_weight) for text, weight in result]

    return result


def expand_midjargon_input(prompt: str) -> list[PromptVariant]:
    """Expand a midjourney prompt by processing permutations and returning a list of prompt variants.

    Args:
        prompt: The prompt string to expand.

    Returns:
        A list of PromptVariant objects, each containing an expanded prompt.

    Raises:
        ValueError: If the prompt is invalid or empty.
    """
    # First split into weighted prompts
    weighted_prompts = parse_weighted_prompt(prompt)

    # Process each weighted prompt
    result = []
    for text, weight in weighted_prompts:
        # Expand permutations for this prompt
        expanded = expand_permutations(text)
        for expanded_text in expanded:
            # Parse the expanded text into a MidjourneyPrompt
            try:
                prompt_obj = parse_midjargon_prompt(expanded_text)
                variant = PromptVariant(prompt=prompt_obj, weight=weight)
                # Ensure the weight is properly set in both places
                variant.prompt.weight = weight
                result.append(variant)
            except ValueError as e:
                msg = f"Failed to parse expanded prompt '{expanded_text}': {e}"
                raise ValueError(msg) from e

    return result
```

## File: src/midjargon/core/main.py (Size: 1.50 KB)

```
# this_file: src/midjargon/core/main.py

from typing import Any

from midjargon.core.models import PromptVariant


def format_json_output(
    variants: list[PromptVariant], include_parsed: bool = False
) -> dict[str, Any]:
    """Format prompt variants as JSON output.

    Args:
        variants: List of prompt variants to format.
        include_parsed: Whether to include parsed data in output.

    Returns:
        Dictionary containing formatted output.
    """
    if not variants:
        return {}

    # For single variants without weights, return simple format
    if len(variants) == 1 and variants[0].weight == 1.0:
        variant = variants[0].prompt
        result = {
            "text": variant.text,
            "images": [str(img.url) for img in variant.images],
            "parameters": variant.parameters.model_dump(exclude_none=True),
        }
        if include_parsed:
            result["parsed"] = variant.model_dump(exclude_none=True)
        return result

    # For multiple variants or weighted variants, return array format
    results = []
    for variant in variants:
        prompt = variant.prompt
        result = {
            "text": prompt.text,
            "images": [str(img.url) for img in prompt.images],
            "parameters": prompt.parameters.model_dump(exclude_none=True),
            "weight": variant.weight,
        }
        if include_parsed:
            result["parsed"] = prompt.model_dump(exclude_none=True)
        results.append(result)
    return {"variants": results}
```

## File: src/midjargon/core/models.py (Size: 13.96 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/models.py

from enum import Enum
from typing import Any, Optional, TypeVar

from pydantic import (
    BaseModel,
    Field,
    HttpUrl,
    field_validator,
    model_validator,
)

T = TypeVar("T", bound="BaseModel")


class MidjourneyVersion(str, Enum):
    """Midjourney model version."""

    V4 = "v4"
    V5 = "v5"
    V5_1 = "v5.1"
    V5_2 = "v5.2"
    V6 = "v6"
    V6_1 = "v6.1"
    NIJI4 = "niji4"
    NIJI5 = "niji5"
    NIJI6 = "niji6"

    @classmethod
    def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
        """Handle missing values by trying to normalize the input."""
        try:
            # Try to normalize version string
            value = str(value).lower().strip()

            # Handle numeric versions (e.g., 4, 5, 6)
            if value.replace(".", "").isdigit():
                if "." not in value:
                    value = f"v{value}"
                else:
                    value = f"v{value}"

            # Handle niji versions
            if value == "niji":
                return cls.NIJI6
            if value.startswith("niji"):
                for member in cls:
                    if member.value == value:
                        return member
                return cls.NIJI6

            # Handle v prefix
            if not value.startswith("v") and not value.startswith("niji"):
                value = f"v{value}"

            # Try exact match first
            for member in cls:
                if member.value == value:
                    return member

            # Try prefix match for v* versions
            if value.startswith("v"):
                base_version = value.split(".")[0]
                latest_version = None
                for member in cls:
                    if member.value.startswith(base_version):
                        if (
                            latest_version is None
                            or member.value > latest_version.value
                        ):
                            latest_version = member
                if latest_version:
                    return latest_version

            return None
        except Exception:
            return None


class StyleMode(str, Enum):
    """Available style modes."""

    RAW = "raw"
    CUTE = "cute"
    EXPRESSIVE = "expressive"
    SCENIC = "scenic"
    ORIGINAL = "original"


class ImageReference(BaseModel):
    """Reference to an image."""

    url: HttpUrl
    weight: float = Field(default=1.0, ge=0.0, le=2.0)

    def __str__(self) -> str:
        """Convert to string format."""
        return str(self.url)


class CharacterReference(BaseModel):
    """Reference to a character."""

    url: HttpUrl | None = None
    code: str | None = None
    weight: float = Field(default=1.0, ge=0.0, le=2.0)

    @model_validator(mode="before")
    @classmethod
    def validate_reference(cls, data: dict[str, Any]) -> dict[str, Any]:
        """Validate that at least one of url or code is provided."""
        if not data.get("url") and not data.get("code"):
            raise ValueError("At least one of url or code must be provided")
        return data


class StyleReference(BaseModel):
    """Reference to a style."""

    url: HttpUrl | None = None
    code: str | None = None
    weight: float = Field(default=1.0, ge=0.0, le=2.0)

    @model_validator(mode="before")
    @classmethod
    def validate_reference(cls, data: dict[str, Any]) -> dict[str, Any]:
        """Validate that at least one of url or code is provided."""
        if not data.get("url") and not data.get("code"):
            raise ValueError("At least one of url or code must be provided")
        return data


class MidjourneyParameters(BaseModel):
    """Parameters for a Midjourney prompt."""

    version: MidjourneyVersion | str | None = None
    style: StyleMode | None = None
    stylize: float = Field(default=100.0, ge=0.0, le=1000.0)
    chaos: float = Field(default=0.0, ge=0.0, le=100.0)
    weird: float = Field(default=0.0, ge=0.0, le=3000.0)
    seed: int | str | None = None
    aspect_width: int | None = None
    aspect_height: int | None = None
    aspect_ratio: str | None = None
    tile: bool = False
    turbo: bool = False
    relax: bool = False
    no: list[str] = Field(default_factory=list)
    character_reference: list[CharacterReference] = Field(default_factory=list)
    style_reference: list[StyleReference] = Field(default_factory=list)
    character_weight: float = Field(default=100.0, ge=0.0, le=200.0)
    style_weight: float | None = Field(default=None, ge=0.0, le=200.0)
    style_version: int = Field(default=2, ge=1, le=3)
    repeat: int | None = Field(default=None, ge=1, le=40)
    personalization: bool = False
    quality: float = Field(default=1.0, ge=0.25, le=2.0)
    negative_prompt: str | None = None
    extra_params: dict[str, Any] = Field(default_factory=dict)

    @field_validator("aspect_ratio")
    @classmethod
    def validate_aspect_ratio(cls, v: str | None) -> str | None:
        """Validate aspect ratio format."""
        if v is not None:
            try:
                parts = v.split(":")
                if len(parts) != 2:
                    msg = "Invalid aspect ratio format: must be width:height"
                    raise ValueError(msg)
                w, h = map(int, parts)
                if w <= 0 or h <= 0:
                    msg = "Invalid aspect ratio: values must be positive"
                    raise ValueError(msg)
                return f"{w}:{h}"
            except ValueError as e:
                msg = f"Invalid aspect ratio format: {e}"
                raise ValueError(msg)
        return v

    @field_validator("version")
    @classmethod
    def validate_version(
        cls, v: MidjourneyVersion | str | None
    ) -> MidjourneyVersion | str | None:
        """Validate version value."""
        if v is None:
            return None
        if isinstance(v, str) and v.lower() == "niji":
            return "niji"
        if isinstance(v, str):
            try:
                return MidjourneyVersion(v)
            except ValueError:
                msg = f"Invalid version value: {v}"
                raise ValueError(msg)
        return v

    @field_validator("seed")
    @classmethod
    def validate_seed(cls, v: int | str | None) -> int | str | None:
        """Validate seed value."""
        if v is None:
            return None
        if isinstance(v, str) and v.lower() in {"random", "none"}:
            return v.lower()
        if isinstance(v, int | str):
            try:
                return int(v)
            except ValueError:
                msg = f"Invalid seed value: {v}"
                raise ValueError(msg)
        return v

    @property
    def aspect(self) -> str | None:
        """Get the aspect ratio string."""
        if self.aspect_ratio:
            return self.aspect_ratio
        if self.aspect_width and self.aspect_height:
            return f"{self.aspect_width}:{self.aspect_height}"
        return None

    def to_string(self) -> str:
        """Convert parameters to string format."""
        parts = []

        # Handle version
        if self.version:
            parts.append(f"--v {self.version}")

        # Handle style
        if self.style:
            parts.append(f"--style {self.style.value}")

        # Handle numeric parameters
        if self.stylize != 100.0:
            parts.append(f"--s {self.stylize}")
        if self.chaos > 0:
            parts.append(f"--c {self.chaos}")
        if self.weird > 0:
            parts.append(f"--weird {self.weird}")
        if self.seed is not None:
            parts.append(f"--seed {self.seed}")

        # Handle aspect ratio
        if self.aspect:
            parts.append(f"--ar {self.aspect}")

        # Handle boolean flags
        if self.tile:
            parts.append("--tile")
        if self.turbo:
            parts.append("--turbo")
        if self.relax:
            parts.append("--relax")

        # Handle negative prompts
        if self.no:
            parts.append(f"--no {','.join(self.no)}")

        # Handle references
        if self.character_reference:
            for ref in self.character_reference:
                if ref.url:
                    parts.append(f"--cref {ref.url}")
                elif ref.code:
                    parts.append(f"--cref {ref.code}")
                if ref.weight != 1.0:
                    parts.append(f"--cw {ref.weight}")

        if self.style_reference:
            for ref in self.style_reference:
                if ref.url:
                    parts.append(f"--sref {ref.url}")
                elif ref.code:
                    parts.append(f"--sref {ref.code}")
                if ref.weight != 1.0:
                    parts.append(f"--sw {ref.weight}")

        # Handle other parameters
        if self.character_weight != 100.0:
            parts.append(f"--cw {self.character_weight}")
        if self.style_weight is not None:
            parts.append(f"--sw {self.style_weight}")
        if self.style_version != 2:
            parts.append(f"--sv {self.style_version}")
        if self.repeat is not None:
            parts.append(f"--r {self.repeat}")
        if self.personalization:
            parts.append("--p")
        if self.quality != 1.0:
            parts.append(f"--q {self.quality}")
        if self.negative_prompt:
            parts.append(f"--no {self.negative_prompt}")

        # Handle extra parameters
        for key, value in self.extra_params.items():
            if value is True:
                parts.append(f"--{key}")
            elif value is not False:
                parts.append(f"--{key} {value}")

        return " ".join(parts)


class MidjourneyPrompt(BaseModel):
    """A Midjourney prompt."""

    text: str
    image_prompts: list[ImageReference] = Field(default_factory=list)
    parameters: MidjourneyParameters = Field(default_factory=MidjourneyParameters)
    weight: float = Field(default=1.0, ge=0.0, le=2.0)

    def __str__(self) -> str:
        """Convert to string format."""
        parts = [self.text]

        # Add image prompts
        for img in self.image_prompts:
            parts.append(str(img))

        # Add parameters
        param_str = self.parameters.to_string()
        if param_str:
            parts.append(param_str)

        return " ".join(parts)

    def to_string(self) -> str:
        """Convert to string format."""
        return str(self)

    def model_dump(self, **kwargs: Any) -> dict[str, Any]:
        """Override model_dump to handle nested models correctly."""
        data = super().model_dump(**kwargs)
        if "parameters" in data:
            params = data["parameters"]
            data.update(params)
            del data["parameters"]
        return data

    # Property methods to expose parameters
    @property
    def version(self) -> MidjourneyVersion | str | None:
        """Get version parameter."""
        return self.parameters.version

    @property
    def style(self) -> StyleMode | None:
        """Get style parameter."""
        return self.parameters.style

    @property
    def stylize(self) -> float:
        """Get stylize parameter."""
        return self.parameters.stylize

    @property
    def chaos(self) -> float:
        """Get chaos parameter."""
        return self.parameters.chaos

    @property
    def weird(self) -> float:
        """Get weird parameter."""
        return self.parameters.weird

    @property
    def seed(self) -> int | str | None:
        """Get seed parameter."""
        return self.parameters.seed

    @property
    def aspect_width(self) -> int | None:
        """Get aspect width parameter."""
        return self.parameters.aspect_width

    @property
    def aspect_height(self) -> int | None:
        """Get aspect height parameter."""
        return self.parameters.aspect_height

    @property
    def aspect_ratio(self) -> str | None:
        """Get aspect ratio parameter."""
        return self.parameters.aspect_ratio

    @property
    def aspect(self) -> str | None:
        """Get aspect ratio string."""
        return self.parameters.aspect

    @property
    def tile(self) -> bool:
        """Get tile parameter."""
        return self.parameters.tile

    @property
    def turbo(self) -> bool:
        """Get turbo parameter."""
        return self.parameters.turbo

    @property
    def relax(self) -> bool:
        """Get relax parameter."""
        return self.parameters.relax

    @property
    def no(self) -> list[str]:
        """Get no parameter."""
        return self.parameters.no

    @property
    def character_reference(self) -> list[CharacterReference]:
        """Get character reference parameter."""
        return self.parameters.character_reference

    @property
    def style_reference(self) -> list[StyleReference]:
        """Get style reference parameter."""
        return self.parameters.style_reference

    @property
    def character_weight(self) -> float:
        """Get character weight parameter."""
        return self.parameters.character_weight

    @property
    def style_weight(self) -> float | None:
        """Get style weight parameter."""
        return self.parameters.style_weight

    @property
    def style_version(self) -> int:
        """Get style version parameter."""
        return self.parameters.style_version

    @property
    def repeat(self) -> int | None:
        """Get repeat parameter."""
        return self.parameters.repeat

    @property
    def personalization(self) -> bool:
        """Get personalization parameter."""
        return self.parameters.personalization

    @property
    def quality(self) -> float:
        """Get quality parameter."""
        return self.parameters.quality

    @property
    def negative_prompt(self) -> str | None:
        """Get negative prompt parameter."""
        return self.parameters.negative_prompt

    @property
    def extra_params(self) -> dict[str, Any]:
        """Get extra parameters."""
        return self.parameters.extra_params


class PromptVariant(BaseModel):
    """A variant of a prompt with weight."""

    prompt: MidjourneyPrompt
    weight: float = 1.0
```

## File: src/midjargon/core/parameters.py (Size: 7.14 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/parameters.py

import shlex
from typing import Any
from urllib.parse import urlparse

from pydantic import HttpUrl

from midjargon.core.models import (
    CharacterReference,
    MidjourneyVersion,
    StyleMode,
    StyleReference,
)

# Parameter aliases mapping
ALIASES = {
    # Version aliases
    "v": "version",
    "ver": "version",
    "niji": "version",
    # Style aliases
    "s": "stylize",
    # Chaos aliases
    "c": "chaos",
    # Weird aliases
    "w": "weird",
    # Seed aliases
    "sameseed": "seed",
    # Aspect ratio aliases
    "ar": "aspect_ratio",
    # Character reference aliases
    "cref": "character_reference",
    # Style reference aliases
    "sref": "style_reference",
    # Character weight aliases
    "cw": "character_weight",
    # Style weight aliases
    "sw": "style_weight",
    # Style version aliases
    "sv": "style_version",
    # Personalization aliases
    "p": "personalization",
}

# Parameters that can have multiple values
MULTI_VALUE_PARAMS = {"no", "character_reference", "style_reference"}

# Parameters that are flags (no value needed)
FLAG_PARAMS = {"tile", "turbo", "relax", "fast", "video", "personalization"}

# Parameters that should remain as strings
STRING_PARAMS = {"aspect_ratio", "negative_prompt"}

# Parameters that should be integers
INT_PARAMS = {"style_version", "repeat"}

# Special seed values
SPECIAL_SEED_VALUES = {"random", "none"}


def is_url(value: str) -> bool:
    """Check if a string is a valid URL."""
    try:
        result = urlparse(value)
        return all([result.scheme, result.netloc])
    except:
        return False


def convert_parameter_value(param: str, value: str | None) -> Any:
    """Convert a parameter value to the appropriate type."""
    # Handle flag parameters
    if param in FLAG_PARAMS:
        if value is None:
            return True
        val_lower = value.lower()
        if val_lower in {"true", "1", "yes", "on"}:
            return True
        if val_lower in {"false", "0", "no", "off"}:
            return False
        return bool(value)

    # Handle empty values
    if value is None:
        return None

    # Handle string parameters
    if param in STRING_PARAMS:
        return str(value)

    # Handle version parameter
    if param == "version":
        if value.lower() == "niji":
            return "niji"
        try:
            return MidjourneyVersion(value)
        except ValueError:
            msg = f"Invalid version value: {value}"
            raise ValueError(msg)

    # Handle seed parameter
    if param == "seed":
        if value.lower() in SPECIAL_SEED_VALUES:
            return value.lower()
        try:
            return int(value)
        except ValueError:
            msg = f"Invalid seed value: {value}"
            raise ValueError(msg)

    # Handle integer parameters
    if param in INT_PARAMS:
        try:
            return int(value)
        except ValueError:
            msg = f"Invalid integer value for {param}: {value}"
            raise ValueError(msg)

    # Handle float parameters
    if param in {
        "stylize",
        "chaos",
        "weird",
        "quality",
        "character_weight",
        "style_weight",
        "image_weight",
        "stop",
    }:
        try:
            return float(value)
        except ValueError:
            msg = f"Invalid numeric value for {param}: {value}"
            raise ValueError(msg)

    # Handle style parameter
    if param == "style":
        try:
            return StyleMode(value)
        except ValueError:
            msg = f"Invalid style value: {value}"
            raise ValueError(msg)

    # Handle character and style references
    if param in {"character_reference", "style_reference"}:
        ref_class = (
            CharacterReference if param == "character_reference" else StyleReference
        )
        try:
            if is_url(value):
                return ref_class(url=HttpUrl(value), weight=1.0)
            else:
                # Handle reference codes (e.g., p123456)
                return ref_class(code=value, weight=1.0)
        except Exception as e:
            msg = f"Invalid reference value for {param}: {value} ({str(e)})"
            raise ValueError(msg)

    # Default case: return as string
    return value


def parse_parameters(param_str: str) -> dict[str, Any]:
    """Parse parameters from a string into a dictionary."""
    if not param_str:
        return {}

    # Split parameters while preserving quoted strings
    try:
        parts = shlex.split(param_str)
    except ValueError as e:
        msg = f"Failed to parse parameters: {e}"
        raise ValueError(msg)

    result: dict[str, Any] = {}
    current_param = None
    current_values = []

    for part in parts:
        if part.startswith("--"):
            # Store previous parameter if exists
            if current_param:
                try:
                    if current_param in MULTI_VALUE_PARAMS:
                        # Handle multi-value parameters
                        values = (
                            [
                                convert_parameter_value(current_param, v)
                                for v in current_values
                            ]
                            if current_values
                            else [True]
                        )
                        if current_param in result:
                            result[current_param].extend(values)
                        else:
                            result[current_param] = values
                    else:
                        # Handle single value parameters
                        value = convert_parameter_value(
                            current_param, current_values[0] if current_values else None
                        )
                        result[current_param] = value
                except Exception as e:
                    msg = f"Failed to parse parameter {current_param}: {e}"
                    raise ValueError(msg)

            # Start new parameter
            current_param = ALIASES.get(
                part[2:], part[2:]
            )  # Remove -- and resolve alias
            current_values = []
        elif current_param:
            current_values.append(part)
        else:
            msg = f"Unexpected value without parameter: {part}"
            raise ValueError(msg)

    # Handle last parameter
    if current_param:
        try:
            if current_param in MULTI_VALUE_PARAMS:
                values = (
                    [convert_parameter_value(current_param, v) for v in current_values]
                    if current_values
                    else [True]
                )
                if current_param in result:
                    result[current_param].extend(values)
                else:
                    result[current_param] = values
            else:
                value = convert_parameter_value(
                    current_param, current_values[0] if current_values else None
                )
                result[current_param] = value
        except Exception as e:
            msg = f"Failed to parse parameter {current_param}: {e}"
            raise ValueError(msg)

    return result
```

## File: src/midjargon/core/parser.py (Size: 7.61 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/parser.py

from typing import Any
from urllib.parse import urlparse

from pydantic import HttpUrl

from midjargon.core.models import (
    CharacterReference,
    ImageReference,
    MidjourneyPrompt,
    MidjourneyVersion,
    StyleMode,
    StyleReference,
)


def is_valid_image_url(url: str) -> bool:
    """Check if a URL is a valid image URL."""
    try:
        result = urlparse(url)
        return bool(
            result.scheme
            and result.netloc
            and any(
                result.path.lower().endswith(ext)
                for ext in [".jpg", ".jpeg", ".png", ".gif", ".webp"]
            )
        )
    except Exception:
        return False


def is_url(text: str) -> bool:
    """Check if text is a URL."""
    try:
        result = urlparse(text)
        return all([result.scheme, result.netloc])
    except Exception:
        return False


def extract_image_urls(prompt: str) -> tuple[list[ImageReference], str]:
    """Extract image URLs from the start of a prompt.

    Args:
        prompt: The raw prompt string.

    Returns:
        A tuple of (list of ImageReference objects, remaining text).
    """
    parts = prompt.strip().split()
    refs = []
    text_start = 0

    for i, part in enumerate(parts):
        if is_url(part):
            refs.append(ImageReference(url=HttpUrl(part)))
            text_start = i + 1
        else:
            break

    return refs, " ".join(parts[text_start:])


def parse_parameters(param_str: str) -> dict[str, Any]:
    """Parse parameter string into a dictionary.

    Args:
        param_str: The parameter string to parse.

    Returns:
        Dictionary of parameter names and values.

    Raises:
        ValueError: If parameter parsing fails.
    """
    params: dict[str, Any] = {
        "character_reference": [],
        "style_reference": [],
    }

    # Split into individual parameters
    parts = param_str.split("--")
    for part in parts[1:]:  # Skip empty first part
        if not part.strip():
            continue

        # Split parameter name and value
        param_parts = part.strip().split(maxsplit=1)
        param_name = param_parts[0]
        param_value = param_parts[1] if len(param_parts) > 1 else None

        # Handle special parameters
        if param_name == "cref":
            if param_value:
                if is_url(param_value):
                    params["character_reference"].append(
                        CharacterReference(url=HttpUrl(param_value), code=None)
                    )
                else:
                    params["character_reference"].append(
                        CharacterReference(url=None, code=param_value)
                    )
        elif param_name == "sref":
            if param_value:
                if is_url(param_value):
                    params["style_reference"].append(
                        StyleReference(url=HttpUrl(param_value), code=None)
                    )
                else:
                    params["style_reference"].append(
                        StyleReference(url=None, code=param_value)
                    )
        elif param_name == "ar":
            if param_value:
                try:
                    w, h = map(int, param_value.split(":"))
                    params["aspect_ratio"] = f"{w}:{h}"
                    params["aspect_width"] = w
                    params["aspect_height"] = h
                except ValueError as e:
                    msg = f"Invalid aspect ratio format: {e}"
                    raise ValueError(msg) from e
        elif param_name == "v" or param_name == "version":
            if param_value:
                try:
                    version = MidjourneyVersion(param_value)
                    params["version"] = version
                except ValueError as e:
                    msg = f"Invalid version value: {param_value}"
                    raise ValueError(msg) from e
        elif param_name == "style":
            if param_value:
                try:
                    style = StyleMode(param_value.lower())
                    params["style"] = style
                except ValueError as e:
                    msg = f"Invalid style value: {param_value}"
                    raise ValueError(msg) from e
        # Handle flag parameters
        elif param_value is None:
            if param_name in {"tile", "turbo", "relax"}:
                params[param_name] = True
            else:
                msg = f"Invalid flag parameter: {param_name}"
                raise ValueError(msg)
        # Handle numeric parameters
        elif param_value.replace(".", "").isdigit():
            if param_name in {"stylize", "s"}:
                params["stylize"] = int(param_value)
            elif param_name in {"chaos", "c"}:
                params["chaos"] = int(param_value)
            elif param_name in {"weird", "w"}:
                params["weird"] = int(param_value)
            elif param_name == "seed" and param_value != "random":
                params["seed"] = int(param_value)
            elif param_name == "cw":
                params["character_weight"] = float(param_value)
            elif param_name == "sw":
                params["style_weight"] = float(param_value)
            else:
                params[param_name] = (
                    float(param_value) if "." in param_value else int(param_value)
                )
        # Handle boolean parameters
        elif param_value.lower() in ("true", "false"):
            params[param_name] = param_value.lower() == "true"
        # Handle list parameters
        elif param_value.startswith("[") and param_value.endswith("]"):
            try:
                items = [
                    item.strip()
                    for item in param_value[1:-1].split(",")
                    if item.strip()
                ]
                params[param_name] = items
            except Exception as e:
                msg = f"Failed to parse list parameter {param_name}: {e!s}"
                raise ValueError(msg) from e
        # Handle string parameters
        else:
            params[param_name] = param_value

    return params


def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
    """Parse a Midjourney prompt into a validated MidjourneyPrompt object.

    Args:
        prompt: The raw prompt string to parse.

    Returns:
        A validated MidjourneyPrompt object.

    Raises:
        ValueError: If the prompt is invalid or missing required components.
    """
    # Extract image URLs
    images, remaining_text = extract_image_urls(prompt)

    # Split into text and parameters
    if " --" in remaining_text:
        text_part, param_part = remaining_text.split(" --", 1)
        text_part = text_part.strip()
        param_str = "--" + param_part.strip()
        try:
            parameters = parse_parameters(param_str)
        except Exception as e:
            msg = f"Failed to parse parameters: {e!s}"
            raise ValueError(msg) from e
    else:
        text_part = remaining_text.strip()
        parameters = {}

    # Create and validate the prompt object
    try:
        return MidjourneyPrompt(
            text=text_part,
            image_prompts=images,
            **parameters,
        )
    except Exception as e:
        msg = f"Failed to create prompt object: {e!s}"
        raise ValueError(msg) from e


def parse_midjargon_prompt_to_dict(prompt: str) -> dict[str, Any]:
    """Parse a Midjourney prompt into a dictionary.

    Args:
        prompt: The raw prompt string to parse.

    Returns:
        Dictionary representation of the prompt.
    """
    parsed = parse_midjargon_prompt(prompt)
    return parsed.model_dump()
```

## File: src/midjargon/core/permutations.py (Size: 3.63 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/permutations.py


def find_unescaped(s: str, char: str, start: int = 0) -> int:
    """Find the next unescaped occurrence of a character.

    Args:
        s: String to search in.
        char: Character to find.
        start: Starting position for search.

    Returns:
        Index of the first unescaped occurrence, or -1 if not found.
    """
    i = start
    while i < len(s):
        if s[i] == "\\":
            i += 2  # Skip escaped character
            continue
        if s[i] == char:
            return i
        i += 1
    return -1


def split_unescaped(s: str, delimiter: str = ",") -> list[str]:
    """Split string on unescaped delimiters and handle escapes.

    Args:
        s: String to split.
        delimiter: Character to split on.

    Returns:
        List of substrings.
    """
    parts = []
    current = []
    i = 0

    while i < len(s):
        if s[i] == "\\":
            if i + 1 < len(s):
                current.append(s[i + 1])  # Keep escaped character
                i += 2
            else:
                current.append(s[i])  # Keep trailing backslash
                i += 1
        elif s[i] == delimiter:
            parts.append("".join(current).strip())
            current = []
            i += 1
        else:
            current.append(s[i])
            i += 1

    if current:
        parts.append("".join(current).strip())

    return parts


def find_matching_brace(s: str, start: int) -> tuple[int, str]:
    """Find matching closing brace and extract error message if any.

    Args:
        s: String to search in.
        start: Position of opening brace.

    Returns:
        Tuple of (position of closing brace, error message).
        Position will be -1 if no match found.
    """
    count = 1
    i = start + 1

    while i < len(s):
        if s[i] == "\\":
            i += 2
            continue
        if s[i] == "{":
            count += 1
        elif s[i] == "}":
            count -= 1
            if count == 0:
                return i, ""
        i += 1

    if count > 0:
        return -1, f"Unclosed brace at position {start}"
    return -1, "Invalid brace structure"


def expand_permutations(s: str) -> list[str]:
    """Recursively expand permutations in the prompt string using {a, b, ...} syntax.

    Handles:
    - Nested permutation groups
    - Escaped characters (\\, \\{, \\}, \\,)
    - Proper error reporting

    Args:
        s: String containing permutation groups.

    Returns:
        List of all possible permutations.

    Raises:
        ValueError: If the permutation syntax is invalid.
    """
    # Find first unescaped opening brace
    start = find_unescaped(s, "{")
    if start == -1:
        return [s]

    # Find matching closing brace
    end, error = find_matching_brace(s, start)
    if end == -1:
        raise ValueError(error)

    # Extract and split options
    options_str = s[start + 1 : end]
    try:
        options = split_unescaped(options_str)
    except Exception as e:
        msg = f"Failed to parse options at position {start}: {e!s}"
        raise ValueError(msg)

    if not options:
        msg = f"Empty permutation group at position {start}"
        raise ValueError(msg)

    # Recursively expand each option
    results = []
    prefix = s[:start]
    suffix = s[end + 1 :]

    for option in options:
        # Replace the entire '{...}' with the option
        new_s = prefix + option + suffix
        try:
            results.extend(expand_permutations(new_s))
        except Exception as e:
            msg = f"Failed to expand option '{option}': {e!s}"
            raise ValueError(msg)

    return results
```

## File: src/midjargon/engines/__init__.py (Size: 0.05 KB)

```
# this_file: src/midjargon/engines/__init__.py
```

## File: src/midjargon/engines/fal/__init__.py (Size: 0.20 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/fal/__init__.py

from midjargon.engines.fal.fal import FalParser, FalPrompt, parse_fal_dict

__all__ = ["FalParser", "FalPrompt", "parse_fal_dict"]
```

## File: src/midjargon/engines/fal/fal.py (Size: 3.27 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/fal/fal.py

from typing import Any

from pydantic import BaseModel, HttpUrl, computed_field


class FalPrompt(BaseModel):
    """Fal.ai prompt model with all parameters."""

    text: str
    image_prompts: list[HttpUrl] = []
    negative_prompt: str | None = None
    num_inference_steps: int | None = 50
    guidance_scale: float | None = 7.5
    width: int | None = 1024
    height: int | None = 1024
    seed: int | None = None
    scheduler: str | None = None
    extra_params: dict[str, Any] = {}

    @computed_field
    def images(self) -> list[HttpUrl]:
        """Get image URLs."""
        return self.image_prompts

    @computed_field
    def parameters(self) -> dict[str, Any]:
        """Get all parameters as a dictionary."""
        params = self.model_dump(exclude={"text", "image_prompts", "extra_params"})
        return {k: v for k, v in params.items() if v is not None}

    def to_string(self) -> str:
        """Convert prompt to string format."""
        parts = [self.text]

        # Add image prompts
        for url in self.image_prompts:
            parts.append(str(url))

        # Add parameters
        params = []
        for field, value in self.model_dump(exclude_unset=True).items():
            if field in {"text", "image_prompts", "extra_params"} or value is None:
                continue
            if isinstance(value, bool) and value:
                params.append(f"--{field}")
            elif isinstance(value, list) and value:
                for v in value:
                    params.append(f"--{field} {v}")
            else:
                params.append(f"--{field} {value}")

        # Add extra parameters
        for key, value in self.extra_params.items():
            if value is None:
                params.append(f"--{key}")
            else:
                params.append(f"--{key} {value}")

        if params:
            parts.append(" ".join(params))

        return " ".join(parts)


class FalParser:
    """Parser for converting between Fal.ai prompt formats."""

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.

        Args:
            prompt_dict: Dictionary containing prompt data.

        Returns:
            FalPrompt instance.

        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)

        # Extract known fields
        known_fields = set(FalPrompt.model_fields)

        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value

        # Create prompt with all parameters
        return FalPrompt(text=text, **params, extra_params=extra_params)


def parse_fal_dict(prompt_dict: dict[str, Any]) -> FalPrompt:
    """Convert a dictionary to a FalPrompt.

    Args:
        prompt_dict: Dictionary containing prompt data.

    Returns:
        FalPrompt instance.
    """
    parser = FalParser()
    return parser.parse_dict(prompt_dict)
```

## File: src/midjargon/engines/midjourney/__init__.py (Size: 0.28 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/__init__.py

from midjargon.engines.midjourney.midjourney import (
    MidjourneyParser,
    MidjourneyPrompt,
    parse_midjourney_dict,
)

__all__ = ["MidjourneyParser", "MidjourneyPrompt", "parse_midjourney_dict"]
```

## File: src/midjargon/engines/midjourney/midjourney.py (Size: 4.97 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/midjourney.py

from typing import Any

from pydantic import HttpUrl

from midjargon.core.models import (
    CharacterReference,
    ImageReference,
    MidjourneyParameters,
    MidjourneyPrompt,
    StyleReference,
)


class MidjourneyParser:
    """Parser for converting between Midjourney prompt formats."""

    def _parse_url(self, url: str) -> HttpUrl:
        """Parse a URL string into an HttpUrl object.

        Args:
            url: URL string to parse.

        Returns:
            HttpUrl instance.
        """
        return HttpUrl(url)

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.

        Args:
            prompt_dict: Dictionary containing prompt data.

        Returns:
            MidjourneyPrompt instance.

        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)

        # Handle image prompts
        image_prompts = []
        raw_image_prompts = prompt_dict.pop("image_prompts", [])
        for img in raw_image_prompts:
            if isinstance(img, str):
                image_prompts.append(ImageReference(url=self._parse_url(img)))
            elif isinstance(img, dict):
                if "url" in img and isinstance(img["url"], str):
                    img["url"] = self._parse_url(img["url"])
                image_prompts.append(ImageReference(**img))
            elif isinstance(img, ImageReference):
                image_prompts.append(img)

        # Handle parameters
        params = MidjourneyParameters()

        # Handle aspect ratio
        if "ar" in prompt_dict:
            params.aspect_ratio = prompt_dict.pop("ar")
        elif "aspect_ratio" in prompt_dict:
            params.aspect_ratio = prompt_dict.pop("aspect_ratio")
        elif "aspect" in prompt_dict:
            params.aspect_ratio = prompt_dict.pop("aspect")
        elif all(k in prompt_dict for k in ["aspect_width", "aspect_height"]):
            params.aspect_width = int(prompt_dict.pop("aspect_width"))
            params.aspect_height = int(prompt_dict.pop("aspect_height"))

        # Handle version
        if "v" in prompt_dict:
            params.version = prompt_dict.pop("v")
        elif "version" in prompt_dict:
            params.version = prompt_dict.pop("version")

        # Handle style
        if "style" in prompt_dict:
            params.style = prompt_dict.pop("style")

        # Handle numeric parameters
        if "s" in prompt_dict:
            params.stylize = float(prompt_dict.pop("s"))
        elif "stylize" in prompt_dict:
            params.stylize = float(prompt_dict.pop("stylize"))

        if "c" in prompt_dict:
            params.chaos = float(prompt_dict.pop("c"))
        elif "chaos" in prompt_dict:
            params.chaos = float(prompt_dict.pop("chaos"))

        if "weird" in prompt_dict:
            params.weird = float(prompt_dict.pop("weird"))

        if "seed" in prompt_dict:
            params.seed = prompt_dict.pop("seed")

        # Handle boolean flags
        for flag in ["tile", "turbo", "relax", "personalization"]:
            if flag in prompt_dict:
                setattr(params, flag, bool(prompt_dict.pop(flag)))

        # Handle references
        if "cref" in prompt_dict:
            ref = prompt_dict.pop("cref")
            weight = float(prompt_dict.pop("cw", 1.0))
            if isinstance(ref, str):
                if ref.startswith("http"):
                    params.character_reference.append(
                        CharacterReference(url=self._parse_url(ref), weight=weight)
                    )
                else:
                    params.character_reference.append(
                        CharacterReference(code=ref, weight=weight)
                    )

        if "sref" in prompt_dict:
            ref = prompt_dict.pop("sref")
            weight = float(prompt_dict.pop("sw", 1.0))
            if isinstance(ref, str):
                if ref.startswith("http"):
                    params.style_reference.append(
                        StyleReference(url=self._parse_url(ref), weight=weight)
                    )
                else:
                    params.style_reference.append(
                        StyleReference(code=ref, weight=weight)
                    )

        # Handle remaining parameters
        params.extra_params = prompt_dict

        return MidjourneyPrompt(
            text=text,
            image_prompts=image_prompts,
            parameters=params,
        )


def parse_midjourney_dict(prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
    """Convert a dictionary to a MidjourneyPrompt.

    Args:
        prompt_dict: Dictionary containing prompt data.

    Returns:
        MidjourneyPrompt instance.
    """
    parser = MidjourneyParser()
    return parser.parse_dict(prompt_dict)
```

## File: src/midjargon/engines/midjourney/parser.py (Size: 2.02 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/parser.py

from typing import Any

from midjargon.core.models import MidjourneyParameters, MidjourneyPrompt
from midjargon.core.parameters import parse_parameters


class MidjourneyParser:
    """Parser for Midjourney prompts."""

    def __init__(self, prompt_dict: dict[str, Any] | None = None):
        """Initialize the parser.

        Args:
            prompt_dict: Optional dictionary containing prompt data.
        """
        self.prompt_dict = prompt_dict or {}
        self.prompt = MidjourneyPrompt(
            text=self.prompt_dict.get("text", ""),
            images=self.prompt_dict.get("images", []),
            parameters=MidjourneyParameters(**self.prompt_dict.get("parameters", {})),
        )

    def parse(self) -> MidjourneyPrompt:
        """Parse the prompt data into a MidjourneyPrompt object.

        Returns:
            A validated MidjourneyPrompt object.
        """
        return self.prompt

    @staticmethod
    def from_string(prompt_str: str) -> "MidjourneyParser":
        """Create a parser from a prompt string.

        Args:
            prompt_str: The raw prompt string to parse.

        Returns:
            A MidjourneyParser instance.

        Raises:
            ValueError: If prompt parsing fails.
        """
        # Split into text and parameters
        if " --" in prompt_str:
            text_part, param_part = prompt_str.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg) from e
        else:
            text_part = prompt_str.strip()
            parameters = {}

        # Create prompt dictionary
        prompt_dict = {
            "text": text_part,
            "images": [],
            "parameters": parameters,
        }

        return MidjourneyParser(prompt_dict)
```

## File: test-cases/prompts-fal.txt (Size: 32.46 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "images": [],
    "version": 6,
    "stylize": 250,
    "seed": 12345,
    "prompt": "\"Do not enter\" sign in Elvish script, overgrown with vines"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 250,
    "seed": 67890,
    "prompt": "\"Do not enter\" sign in Elvish script, overgrown with vines"
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "images": [],
  "version": 6.1,
  "stylize": 750,
  "weird": 250,
  "prompt": "\"Lost in translation\" neon sign in a Tokyo alleyway"
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "images": [],
  "version": 6.1,
  "stylize": 1000,
  "zoom": 1.5,
  "aspect_ratio": "1:2",
  "prompt": "\"Made in Midjourney\" stamp on a vintage postage stamp"
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
[
  {
    "images": [],
    "style": "raw",
    "stylize": 0,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "raw",
    "stylize": 0,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "raw",
    "stylize": 1000,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "raw",
    "stylize": 1000,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 0,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 0,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 1000,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 1000,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  }
]======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "images": [],
    "video": null,
    "version": 5.2,
    "chaos": 30,
    "aspect_ratio": "1:1",
    "prompt": "A botanical sketch of fern fronds"
  },
  {
    "images": [],
    "video": null,
    "version": 5.2,
    "chaos": 30,
    "aspect_ratio": "16:9",
    "prompt": "A botanical sketch of fern fronds"
  },
  {
    "images": [],
    "video": null,
    "version": 6,
    "chaos": 30,
    "aspect_ratio": "1:1",
    "prompt": "A botanical sketch of fern fronds"
  },
  {
    "images": [],
    "video": null,
    "version": 6,
    "chaos": 30,
    "aspect_ratio": "16:9",
    "prompt": "A botanical sketch of fern fronds"
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "images": [],
  "version": 6,
  "stylize": 100,
  "aspect_ratio": "2:3",
  "prompt": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages"
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "images": [],
    "stop": 80,
    "weird": 2000,
    "aspect_ratio": "3:2",
    "prompt": "A cat in a Tundra environment"
  },
  {
    "images": [],
    "stop": 80,
    "weird": 2000,
    "aspect_ratio": "3:2",
    "prompt": "A cat in a Jungle environment"
  },
  {
    "images": [],
    "stop": 80,
    "weird": 2000,
    "aspect_ratio": "3:2",
    "prompt": "A cat in a City environment"
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 50,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 50,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 750,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 750,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 50,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 50,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 750,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 750,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "images": [],
  "version": 6,
  "stylize": 500,
  "aspect_ratio": "1:1",
  "prompt": "A cyberpunk cat with a neon sign that says \"Midjourney\""
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "images": [],
  "version": 6.1,
  "stylize": 250,
  "aspect_ratio": "16:9",
  "prompt": "A pastel watercolor landscape with \"/imagine\" written in the clouds"
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "images": [],
    "tile": null,
    "chaos": 25,
    "prompt": "A pattern of pink and blue striped river stones"
  },
  {
    "images": [],
    "tile": null,
    "chaos": 75,
    "prompt": "A pattern of pink and blue striped river stones"
  },
  {
    "images": [],
    "tile": null,
    "chaos": 25,
    "prompt": "A pattern of colorful watercolor fall leaves"
  },
  {
    "images": [],
    "tile": null,
    "chaos": 75,
    "prompt": "A pattern of colorful watercolor fall leaves"
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "images": [],
  "style": "random-64",
  "no": "color, shading",
  "aspect_ratio": "2:3",
  "prompt": "A pencil sketch of a dragon made of constellations"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "prompt": "A portrait of a melancholic robot butler"
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "stop": 30,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "stop": 70,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "stop": 30,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "stop": 70,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
[
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  }
]======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "images": [],
    "stop": 50,
    "quality": 0.5,
    "prompt": "A continuous line charcoal drawing of a value study of a cyborg geisha"
  },
  {
    "images": [],
    "stop": 50,
    "quality": 0.5,
    "prompt": "A loose gestural charcoal drawing of a value study of a cyborg geisha"
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
[
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  }
]======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
[
  {
    "images": [],
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome",
    "prompt": "A Millennial Pink colored cat"
  },
  {
    "images": [],
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome",
    "prompt": "A Acid Green colored cat"
  },
  {
    "images": [],
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome",
    "prompt": "A Ebony colored cat"
  }
]======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a determined sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a determined sloth riding a unicorn through a salt flat"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a determined sloth riding a unicorn through a salt flat"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat"
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
[
  {
    "images": [],
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers",
    "prompt": "A pixel art style cat"
  },
  {
    "images": [],
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers",
    "prompt": "A acrylic pour style cat"
  }
]======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "images": [],
  "stylize": 50,
  "no": "board, pieces",
  "style": "raw",
  "aspect_ratio": "4:3",
  "prompt": "An impressionistic watercolor of a cat playing chess with a dog"
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "images": [],
  "negative": "weight fruit::-.5",
  "version": 4,
  "chaos": 60,
  "prompt": "cheese:: cake:: painting multi-prompt"
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "images": [],
    "weird": 750,
    "stylize": 200,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 200,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 600,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 600,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 900,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 900,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 200,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 200,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 600,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 600,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 900,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 900,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 200,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 200,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 600,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 600,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 900,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 900,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "images": [],
    "weird": 250,
    "stylize": 100,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 100,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 100,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 500,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 500,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 500,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 1000,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 1000,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 1000,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 100,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 100,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 100,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 500,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 500,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 500,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 1000,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 1000,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 1000,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 100,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 100,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 100,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 500,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 500,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 500,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 1000,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 1000,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 1000,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  }
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "images": [],
  "remix": null,
  "prompt": "image of a robot holding flowers",
  "zoom": "2x"
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1400s cat"
  },
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1400s cat"
  },
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1990s cat"
  },
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1990s cat"
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "images": [],
    "weird": 500,
    "chaos": 20,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 20,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 60,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 60,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 20,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 20,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 60,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 60,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 20,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 20,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 60,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 60,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 80,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 80,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "images": [],
    "stylize": 250,
    "weird": 500,
    "prompt": "space:: ship multi-prompt"
  },
  {
    "images": [],
    "stylize": 750,
    "weird": 500,
    "prompt": "space:: ship multi-prompt"
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "images": [],
  "vary": "region",
  "selection": "sky area",
  "prompt": "stream running through a redwood forest",
  "pan": "up"
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "images": [],
    "version": 5.2,
    "stylize": 100,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 5.2,
    "stylize": 100,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 5.2,
    "stylize": 500,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 5.2,
    "stylize": 500,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 100,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 100,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 500,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 500,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 100,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 100,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 500,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 500,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  }
]
```

## File: test-cases/prompts-in.txt (Size: 3.16 KB)

```
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
space:: ship multi-prompt  --stylize {250, 750} --weird 500
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
{Happy, Angry, Shy} cat --style raw --chaos 60 --quality 1 --repeat 3
```

## File: test-cases/prompts-json.txt (Size: 31.71 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "images": [],
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "version": "6",
    "stylize": 250,
    "seed": 12345
  },
  {
    "images": [],
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "version": "6",
    "stylize": 250,
    "seed": 67890
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "images": [],
  "text": "\"Lost in translation\" neon sign in a Tokyo alleyway",
  "version": "6.1",
  "stylize": 750,
  "weird": 250
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "images": [],
  "text": "\"Made in Midjourney\" stamp on a vintage postage stamp",
  "version": "6.1",
  "stylize": 1000,
  "zoom": "1.5",
  "aspect": "1:2"
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
[
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 0,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 0,
    "weird": 3000
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 1000,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 1000,
    "weird": 3000
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 0,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 0,
    "weird": 3000
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 1000,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 1000,
    "weird": 3000
  }
]======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "5.2",
    "aspect": "1:1",
    "chaos": 30
  },
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "5.2",
    "aspect": "16:9",
    "chaos": 30
  },
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "6",
    "aspect": "1:1",
    "chaos": 30
  },
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "6",
    "aspect": "16:9",
    "chaos": 30
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "images": [],
  "text": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages",
  "version": "6",
  "stylize": 100,
  "aspect": "2:3"
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "images": [],
    "text": "A cat in a Tundra environment",
    "aspect": "3:2",
    "stop": 80,
    "weird": 2000
  },
  {
    "images": [],
    "text": "A cat in a Jungle environment",
    "aspect": "3:2",
    "stop": 80,
    "weird": 2000
  },
  {
    "images": [],
    "text": "A cat in a City environment",
    "aspect": "3:2",
    "stop": 80,
    "weird": 2000
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 50,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 50,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 750,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 750,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 50,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 50,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 750,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 750,
    "quality": 1.0
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "images": [],
  "text": "A cyberpunk cat with a neon sign that says \"Midjourney\"",
  "version": "6",
  "stylize": 500,
  "aspect": "1:1"
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "images": [],
  "text": "A pastel watercolor landscape with \"/imagine\" written in the clouds",
  "version": "6.1",
  "stylize": 250,
  "aspect": "16:9"
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "images": [],
    "text": "A pattern of pink and blue striped river stones",
    "tile": null,
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pattern of pink and blue striped river stones",
    "tile": null,
    "chaos": 75
  },
  {
    "images": [],
    "text": "A pattern of colorful watercolor fall leaves",
    "tile": null,
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pattern of colorful watercolor fall leaves",
    "tile": null,
    "chaos": 75
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "images": [],
  "text": "A pencil sketch of a dragon made of constellations",
  "aspect": "2:3",
  "style": "random-64",
  "no": "color, shading"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 500,
    "chaos": 80,
    "stop": 30
  },
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 500,
    "chaos": 80,
    "stop": 70
  },
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 1500,
    "chaos": 80,
    "stop": 30
  },
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 1500,
    "chaos": 80,
    "stop": 70
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
[
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295
  }
]======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "images": [],
    "text": "A continuous line charcoal drawing of a value study of a cyborg geisha",
    "stop": 50,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "A loose gestural charcoal drawing of a value study of a cyborg geisha",
    "stop": 50,
    "quality": 0.5
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
[
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 100
  }
]======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
[
  {
    "images": [],
    "text": "A Millennial Pink colored cat",
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome"
  },
  {
    "images": [],
    "text": "A Acid Green colored cat",
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome"
  },
  {
    "images": [],
    "text": "A Ebony colored cat",
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome"
  }
]======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "images": [],
    "text": "A pastel painting of a determined sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pastel painting of a determined sloth riding a unicorn through a salt flat",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a determined sloth riding a unicorn through a salt flat",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat",
    "chaos": 25
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
[
  {
    "images": [],
    "text": "A pixel art style cat",
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers"
  },
  {
    "images": [],
    "text": "A acrylic pour style cat",
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers"
  }
]======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "images": [],
  "text": "An impressionistic watercolor of a cat playing chess with a dog",
  "aspect": "4:3",
  "stylize": 50,
  "no": "board, pieces",
  "style": "raw"
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "images": [],
  "text": "cheese:: cake:: painting multi-prompt",
  "negative": "weight fruit::-.5",
  "version": "4",
  "chaos": 60
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 200,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 200,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 600,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 600,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 900,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 900,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 200,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 200,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 600,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 600,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 900,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 900,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 200,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 200,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 600,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 600,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 900,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 900,
    "aspect": "3:2"
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 100,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 100,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 100,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 500,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 500,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 500,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 1000,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 1000,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 1000,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 100,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 100,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 100,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 500,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 500,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 500,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 1000,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 1000,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 1000,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 100,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 100,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 100,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 500,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 500,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 500,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 1000,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 1000,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 1000,
    "chaos": 90
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect": "2:3"
  }
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "images": [],
  "text": "image of a robot holding flowers",
  "remix": null,
  "prompt": "A cyborg holding cybernetic orchids",
  "zoom": "2x"
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "images": [],
    "text": "Imagine a 1400s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect": "5:4"
  },
  {
    "images": [],
    "text": "Imagine a 1400s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect": "5:4"
  },
  {
    "images": [],
    "text": "Imagine a 1990s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect": "5:4"
  },
  {
    "images": [],
    "text": "Imagine a 1990s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect": "5:4"
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 20,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 20,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 60,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 60,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 80,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 80,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 20,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 20,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 60,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 60,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 80,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 80,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 20,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 20,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 60,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 60,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 80,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 80,
    "quality": 1.0
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "images": [],
    "text": "space:: ship multi-prompt",
    "stylize": 250,
    "weird": 500
  },
  {
    "images": [],
    "text": "space:: ship multi-prompt",
    "stylize": 750,
    "weird": 500
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "images": [],
  "text": "stream running through a redwood forest",
  "vary": "region",
  "selection": "sky area",
  "prompt": "aurora borealis",
  "pan": "up"
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 100,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 100,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 500,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 500,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 100,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 100,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 500,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 500,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 100,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 100,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 500,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 500,
    "quality": 2.0
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 5
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 5
  }
]
```

## File: test-cases/prompts-mj.txt (Size: 105.65 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 12345,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 67890,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "text": "\"Lost in translation\" neon sign in a Tokyo alleyway",
  "image_prompts": [],
  "stylize": 750,
  "chaos": 0,
  "weird": 250,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "text": "\"Made in Midjourney\" stamp on a vintage postage stamp",
  "image_prompts": [],
  "stylize": 1000,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 2,
  "aspect_ratio": "1:2",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "zoom": "1.5"
  }
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'expressive', 'raw', 'scenic', 'original'} [type=value_error, input_value='default', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 16,
    "aspect_height": 9,
    "aspect_ratio": "16:9",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 16,
    "aspect_height": 9,
    "aspect_ratio": "16:9",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "text": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 2,
  "aspect_height": 3,
  "aspect_ratio": "2:3",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "text": "A cat in a Tundra environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a Jungle environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a City environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "text": "A cyberpunk cat with a neon sign that says \"Midjourney\"",
  "image_prompts": [],
  "stylize": 500,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "text": "A pastel watercolor landscape with \"/imagine\" written in the clouds",
  "image_prompts": [],
  "stylize": 250,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 16,
  "aspect_height": 9,
  "aspect_ratio": "16:9",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'cute', 'original', 'raw', 'expressive'} [type=value_error, input_value='random-64', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
{
  "error": "Invalid value for seed: random - Invalid numeric value: could not convert string to float: 'random'"
}======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "text": "A continuous line charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A loose gestural charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'raw', 'cute', 'original', 'expressive'} [type=value_error, input_value='random', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'expressive', 'original', 'raw', 'scenic'} [type=value_error, input_value='random-16', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'scenic', 'raw', 'expressive', 'original'} [type=value_error, input_value='random-128', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "text": "An impressionistic watercolor of a cat playing chess with a dog",
  "image_prompts": [],
  "stylize": 50,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 4,
  "aspect_height": 3,
  "aspect_ratio": "4:3",
  "style": "raw",
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": "board, pieces",
  "extra_params": {}
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "text": "cheese:: cake:: painting multi-prompt",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 60,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v4",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "negative": "weight fruit::-.5"
  }
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "text": "image of a robot holding flowers",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "remix": null,
    "prompt": "A cyborg holding cybernetic orchids",
    "zoom": "2x"
  }
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "text": "stream running through a redwood forest",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "vary": "region",
    "selection": "sky area",
    "prompt": "aurora borealis",
    "pan": "up"
  }
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]
```

## File: test-cases/prompts-out.txt (Size: 13.41 KB)

```
> mj '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> fal '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> json '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> perm '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> mj '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> fal '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> json '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> perm '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> mj '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> fal '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> json '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> perm '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> mj 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> fal 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> json 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> perm 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> mj 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> fal 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> json 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> perm 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> mj 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> fal 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> json 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> perm 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> mj 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> fal 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> json 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> perm 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> mj 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> fal 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> json 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> perm 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> mj 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> fal 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> json 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> perm 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> mj 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> fal 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> json 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> perm 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> mj 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> fal 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> json 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> perm 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> mj 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> fal 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> json 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> perm 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> mj 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> fal 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> json 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> perm 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> mj 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> fal 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> json 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> perm 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> mj 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> fal 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> json 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> perm 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> mj 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> fal 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> json 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> perm 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> mj 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> fal 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> json 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> perm 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> mj 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> fal 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> json 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> perm 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> mj 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> fal 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> json 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> perm 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> mj 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> fal 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> json 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> perm 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> mj 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> fal 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> json 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> perm 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> mj 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> fal 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> json 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> perm 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> mj 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> fal 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> json 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> perm 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> mj 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> fal 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> json 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> perm 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> mj 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> fal 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> json 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> perm 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> mj 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> fal 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> json 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> perm 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> mj 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> fal 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> json 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> perm 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> mj 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> fal 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> json 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> perm 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> mj 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> fal 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> json 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> perm 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> mj 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> fal 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> json 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> perm 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> mj 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> fal 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> json 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> perm 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> mj '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
> fal '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
> json '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
> perm '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
```

## File: test-cases/prompts-perm.txt (Size: 19.07 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  "\"Do not enter\" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed 12345",
  "\"Do not enter\" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed 67890"
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
[
  "\"Lost in translation\" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250"
]======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
[
  "\"Made in Midjourney\" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2"
]======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
[
  "A black and white oak tree icon --style raw --stylize 0 --weird 0",
  "A black and white oak tree icon --style raw --stylize 0 --weird 3000",
  "A black and white oak tree icon --style raw --stylize 1000 --weird 0",
  "A black and white oak tree icon --style raw --stylize 1000 --weird 3000",
  "A black and white oak tree icon --style default --stylize 0 --weird 0",
  "A black and white oak tree icon --style default --stylize 0 --weird 3000",
  "A black and white oak tree icon --style default --stylize 1000 --weird 0",
  "A black and white oak tree icon --style default --stylize 1000 --weird 3000"
]======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  "A botanical sketch of fern fronds --video --version 5.2 --ar 1:1 --chaos 30",
  "A botanical sketch of fern fronds --video --version 5.2 --ar 16:9 --chaos 30",
  "A botanical sketch of fern fronds --video --version 6 --ar 1:1 --chaos 30",
  "A botanical sketch of fern fronds --video --version 6 --ar 16:9 --chaos 30"
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
[
  "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages --v 6 --stylize 100 --ar 2:3"
]======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  "A cat in a Tundra environment --ar 3:2 --stop 80 --weird 2000",
  "A cat in a Jungle environment --ar 3:2 --stop 80 --weird 2000",
  "A cat in a City environment --ar 3:2 --stop 80 --weird 2000"
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 50 --quality .25",
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 50 --quality 1",
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 750 --quality .25",
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 750 --quality 1",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 50 --quality .25",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 50 --quality 1",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 750 --quality .25",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 750 --quality 1"
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
[
  "A cyberpunk cat with a neon sign that says \"Midjourney\" --v 6 --stylize 500 --ar 1:1"
]======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
[
  "A pastel watercolor landscape with \"/imagine\" written in the clouds --v 6.1 --stylize 250 --ar 16:9"
]======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  "A pattern of pink and blue striped river stones --tile --chaos 25",
  "A pattern of pink and blue striped river stones --tile --chaos 75",
  "A pattern of colorful watercolor fall leaves --tile --chaos 25",
  "A pattern of colorful watercolor fall leaves --tile --chaos 75"
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
[
  "A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading"
]======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 0 --sref <image URL of sad painting> --sw 100",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 0 --sref <image URL of sad painting> --sw 800",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 50 --sref <image URL of sad painting> --sw 100",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 50 --sref <image URL of sad painting> --sw 800",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 100 --sref <image URL of sad painting> --sw 100",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 100 --sref <image URL of sad painting> --sw 800"
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 500 --chaos 80 --stop 30",
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 500 --chaos 80 --stop 70",
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 1500 --chaos 80 --stop 30",
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 1500 --chaos 80 --stop 70"
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
[
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality 1 --seed 4294967295",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality 1 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality 1 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality 1 --seed 4294967295"
]======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  "A continuous line charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5",
  "A loose gestural charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5"
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
[
  "A dreary cyberpunk cityscape --ar 16:9 --style raw --chaos 0",
  "A dreary cyberpunk cityscape --ar 16:9 --style raw --chaos 100",
  "A dreary cyberpunk cityscape --ar 16:9 --style random --chaos 0",
  "A dreary cyberpunk cityscape --ar 16:9 --style random --chaos 100",
  "A dreary cyberpunk cityscape --ar 1:1 --style raw --chaos 0",
  "A dreary cyberpunk cityscape --ar 1:1 --style raw --chaos 100",
  "A dreary cyberpunk cityscape --ar 1:1 --style random --chaos 0",
  "A dreary cyberpunk cityscape --ar 1:1 --style random --chaos 100",
  "A vibrant cyberpunk cityscape --ar 16:9 --style raw --chaos 0",
  "A vibrant cyberpunk cityscape --ar 16:9 --style raw --chaos 100",
  "A vibrant cyberpunk cityscape --ar 16:9 --style random --chaos 0",
  "A vibrant cyberpunk cityscape --ar 16:9 --style random --chaos 100",
  "A vibrant cyberpunk cityscape --ar 1:1 --style raw --chaos 0",
  "A vibrant cyberpunk cityscape --ar 1:1 --style raw --chaos 100",
  "A vibrant cyberpunk cityscape --ar 1:1 --style random --chaos 0",
  "A vibrant cyberpunk cityscape --ar 1:1 --style random --chaos 100"
]======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
[
  "A Millennial Pink colored cat --s 250 --style random-16 --no monochrome",
  "A Acid Green colored cat --s 250 --style random-16 --no monochrome",
  "A Ebony colored cat --s 250 --style random-16 --no monochrome"
]======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  "A pastel painting of a determined sloth riding a unicorn through a crystal forest --chaos 25",
  "A pastel painting of a determined sloth riding a unicorn through a salt flat --chaos 25",
  "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest --chaos 25",
  "A pastel painting of a sleepy sloth riding a unicorn through a salt flat --chaos 25",
  "A blacklight painting of a determined sloth riding a unicorn through a crystal forest --chaos 25",
  "A blacklight painting of a determined sloth riding a unicorn through a salt flat --chaos 25",
  "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest --chaos 25",
  "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat --chaos 25"
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
[
  "A pixel art style cat --style random-128 --weird 1000 --no fur, whiskers",
  "A acrylic pour style cat --style random-128 --weird 1000 --no fur, whiskers"
]======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
[
  "An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw"
]======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
[
  "cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60"
]======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  "Clockwork chicken --weird 750 --stylize 200 --ar 2:3",
  "Clockwork chicken --weird 750 --stylize 200 --ar 3:2",
  "Clockwork chicken --weird 750 --stylize 600 --ar 2:3",
  "Clockwork chicken --weird 750 --stylize 600 --ar 3:2",
  "Clockwork chicken --weird 750 --stylize 900 --ar 2:3",
  "Clockwork chicken --weird 750 --stylize 900 --ar 3:2",
  "Clockwork chicken --weird 1750 --stylize 200 --ar 2:3",
  "Clockwork chicken --weird 1750 --stylize 200 --ar 3:2",
  "Clockwork chicken --weird 1750 --stylize 600 --ar 2:3",
  "Clockwork chicken --weird 1750 --stylize 600 --ar 3:2",
  "Clockwork chicken --weird 1750 --stylize 900 --ar 2:3",
  "Clockwork chicken --weird 1750 --stylize 900 --ar 3:2",
  "Clockwork chicken --weird 2750 --stylize 200 --ar 2:3",
  "Clockwork chicken --weird 2750 --stylize 200 --ar 3:2",
  "Clockwork chicken --weird 2750 --stylize 600 --ar 2:3",
  "Clockwork chicken --weird 2750 --stylize 600 --ar 3:2",
  "Clockwork chicken --weird 2750 --stylize 900 --ar 2:3",
  "Clockwork chicken --weird 2750 --stylize 900 --ar 3:2"
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  "Cyanotype cat --weird 250 --stylize 100 --chaos 10",
  "Cyanotype cat --weird 250 --stylize 100 --chaos 50",
  "Cyanotype cat --weird 250 --stylize 100 --chaos 90",
  "Cyanotype cat --weird 250 --stylize 500 --chaos 10",
  "Cyanotype cat --weird 250 --stylize 500 --chaos 50",
  "Cyanotype cat --weird 250 --stylize 500 --chaos 90",
  "Cyanotype cat --weird 250 --stylize 1000 --chaos 10",
  "Cyanotype cat --weird 250 --stylize 1000 --chaos 50",
  "Cyanotype cat --weird 250 --stylize 1000 --chaos 90",
  "Cyanotype cat --weird 1000 --stylize 100 --chaos 10",
  "Cyanotype cat --weird 1000 --stylize 100 --chaos 50",
  "Cyanotype cat --weird 1000 --stylize 100 --chaos 90",
  "Cyanotype cat --weird 1000 --stylize 500 --chaos 10",
  "Cyanotype cat --weird 1000 --stylize 500 --chaos 50",
  "Cyanotype cat --weird 1000 --stylize 500 --chaos 90",
  "Cyanotype cat --weird 1000 --stylize 1000 --chaos 10",
  "Cyanotype cat --weird 1000 --stylize 1000 --chaos 50",
  "Cyanotype cat --weird 1000 --stylize 1000 --chaos 90",
  "Cyanotype cat --weird 2000 --stylize 100 --chaos 10",
  "Cyanotype cat --weird 2000 --stylize 100 --chaos 50",
  "Cyanotype cat --weird 2000 --stylize 100 --chaos 90",
  "Cyanotype cat --weird 2000 --stylize 500 --chaos 10",
  "Cyanotype cat --weird 2000 --stylize 500 --chaos 50",
  "Cyanotype cat --weird 2000 --stylize 500 --chaos 90",
  "Cyanotype cat --weird 2000 --stylize 1000 --chaos 10",
  "Cyanotype cat --weird 2000 --stylize 1000 --chaos 50",
  "Cyanotype cat --weird 2000 --stylize 1000 --chaos 90"
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  "Ice cream icon --niji 5 --style cute --weird 250 --ar 1:1",
  "Ice cream icon --niji 5 --style cute --weird 250 --ar 2:3",
  "Ice cream icon --niji 5 --style cute --weird 1000 --ar 1:1",
  "Ice cream icon --niji 5 --style cute --weird 1000 --ar 2:3",
  "Ice cream icon --niji 5 --style expressive --weird 250 --ar 1:1",
  "Ice cream icon --niji 5 --style expressive --weird 250 --ar 2:3",
  "Ice cream icon --niji 5 --style expressive --weird 1000 --ar 1:1",
  "Ice cream icon --niji 5 --style expressive --weird 1000 --ar 2:3",
  "Ice cream icon --niji 6 --style cute --weird 250 --ar 1:1",
  "Ice cream icon --niji 6 --style cute --weird 250 --ar 2:3",
  "Ice cream icon --niji 6 --style cute --weird 1000 --ar 1:1",
  "Ice cream icon --niji 6 --style cute --weird 1000 --ar 2:3",
  "Ice cream icon --niji 6 --style expressive --weird 250 --ar 1:1",
  "Ice cream icon --niji 6 --style expressive --weird 250 --ar 2:3",
  "Ice cream icon --niji 6 --style expressive --weird 1000 --ar 1:1",
  "Ice cream icon --niji 6 --style expressive --weird 1000 --ar 2:3"
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
[
  "image of a robot holding flowers --remix --prompt \"A cyborg holding cybernetic orchids\" --zoom 2x"
]======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  "Imagine a 1400s cat --sref <image URL of medieval tapestry> --sv 1 --ar 5:4",
  "Imagine a 1400s cat --sref <image URL of medieval tapestry> --sv 4 --ar 5:4",
  "Imagine a 1990s cat --sref <image URL of medieval tapestry> --sv 1 --ar 5:4",
  "Imagine a 1990s cat --sref <image URL of medieval tapestry> --sv 4 --ar 5:4"
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  "Lithograph potato --weird 500 --chaos 20 --quality .5",
  "Lithograph potato --weird 500 --chaos 20 --quality 1",
  "Lithograph potato --weird 500 --chaos 60 --quality .5",
  "Lithograph potato --weird 500 --chaos 60 --quality 1",
  "Lithograph potato --weird 500 --chaos 80 --quality .5",
  "Lithograph potato --weird 500 --chaos 80 --quality 1",
  "Lithograph potato --weird 1500 --chaos 20 --quality .5",
  "Lithograph potato --weird 1500 --chaos 20 --quality 1",
  "Lithograph potato --weird 1500 --chaos 60 --quality .5",
  "Lithograph potato --weird 1500 --chaos 60 --quality 1",
  "Lithograph potato --weird 1500 --chaos 80 --quality .5",
  "Lithograph potato --weird 1500 --chaos 80 --quality 1",
  "Lithograph potato --weird 2500 --chaos 20 --quality .5",
  "Lithograph potato --weird 2500 --chaos 20 --quality 1",
  "Lithograph potato --weird 2500 --chaos 60 --quality .5",
  "Lithograph potato --weird 2500 --chaos 60 --quality 1",
  "Lithograph potato --weird 2500 --chaos 80 --quality .5",
  "Lithograph potato --weird 2500 --chaos 80 --quality 1"
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  "space:: ship multi-prompt  --stylize 250 --weird 500",
  "space:: ship multi-prompt  --stylize 750 --weird 500"
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
[
  "stream running through a redwood forest --vary region --selection \"sky area\" --prompt \"aurora borealis\" --pan up"
]======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  "Vibrant California poppies --version 5.2 --stylize 100 --quality 1",
  "Vibrant California poppies --version 5.2 --stylize 100 --quality 2",
  "Vibrant California poppies --version 5.2 --stylize 500 --quality 1",
  "Vibrant California poppies --version 5.2 --stylize 500 --quality 2",
  "Vibrant California poppies --version 6 --stylize 100 --quality 1",
  "Vibrant California poppies --version 6 --stylize 100 --quality 2",
  "Vibrant California poppies --version 6 --stylize 500 --quality 1",
  "Vibrant California poppies --version 6 --stylize 500 --quality 2",
  "Vibrant California poppies --version 6.1 --stylize 100 --quality 1",
  "Vibrant California poppies --version 6.1 --stylize 100 --quality 2",
  "Vibrant California poppies --version 6.1 --stylize 500 --quality 1",
  "Vibrant California poppies --version 6.1 --stylize 500 --quality 2"
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 5",
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 5",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 5",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 5"
]
```

## File: test-cases/prompts.sh (Size: 0.44 KB)

```
#!/usr/bin/env bash
# this_file: test-cases/prompts.sh

# THIS READS PROMPTS FROM prompts-in.txt
# THE ERRORS are in prompts-out.txt
# THE OUTPUT OF THE midjargon commands are in the -mj -fal -json -perm files

cat ./prompts-in.txt | while read p; do
    for o in mj fal json perm; do
        echo "> $o '$p'"
        echo "======" >>prompts-$o.txt
        echo "$p" >>prompts-$o.txt
        midjargon "$o" "$p" --json >>prompts-$o.txt
    done
done
```

## File: tests/__init__.py (Size: 0.03 KB)

```
# this_file: tests/__init__.py
```

## File: tests/cli/__init__.py (Size: 0.03 KB)

```
# this_file: tests/cli/__init__.py
```

## File: tests/cli/test_main.py (Size: 10.77 KB)

```
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pytest", "rich"]
# ///
# this_file: tests/cli/test_main.py

"""Tests for CLI functionality."""

import json
import re
import sys
from io import StringIO
from typing import Any

import pytest
from rich.console import Console

from midjargon.cli.main import MidjargonCLI

# Test constants
ASPECT_WIDTH = 16
ASPECT_HEIGHT = 9
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
IMAGE_PROMPTS_COUNT = 2
PERMUTATION_COUNT_2X2 = 4  # 2 options x 2 options

ANSI_ESCAPE = re.compile(r"\x1B[@-_][0-?]*[ -/]*[@-~]")


def parse_json_output(output_stream: StringIO) -> Any:
    """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
    output_stream.seek(0)
    output = output_stream.getvalue()
    # Remove ANSI escape sequences
    output = ANSI_ESCAPE.sub("", output)
    output = output.strip()
    if not output:
        msg = "No JSON found in output"
        raise ValueError(msg)
    try:
        return json.loads(output)
    except json.JSONDecodeError as e:
        msg = "No JSON found in output"
        raise ValueError(msg) from e


@pytest.fixture
def cli():
    """Fixture to provide CLI instance."""
    return MidjargonCLI()


def test_basic_prompt(cli):
    """Test basic prompt processing."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(
            f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT}",
            json_output=True,
        )
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a beautiful landscape"
    assert data["aspect"] == f"{ASPECT_WIDTH}:{ASPECT_HEIGHT}"


def test_permutations(cli):
    """Test permutation processing."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm("a {red, blue} bird", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 2
    texts = set(data)
    assert texts == {"a red bird", "a blue bird"}


def test_raw_output(cli):
    """Test raw output mode."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(f"a photo --stylize {STYLIZE_VALUE}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"
    assert data["stylize"] == STYLIZE_VALUE


def test_json_output_formatting(cli):
    """Test JSON output formatting."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"
    assert "images" in data


def test_invalid_input(cli):
    """Test handling of invalid input."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
        assert data["text"] == ""


def test_parameter_validation(cli):
    """Test parameter validation."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(
            f"a photo --stylize {STYLIZE_VALUE * 20}", json_output=True
        )  # Over max
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
        assert data["stylize"] == STYLIZE_VALUE * 20  # Now accepts any value


def test_image_url_handling(cli):
    """Test handling of image URLs."""
    url = "https://example.com/image.jpg"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(f"{url} a fusion", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a fusion"
    assert len(data["images"]) == 1
    assert data["images"][0] == url


def test_no_color_output(cli):
    """Test no-color output mode."""
    Console(force_terminal=False)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo", json_output=True, no_color=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"


def test_complex_prompt(cli):
    """Test complex prompt with multiple features."""
    prompt = (
        "https://example.com/img1.jpg https://example.com/img2.jpg "
        "a {red, blue} bird on a {branch, rock} "
        f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
    )
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == PERMUTATION_COUNT_2X2
    for prompt in data:
        assert len(prompt["images"]) == IMAGE_PROMPTS_COUNT
        assert prompt["stylize"] == STYLIZE_VALUE
        assert prompt["chaos"] == CHAOS_VALUE
        assert prompt["aspect"] == f"{ASPECT_WIDTH}:{ASPECT_HEIGHT}"


def test_personalization_parameter(cli):
    """Test personalization parameter handling in different forms."""
    # Test flag form (--p)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --p", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] is None  # Flag parameters should be None

    # Test with code (--p CODE1)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --p CODE1", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] == ["CODE1"]

    # Test with multiple codes (--p "CODE1 CODE2")
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json('a photo --p "CODE1 CODE2"', json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] == ["CODE1", "CODE2"]


def test_numeric_range_permutations(cli):
    """Test handling of numeric parameters in permutations."""
    # Test stylize parameter range
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 2
    stylize_values = {prompt["stylize"] for prompt in data}
    assert stylize_values == {75, 300}

    # Test multiple numeric parameters
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --s {75, 300} --c {0, 50}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4  # 2x2 combinations
    stylize_values = {prompt["stylize"] for prompt in data}
    chaos_values = {prompt["chaos"] for prompt in data}
    assert stylize_values == {75, 300}
    assert chaos_values == {0, 50}


def test_nested_parameter_permutations(cli):
    """Test handling of nested permutations with parameters."""
    # Test personalization with nested options
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("smooth edges {, --p {, CODE1}} --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 6  # 3x2 combinations (no --p, empty --p, --p CODE1) x (75, 300)

    # Verify all combinations
    variants = [
        (None, 75),  # No --p, stylize 75
        (None, 300),  # No --p, stylize 300
        (True, 75),  # Empty --p, stylize 75
        (True, 300),  # Empty --p, stylize 300
        (["CODE1"], 75),  # --p with code, stylize 75
        (["CODE1"], 300),  # --p with code, stylize 300
    ]
    for prompt in data:
        assert prompt["text"] == "smooth edges"
        assert (prompt.get("personalization"), prompt["stylize"]) in variants

    # Test more complex nested permutations
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("smooth edges {, --p {, CODE1 CODE2}} --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 6  # 3x2 combinations

    # Verify all combinations
    variants = [
        (None, 75),  # No --p, stylize 75
        (None, 300),  # No --p, stylize 300
        (True, 75),  # Empty --p, stylize 75
        (True, 300),  # Empty --p, stylize 300
        (["CODE1", "CODE2"], 75),  # --p with codes, stylize 75
        (["CODE1", "CODE2"], 300),  # --p with codes, stylize 300
    ]
    for prompt in data:
        assert prompt["text"] == "smooth edges"
        assert (prompt.get("personalization"), prompt["stylize"]) in variants


def test_mj_command(cli):
    """Test Midjourney prompt conversion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.mj("a serene landscape --ar 16:9 --stylize 100", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)  # Changed from list to dict
    assert data["text"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_fal_command(cli):
    """Test Fal.ai prompt conversion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.fal("a serene landscape --ar 16:9 --stylize 100", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["prompt"] == "a serene landscape"
    assert data["aspect_ratio"] == "16:9"
    assert data["stylize"] == 100


def test_perm_command(cli):
    """Test permutation expansion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm("a {red, blue} bird on a {branch, rock}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4
    expected = [
        "a red bird on a branch",
        "a red bird on a rock",
        "a blue bird on a branch",
        "a blue bird on a rock",
    ]
    assert set(data) == set(expected)
```

## File: tests/conftest.py (Size: 1.04 KB)

```
# this_file: tests/conftest.py
"""Pytest configuration and shared fixtures."""

import pytest


@pytest.fixture
def sample_prompts():
    """Return a dictionary of sample prompts for testing."""
    return {
        "basic": "a serene landscape --ar 16:9 --stylize 100",
        "with_image": "https://example.com/image.jpg mystical forest --chaos 20",
        "permutation": "a {red, blue} bird on a {flower, leaf} --ar 16:9",
        "multi_prompt": "mystical forest ::2 foggy mountains ::1 --chaos 20",
        "with_flags": "landscape photo --tile --no blur,cars",
        "escaped_commas": "a {red\\, blue, green} bird",
        "nested": "a {big {red, blue}, small green} bird",
        "multiple_images": "https://example.com/1.jpg https://example.com/2.jpg forest --iw 2",
    }


@pytest.fixture
def invalid_prompts():
    """Return a dictionary of invalid prompts for testing."""
    return {
        "empty": "",
        "only_params": "--ar 16:9",
        "unclosed_brace": "a {red, blue bird",
        "invalid_weight": "forest ::x mountains",
    }
```

## File: tests/core/__init__.py (Size: 0.04 KB)

```
# this_file: tests/core/__init__.py
```

## File: tests/core/test_input.py (Size: 3.74 KB)

```
# this_file: tests/core/test_input.py
"""Tests for input handling."""

from midjargon.core.input import expand_midjargon_input

# Test constants
PERMUTATION_COUNT_2 = 2  # Single permutation with 2 options
PERMUTATION_COUNT_3 = 3  # Single permutation with 3 options


def test_basic_input():
    """Test basic input without permutations."""
    result = expand_midjargon_input("a simple prompt")
    assert len(result) == 1
    assert result[0] == "a simple prompt"


def test_single_permutation():
    """Test input with a single permutation."""
    result = expand_midjargon_input("a {red, blue} bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red bird" in result
    assert "a blue bird" in result


def test_empty_input():
    """Test empty input handling."""
    result = expand_midjargon_input("")
    assert len(result) == 1
    assert result[0] == ""


def test_multiple_permutations():
    """Test input with multiple permutations."""
    result = expand_midjargon_input("a {red, blue, green} bird")
    assert len(result) == PERMUTATION_COUNT_3
    assert "a red bird" in result
    assert "a blue bird" in result
    assert "a green bird" in result


def test_nested_permutations():
    """Test input with nested permutations."""
    result = expand_midjargon_input("a {red {cat, dog}, blue bird}")
    assert len(result) == PERMUTATION_COUNT_3
    assert "a red cat" in result
    assert "a red dog" in result
    assert "a blue bird" in result


def test_escaped_braces():
    """Test input with escaped braces."""
    result = expand_midjargon_input(r"a \{red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"


def test_escaped_commas():
    """Test input with escaped commas."""
    result = expand_midjargon_input(r"a {red\, blue, green} bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red, blue bird" in result
    assert "a green bird" in result


def test_unmatched_braces():
    """Test input with unmatched braces."""
    result = expand_midjargon_input("a {red, blue bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue bird"


def test_empty_permutation():
    """Test input with empty permutation options."""
    result = expand_midjargon_input("a {} bird")
    assert len(result) == 1
    assert result[0] == "a bird"


def test_whitespace_handling():
    """Test input with various whitespace patterns."""
    result = expand_midjargon_input("a {  red  ,  blue  } bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red bird" in result
    assert "a blue bird" in result


def test_expand_midjargon_input():
    """Test expand_midjargon_input function to verify prompt expansion."""
    result = expand_midjargon_input("a {red, blue} bird")
    assert len(result) == 2
    assert "a red bird" in result
    assert "a blue bird" in result

    result = expand_midjargon_input("a {red, blue, green} bird")
    assert len(result) == 3
    assert "a red bird" in result
    assert "a blue bird" in result
    assert "a green bird" in result

    result = expand_midjargon_input("a {red {cat, dog}, blue bird}")
    assert len(result) == 3
    assert "a red cat" in result
    assert "a red dog" in result
    assert "a blue bird" in result


def test_handling_escaped_characters():
    """Test handling of escaped characters in expand_midjargon_input."""
    result = expand_midjargon_input(r"a \{red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"

    result = expand_midjargon_input(r"a {red\, blue, green} bird")
    assert len(result) == 2
    assert "a red, blue bird" in result
    assert "a green bird" in result

    result = expand_midjargon_input(r"a {red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"
```

## File: tests/core/test_parameters.py (Size: 6.49 KB)

```
# this_file: tests/core/test_parameters.py
"""Tests for parameter parsing functionality."""

import pytest

from midjargon.core.parameters import parse_parameters


def test_basic_parameter_parsing():
    """Test parsing of basic parameters."""
    param_str = "--ar 16:9 --stylize 100"
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["stylize"] == "100"


def test_flag_parameters():
    """Test parsing of flag parameters (without values)."""
    param_str = "--tile --turbo --relax"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None


def test_parameter_with_multiple_values():
    """Test parsing parameters that accept multiple values."""
    param_str = "--no blur,cars,watermark"
    params = parse_parameters(param_str)
    assert params["no"] == "blur,cars,watermark"


def test_parameter_with_spaces():
    """Test parsing parameters with values containing spaces."""
    param_str = '--style "raw photo" --seed 123456'
    params = parse_parameters(param_str)
    assert params["style"] == "raw photo"
    assert params["seed"] == "123456"


def test_mixed_parameters():
    """Test parsing a mix of different parameter types."""
    param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["tile"] is None
    assert params["no"] == "blur,cars"
    assert params["style"] == "raw photo"


def test_shorthand_parameters():
    """Test parsing of shorthand parameter names."""
    param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
    params = parse_parameters(param_str)
    assert params["stylize"] == "100"
    assert params["chaos"] == "50"
    assert params["weird"] == "1000"
    assert params["image_weight"] == "2.0"
    assert params["quality"] == "1.0"


def test_niji_version_parameter():
    """Test parsing of niji version parameter."""
    # Test basic niji
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"


def test_version_parameter():
    """Test parsing of version parameter."""
    # Test v parameter
    params = parse_parameters("--v 5.2")
    assert params["version"] == "5.2"


def test_personalization_parameter():
    """Test parsing of personalization parameter."""
    # Test basic p parameter
    params = parse_parameters("--p")
    assert params["personalization"] is None  # Flag without value is None

    # Test p parameter with value
    params = parse_parameters("--p custom")
    assert params["personalization"] == ["custom"]

    # Test p parameter with multiple values
    params = parse_parameters("--p custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]

    # Test personalization parameter with value
    params = parse_parameters("--personalization custom")
    assert params["personalization"] == ["custom"]

    # Test personalization parameter with multiple values
    params = parse_parameters("--personalization custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]


def test_reference_parameters():
    """Test parsing of reference parameters."""
    param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
    params = parse_parameters(param_str)
    assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
    assert params["style_reference"] == ["style1.jpg", "style2.jpg"]


def test_parameter_order():
    """Test that parameter order is preserved in output."""
    param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
    params = parse_parameters(param_str)
    keys = list(params.keys())
    assert keys == ["seed", "aspect", "chaos", "tile"]


def test_invalid_parameters():
    """Test handling of invalid parameter formats."""
    with pytest.raises(ValueError, match="Empty parameter name"):
        parse_parameters("--")  # Empty parameter name

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--ar")  # Missing required value

    with pytest.raises(ValueError, match="Parameter name cannot start with dash"):
        parse_parameters("ar 16:9")  # Missing -- prefix

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--v")  # Missing version value


def test_flag_parameters_handling():
    """Test handling of flag parameters in parse_parameters."""
    param_str = "--tile --turbo --relax --video --remix"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None
    assert params["video"] is None
    assert params["remix"] is None

    param_str = "--p"
    params = parse_parameters(param_str)
    assert params["personalization"] is None  # Flag without value is None

    param_str = "--p custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]

    param_str = "--personalization custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]


def test_special_seed_values():
    """Test handling of special seed values."""
    # Test random seed
    params = parse_parameters("--seed random")
    assert params["seed"] == "random"

    # Test numeric seed
    params = parse_parameters("--seed 12345")
    assert params["seed"] == "12345"


def test_reference_url_handling():
    """Test handling of URLs in reference parameters."""
    # Test character reference with quoted URL containing spaces
    params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
    assert params["character_reference"] == [
        "https://example.com/image with spaces.jpg"
    ]

    # Test style reference with quoted URL containing spaces
    params = parse_parameters('--sref "https://example.com/style with spaces.jpg"')
    assert params["style_reference"] == ["https://example.com/style with spaces.jpg"]


def test_niji_version_handling():
    """Test handling of niji version parameter variations."""
    # Test basic niji
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"

    # Test niji with version and other parameters
    params = parse_parameters("--niji 6 --stylize 100")
    assert params["version"] == "niji 6"
    assert params["stylize"] == "100"
```

## File: tests/core/test_parser.py (Size: 3.27 KB)

```
# this_file: tests/core/test_parser.py
"""Tests for prompt parsing functionality."""

from midjargon.core.parser import parse_midjargon_prompt_to_dict

# Test constants
ASPECT_RATIO = "16:9"
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
IMAGE_URL = "https://example.com/image.jpg"


def test_basic_prompt_parsing():
    """Test basic prompt parsing."""
    prompt = "a beautiful landscape --ar 16:9 --stylize 100"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a beautiful landscape"
    assert result["aspect"] == ASPECT_RATIO
    assert result["stylize"] == STYLIZE_VALUE


def test_prompt_with_image_url():
    """Test prompt parsing with image URL."""
    prompt = f"{IMAGE_URL} a mystical forest --chaos 50"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a mystical forest"
    assert result["images"] == [IMAGE_URL]
    assert result["chaos"] == CHAOS_VALUE


def test_prompt_with_multiple_image_urls():
    """Test prompt parsing with multiple image URLs."""
    image_urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = f"{image_urls[0]} {image_urls[1]} a serene landscape --stylize 100"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a serene landscape"
    assert result["images"] == image_urls
    assert result["stylize"] == STYLIZE_VALUE


def test_prompt_with_parameters():
    """Test prompt parsing with various parameters."""
    prompt = "a futuristic city --ar 16:9 --stylize 100 --chaos 50"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a futuristic city"
    assert result["aspect"] == ASPECT_RATIO
    assert result["stylize"] == STYLIZE_VALUE
    assert result["chaos"] == CHAOS_VALUE


def test_prompt_with_empty_parameters():
    """Test prompt parsing with empty parameters."""
    prompt = "a landscape photo --tile --no blur,cars"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a landscape photo"
    assert result["tile"] is None
    assert result["no"] == "blur,cars"


def test_prompt_with_escaped_characters():
    """Test prompt parsing with escaped characters."""
    prompt = r"a \{red, blue\} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == r"a \{red, blue\} bird"


def test_prompt_with_nested_permutations():
    """Test prompt parsing with nested permutations."""
    prompt = "a {big {red, blue}, small green} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {big {red, blue}, small green} bird"


def test_prompt_with_unmatched_braces():
    """Test prompt parsing with unmatched braces."""
    prompt = "a {red, blue bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {red, blue bird"


def test_prompt_with_empty_permutation():
    """Test prompt parsing with empty permutation options."""
    prompt = "a {} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {} bird"


def test_prompt_with_whitespace_handling():
    """Test prompt parsing with various whitespace patterns."""
    prompt = "a {  red  ,  blue  } bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a { red , blue } bird"
```

## File: tests/engines/__init__.py (Size: 0.04 KB)

```
# this_file: tests/engines/__init__.py
```

## File: tests/engines/midjourney/__init__.py (Size: 0.05 KB)

```
# this_file: tests/engines/midjourney/__init__.py
```

## File: tests/engines/midjourney/test_midjourney_parser.py (Size: 7.50 KB)

```
# this_file: tests/engines/midjourney/test_midjourney_parser.py
"""Tests for Midjourney parser."""

import pytest
from pydantic import HttpUrl

from midjargon.engines.midjourney import MidjourneyParser

# Test constants
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
WEIRD_VALUE = 1000
SEED_VALUE = 12345
STOP_VALUE = 80
IMAGE_WEIGHT_VALUE = 2.0
VERSION_NUMBER = "5.2"
DEFAULT_STYLIZE = 100
QUALITY_VALUE = 1.5
CHARACTER_WEIGHT_VALUE = 50
STYLE_WEIGHT_VALUE = 500
STYLE_VERSION_VALUE = 3
REPEAT_VALUE = 5


def test_numeric_parameters():
    """Test parsing of numeric parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "stylize": str(STYLIZE_VALUE),
            "seed": str(SEED_VALUE),
            "chaos": str(CHAOS_VALUE),
        }
    )

    assert prompt.text == "a photo"
    assert prompt.stylize == float(STYLIZE_VALUE)
    assert prompt.seed == SEED_VALUE
    assert prompt.chaos == float(CHAOS_VALUE)


def test_style_parameters():
    """Test parsing of style parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {"text": "a photo", "style": "raw", "version": VERSION_NUMBER}
    )

    assert prompt.text == "a photo"
    assert prompt.style == "raw"
    assert prompt.version == f"v{VERSION_NUMBER}"


def test_aspect_ratio():
    """Test parsing of aspect ratio."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict({"text": "a photo", "ar": "16:9"})

    assert prompt.text == "a photo"
    assert prompt.aspect_width == 16
    assert prompt.aspect_height == 9
    assert prompt.aspect_ratio == "16:9"


def test_image_prompts():
    """Test parsing of image prompts."""
    parser = MidjourneyParser()
    urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = parser.parse_dict({"text": "a fusion", "image_prompts": urls})

    assert prompt.text == "a fusion"
    assert len(prompt.image_prompts) == 2
    assert all(isinstance(url, HttpUrl) for url in prompt.image_prompts)
    assert [str(url) for url in prompt.image_prompts] == urls


def test_extra_parameters():
    """Test handling of unknown parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "unknown": "value",
            "flag": None,
        }
    )

    assert prompt.text == "a photo"
    assert prompt.extra_params == {"unknown": "value", "flag": None}


def test_parameter_conversion():
    """Test parameter value conversion."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "stylize": str(STYLIZE_VALUE),
            "seed": str(SEED_VALUE),
            "image_weight": str(IMAGE_WEIGHT_VALUE),
        }
    )

    assert prompt.text == "a photo"
    assert prompt.stylize == float(STYLIZE_VALUE)
    assert prompt.seed == SEED_VALUE
    assert prompt.image_weight == float(IMAGE_WEIGHT_VALUE)


def test_invalid_values():
    """Test handling of invalid parameter values."""
    parser = MidjourneyParser()

    # Invalid aspect ratio - now accepts any value
    result = parser.parse_dict({"text": "a photo", "ar": "999:999"})
    assert result.aspect_width == 999
    assert result.aspect_height == 999
    assert result.aspect_ratio == "999:999"

    # Invalid image URL - treated as extra parameter
    result = parser.parse_dict({"text": "a photo", "image": "not_a_url"})
    assert len(result.image_prompts) == 0
    assert result.extra_params.get("image") == "not_a_url"


def test_empty_values():
    """Test handling of empty values."""
    parser = MidjourneyParser()

    # Empty text
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": ""})

    # Empty image list
    prompt = parser.parse_dict({"text": "a photo", "image_prompts": []})
    assert prompt.text == "a photo"
    assert not prompt.image_prompts

    # None values
    prompt = parser.parse_dict({"text": "a photo", "stylize": None})
    assert prompt.text == "a photo"
    assert prompt.stylize == DEFAULT_STYLIZE  # Default value


def test_version_parameter():
    """Test parsing of version parameter."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "version": "6",
        }
    )

    assert prompt.text == "a photo"
    assert prompt.version == "v6"


def test_multiple_permutations():
    """Test handling of multiple permutations."""
    parser = MidjourneyParser()

    # Test with parameter permutations
    input_dicts = [
        {"text": "smooth edges", "stylize": "75"},
        {"text": "smooth edges", "stylize": "300"},
        {"text": "smooth edges", "stylize": "75", "personalization": True},
        {"text": "smooth edges", "stylize": "300", "personalization": True},
    ]

    results = [parser.parse_dict(d) for d in input_dicts]
    assert len(results) == 4

    # Verify each permutation is handled correctly
    result_tuples = {(r.text.strip(), r.stylize, r.personalization) for r in results}

    expected = {
        ("smooth edges", 75.0, False),
        ("smooth edges", 300.0, False),
        ("smooth edges", 75.0, True),
        ("smooth edges", 300.0, True),
    }

    assert result_tuples == expected

    # Test with flag permutations
    input_dicts = [
        {"text": "photo"},
        {"text": "photo", "tile": True},
        {"text": "photo", "turbo": True},
        {"text": "photo", "tile": True, "turbo": True},
    ]

    results = [parser.parse_dict(d) for d in input_dicts]
    assert len(results) == 4

    # Verify each permutation is handled correctly
    result_tuples = {(r.text.strip(), r.tile, r.turbo) for r in results}

    expected = {
        ("photo", False, False),
        ("photo", True, False),
        ("photo", False, True),
        ("photo", True, True),
    }

    assert result_tuples == expected


def test_personalization_parameter():
    """Test parsing of personalization parameter."""
    parser = MidjourneyParser()

    # Test flag with True value
    prompt = parser.parse_dict({"text": "a photo", "personalization": True})
    assert prompt.personalization is True

    # Test flag with False value
    prompt = parser.parse_dict({"text": "a photo", "personalization": False})
    assert prompt.personalization is False


def test_edge_cases():
    """Test handling of edge cases in Midjourney parser."""
    parser = MidjourneyParser()

    # Test empty prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": ""})

    # Test prompt with only spaces
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": "   "})

    # Test prompt with special characters
    prompt = parser.parse_dict({"text": "a photo with special characters !@#$%^&*()"})
    assert prompt.text == "a photo with special characters !@#$%^&*()"

    # Test prompt with long text
    long_text = "a" * 1000
    prompt = parser.parse_dict({"text": long_text})
    assert prompt.text == long_text

    # Test prompt with mixed types in extra parameters
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "extra1": "123",
            "extra2": "45.67",
            "extra3": "true",
            "extra4": None,
            "extra5": "item1",
        }
    )
    assert prompt.extra_params["extra1"] == "123"
    assert prompt.extra_params["extra2"] == "45.67"
    assert prompt.extra_params["extra3"] == "true"
    assert prompt.extra_params["extra4"] is None
    assert prompt.extra_params["extra5"] == "item1"
```

## File: tests/integration/__init__.py (Size: 0.04 KB)

```
# this_file: tests/integration/__init__.py
```

## File: tests/integration/test_workflow.py (Size: 7.01 KB)

```
#!/usr/bin/env python3
# this_file: tests/integration/test_workflow.py

"""Integration tests for the complete workflow."""

import sys
from io import StringIO

import pytest

from midjargon.cli.main import MidjargonCLI
from midjargon.core.input import expand_midjargon_input
from midjargon.core.parser import parse_midjargon_prompt_to_dict


def process_prompt(prompt: str) -> list[dict]:
    """Process a prompt through the complete workflow.

    Args:
        prompt: The prompt to process.

    Returns:
        List of dictionaries representing the processed prompts.
    """
    variants = expand_midjargon_input(prompt)
    results = []
    for variant in variants:
        results.append(parse_midjargon_prompt_to_dict(variant.prompt.to_string()))
    return results


def test_basic_workflow():
    """Test basic prompt processing workflow."""
    prompt = "a portrait --ar 16:9 --stylize 200"
    results = process_prompt(prompt)

    assert len(results) == 1
    assert results[0]["text"] == "a portrait"
    assert results[0]["aspect_ratio"] == "16:9"
    assert results[0]["stylize"] == 200


def test_permutation_workflow():
    """Test workflow with permutations."""
    prompt = "a {red, blue} bird"
    results = process_prompt(prompt)

    assert len(results) == 2
    assert any("red" in r["text"] for r in results)
    assert any("blue" in r["text"] for r in results)


def test_image_workflow():
    """Test workflow with image URLs."""
    prompt = "https://example.com/image.jpg a portrait"
    results = process_prompt(prompt)

    assert len(results) == 1
    assert len(results[0]["image_prompts"]) == 1
    assert str(results[0]["image_prompts"][0]) == "https://example.com/image.jpg"


def test_parameter_workflow():
    """Test workflow with various parameters."""
    prompt = "portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
    results = process_prompt(prompt)

    assert len(results) == 1
    assert results[0]["text"] == "portrait"
    assert results[0]["aspect_ratio"] == "16:9"
    assert results[0]["stylize"] == 200
    assert results[0]["chaos"] == 50
    assert results[0]["version"] == "v6"


def test_new_parameters_workflow():
    """Test workflow with newer parameters."""
    prompt = "portrait --cref https://example.com/char.jpg --cw 50"
    results = process_prompt(prompt)

    assert len(results) == 1
    assert len(results[0]["character_reference"]) == 1
    assert results[0]["character_weight"] == 50


def test_weighted_prompts_workflow():
    """Test workflow with weighted prompts."""
    prompt = "first prompt::0.7 second prompt::0.3"
    results = process_prompt(prompt)

    assert len(results) == 2
    weights = [r.get("weight", 1.0) for r in results]
    assert 0.7 in weights
    assert 0.3 in weights


def test_error_workflow():
    """Test workflow error handling."""
    with pytest.raises(ValueError):
        process_prompt("portrait --ar invalid")


def test_complex_workflow():
    """Test workflow with complex combinations."""
    prompt = "a {red, blue} bird::0.6 a {green, yellow} tree::0.4"
    results = process_prompt(prompt)

    assert len(results) == 4
    colors = set()
    for r in results:
        text = r["text"].lower()
        if "red" in text:
            colors.add("red")
        if "blue" in text:
            colors.add("blue")
        if "green" in text:
            colors.add("green")
        if "yellow" in text:
            colors.add("yellow")
    assert colors == {"red", "blue", "green", "yellow"}


def test_permutations_with_parameters():
    """Test permutations with parameters."""
    prompt = "photo {modern, vintage} --ar {1:1, 16:9} --s 100"
    results = process_prompt(prompt)

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (r["text"].strip(), r["aspect_ratio"], r["stylize"]) for r in results
    }

    expected = {
        ("photo modern", "1:1", 100),
        ("photo modern", "16:9", 100),
        ("photo vintage", "1:1", 100),
        ("photo vintage", "16:9", 100),
    }
    assert result_tuples == expected


def test_permutations_with_flag_parameters():
    """Test permutations with flag parameters (no value) are handled correctly."""
    prompt = "photo {, --tile} {, --turbo}"
    results = process_prompt(prompt)

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (r["text"].strip(), r.get("tile", False), r.get("turbo", False))
        for r in results
    }

    expected = {
        ("photo", False, False),
        ("photo", False, True),
        ("photo", True, False),
        ("photo", True, True),
    }
    assert result_tuples == expected


def test_permutations_with_complex_parameters():
    """Test permutations with complex parameter combinations."""
    prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
    results = process_prompt(prompt)

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (
            r["text"].strip(),
            (
                r["personalization"][0]
                if isinstance(r.get("personalization", []), list)
                else r.get("personalization")
            ),
            f"{r['aspect_width']}:{r['aspect_height']}",
            r["stylize"],
        )
        for r in results
    }

    expected = {
        ("portrait modern", None, "1:1", 100),
        ("portrait modern", "custom", "1:1", 100),
        ("portrait modern", None, "16:9", 100),
        ("portrait modern", "custom", "16:9", 100),
        ("portrait vintage", None, "1:1", 100),
        ("portrait vintage", "custom", "1:1", 100),
        ("portrait vintage", None, "16:9", 100),
        ("portrait vintage", "custom", "16:9", 100),
    }
    assert result_tuples == expected


def test_cli_mj_command():
    """Test Midjourney prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.mj(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        output = capture_stdout.getvalue()
    assert "serene landscape" in output
    assert "16:9" in output
    assert "100" in output


def test_cli_fal_command():
    """Test Fal.ai prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.fal(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        output = capture_stdout.getvalue()
    assert "serene landscape" in output
    assert "16:9" in output
    assert "100" in output


def test_cli_perm_command():
    """Test permutation expansion using CLI."""
    cli = MidjargonCLI()
    prompt = "a {red, blue} bird on a {branch, rock}"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        output = capture_stdout.getvalue()
    assert "red" in output
    assert "blue" in output
    assert "branch" in output
    assert "rock" in output
```

## File: tests/test_core.py (Size: 4.50 KB)

```
#!/usr/bin/env python3
# this_file: tests/test_core.py

import pytest

from midjargon import expand_midjargon_input
from midjargon.core.models import (
    MidjourneyParameters,
    MidjourneyPrompt,
)
from midjargon.core.parser import parse_midjargon_prompt
from midjargon.core.permutations import expand_permutations


def test_basic_prompt_parsing():
    """Test basic prompt parsing without parameters."""
    prompt = "a beautiful landscape"
    result = parse_midjargon_prompt(prompt)
    assert isinstance(result, MidjourneyPrompt)
    assert result.text == "a beautiful landscape"
    assert not result.image_prompts
    assert result.parameters == MidjourneyParameters()


def test_prompt_with_parameters():
    """Test prompt parsing with various parameters."""
    prompt = "a portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
    result = parse_midjargon_prompt(prompt)

    assert result.text == "a portrait"
    assert result.parameters.aspect == "16:9"
    assert result.parameters.stylize == 200
    assert result.parameters.chaos == 50
    assert result.parameters.version == "v6"


def test_prompt_with_image():
    """Test prompt parsing with image URLs."""
    prompt = "https://example.com/image.jpg a photo in this style"
    result = parse_midjargon_prompt(prompt)

    assert result.text == "a photo in this style"
    assert len(result.image_prompts) == 1
    assert str(result.image_prompts[0]) == "https://example.com/image.jpg"


def test_invalid_parameters():
    """Test handling of invalid parameters."""
    with pytest.raises(ValueError):
        parse_midjargon_prompt("test --invalid value")


def test_permutation_expansion():
    """Test permutation expansion."""
    prompt = "a {red, blue} bird on a {green, yellow} tree"
    results = expand_permutations(prompt)

    assert len(results) == 4
    assert "a red bird on a green tree" in results
    assert "a red bird on a yellow tree" in results
    assert "a blue bird on a green tree" in results
    assert "a blue bird on a yellow tree" in results


def test_escaped_permutations():
    """Test handling of escaped characters in permutations."""
    prompt = r"a {red\, orange, blue} bird"
    results = expand_permutations(prompt)

    assert len(results) == 2
    assert "a red, orange bird" in results
    assert "a blue bird" in results


def test_weighted_prompts():
    """Test handling of weighted prompts."""
    prompt = "first prompt::0.7 second prompt::0.3"
    results = expand_midjargon_input(prompt)

    assert len(results) == 2
    assert results[0].weight == 0.7
    assert results[1].weight == 0.3


def test_combined_features():
    """Test combination of multiple features."""
    prompt = "a {red, blue} bird::0.6 a {green, yellow} tree::0.4"
    results = expand_midjargon_input(prompt)

    assert len(results) == 4
    # Check first group
    red_blue = [r for r in results if "bird" in r.prompt.text]
    assert len(red_blue) == 2
    assert all("bird" in r.prompt.text for r in red_blue)
    assert all(r.weight == 0.6 for r in red_blue)

    # Check second group
    green_yellow = [r for r in results if "tree" in r.prompt.text]
    assert len(green_yellow) == 2
    assert all("tree" in r.prompt.text for r in green_yellow)
    assert all(r.weight == 0.4 for r in green_yellow)


def test_style_reference():
    """Test handling of style references."""
    # Test with code
    prompt = "test --sref p123456"
    result = parse_midjargon_prompt(prompt)
    assert result.style_reference
    assert result.style_reference[0].code == "p123456"

    # Test with URL
    prompt = "test --sref https://example.com/style.jpg"
    result = parse_midjargon_prompt(prompt)
    assert result.style_reference
    assert str(result.style_reference[0].url) == "https://example.com/style.jpg"


def test_character_reference():
    """Test handling of character references."""
    prompt = "test --cref https://example.com/char.jpg --cw 50"
    result = parse_midjargon_prompt(prompt)

    assert result.character_reference
    assert str(result.character_reference[0].url) == "https://example.com/char.jpg"
    assert result.character_weight == 50


def test_prompt_to_string():
    """Test conversion of prompt back to string format."""
    original = "a portrait --ar 16:9 --stylize 200"
    result = parse_midjargon_prompt(original)

    # Convert back to string
    output = result.to_string()

    # Parse again to verify equivalence
    reparsed = parse_midjargon_prompt(output)
    assert reparsed.text == result.text
    assert reparsed.parameters.model_dump() == result.parameters.model_dump()
```

## File: tests/test_package.py (Size: 0.18 KB)

```
# this_file: tests/test_package.py
"""Test suite for midjargon."""


def test_version():
    """Verify package exposes version."""
    import midjargon

    assert midjargon.__version__
```

## File: updateme.sh (Size: 0.64 KB)

```
#!/usr/bin/env bash
# this_file: ./printme.sh
uv venv
# Activate venv if not active
if [[ -z "${VIRTUAL_ENV}" ]] && [[ -f "venv/bin/activate" ]]; then
    source venv/bin/activate
    uv pip install fire gitignore-find
fi
uv pip install -e .[all]
if [ -e ./midjargon.txt ]; then
    rm ./midjargon.txt
fi
if [ -z "$VIRTUAL_ENV" ]; then
    uv pip install --system gitignore-find
else
    uv pip install gitignore-find
fi
printfolder . ../midjargon.txt && mv ../midjargon.txt .

hatch run lint:style >ERRORS.txt
hatch test >>ERRORS.txt

cat midjargon.txt ERRORS.txt

echo ">> The codebase is in @midjargon.txt and the recent errors are in @ERRORS.txt"
```
</file>

<file path="src/midjargon/engines/fal/converter.py">
"""
Functions for converting MidjargonDict to Fal.ai API format.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any, TypeAlias, cast

if TYPE_CHECKING:
    from midjargon.core.type_defs import MidjargonDict

# Type alias for Fal.ai API dict format
FalDict: TypeAlias = dict[str, Any]


def _convert_aspect_ratio(d: dict | FalDict | MidjargonDict) -> dict:
    """Convert aspect ratio parameter to Fal.ai format."""
    result = d.copy()
    if "aspect" in result:
        result["aspect_ratio"] = result.pop("aspect")
    return result


def _convert_image_prompts(d: dict | FalDict | MidjargonDict) -> dict:
    """Convert image prompts to Fal.ai format."""
    result = d.copy()
    if "images" in result and isinstance(result["images"], list) and result["images"]:
        result["image_url"] = result["images"][0]
        if len(result["images"]) > 1:
            result["_"] = cast(Any, {"images": result["images"][1:]})
        del result["images"]
    return result


def _convert_text_prompt(d: dict | FalDict | MidjargonDict) -> dict:
    """Convert text prompt to Fal.ai format."""
    result = d.copy()
    if "text" in result:
        result["prompt"] = result.pop("text")
    return result


def _convert_numeric_values(d: dict | FalDict | MidjargonDict) -> dict:
    """Convert numeric values to appropriate types."""
    result: dict[str, Any] = d.copy()
    for key, value in result.items():
        if isinstance(value, str):
            if value.isdigit():
                result[key] = int(value)
            elif value.replace(".", "").isdigit():
                result[key] = float(value)
    return result


def to_fal_dict(d: dict | FalDict | MidjargonDict) -> FalDict:
    """
    Convert a MidjargonDict to Fal.ai API format.

    Args:
        d: Dictionary to convert.

    Returns:
        Dictionary in Fal.ai API format.
    """
    result = d.copy()
    for conversion_step in (
        _convert_numeric_values,
        _convert_aspect_ratio,
        _convert_image_prompts,
        _convert_text_prompt,
    ):
        result = conversion_step(result)
    return result
</file>

<file path="src/midjargon/engines/midjourney/midjourney.py">
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/midjourney.py
from __future__ import annotations

from typing import Any

from midjargon.core.models import (CharacterReference, ImageReference,
                                   MidjourneyParameters, MidjourneyPrompt,
                                   StyleReference)
from pydantic import HttpUrl


class MidjourneyParser:
    """Parser for converting between Midjourney prompt formats."""

    def _parse_url(self, url: str) -> HttpUrl:
        """Parse a URL string into an HttpUrl object.

        Args:
            url: URL string to parse.

        Returns:
            HttpUrl instance.
        """
        return HttpUrl(url)

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.

        Args:
            prompt_dict: Dictionary containing prompt data.

        Returns:
            MidjourneyPrompt instance.

        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)

        # Handle image prompts
        image_prompts = []
        raw_image_prompts = prompt_dict.pop("image_prompts", [])
        for img in raw_image_prompts:
            if isinstance(img, str):
                image_prompts.append(ImageReference(url=self._parse_url(img)))
            elif isinstance(img, dict):
                if "url" in img and isinstance(img["url"], str):
                    img["url"] = self._parse_url(img["url"])
                image_prompts.append(ImageReference(**img))
            elif isinstance(img, ImageReference):
                image_prompts.append(img)

        # Handle parameters
        params = MidjourneyParameters()

        # Handle aspect ratio
        if "ar" in prompt_dict:
            params.aspect_ratio = prompt_dict.pop("ar")
        elif "aspect_ratio" in prompt_dict:
            params.aspect_ratio = prompt_dict.pop("aspect_ratio")
        elif "aspect" in prompt_dict:
            params.aspect_ratio = prompt_dict.pop("aspect")
        elif all(k in prompt_dict for k in ["aspect_width", "aspect_height"]):
            params.aspect_width = int(prompt_dict.pop("aspect_width"))
            params.aspect_height = int(prompt_dict.pop("aspect_height"))

        # Handle version
        if "v" in prompt_dict:
            params.version = prompt_dict.pop("v")
        elif "version" in prompt_dict:
            params.version = prompt_dict.pop("version")

        # Handle style
        if "style" in prompt_dict:
            params.style = prompt_dict.pop("style")

        # Handle numeric parameters
        if "s" in prompt_dict:
            params.stylize = float(prompt_dict.pop("s"))
        elif "stylize" in prompt_dict:
            params.stylize = float(prompt_dict.pop("stylize"))

        if "c" in prompt_dict:
            params.chaos = float(prompt_dict.pop("c"))
        elif "chaos" in prompt_dict:
            params.chaos = float(prompt_dict.pop("chaos"))

        if "weird" in prompt_dict:
            params.weird = float(prompt_dict.pop("weird"))

        if "seed" in prompt_dict:
            params.seed = prompt_dict.pop("seed")

        # Handle boolean flags
        for flag in ["tile", "turbo", "relax", "personalization"]:
            if flag in prompt_dict:
                setattr(params, flag, bool(prompt_dict.pop(flag)))

        # Handle references
        if "cref" in prompt_dict:
            ref = prompt_dict.pop("cref")
            weight = float(prompt_dict.pop("cw", 1.0))
            if isinstance(ref, str):
                if ref.startswith("http"):
                    params.character_reference.append(
                        CharacterReference(url=self._parse_url(ref), weight=weight)
                    )
                else:
                    params.character_reference.append(
                        CharacterReference(code=ref, weight=weight)
                    )

        if "sref" in prompt_dict:
            ref = prompt_dict.pop("sref")
            weight = float(prompt_dict.pop("sw", 1.0))
            if isinstance(ref, str):
                if ref.startswith("http"):
                    params.style_reference.append(
                        StyleReference(url=self._parse_url(ref), weight=weight)
                    )
                else:
                    params.style_reference.append(
                        StyleReference(code=ref, weight=weight)
                    )

        # Handle remaining parameters
        params.extra_params = prompt_dict

        return MidjourneyPrompt(
            text=text,
            image_prompts=image_prompts,
            parameters=params,
        )


def parse_midjourney_dict(prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
    """Convert a dictionary to a MidjourneyPrompt.

    Args:
        prompt_dict: Dictionary containing prompt data.

    Returns:
        MidjourneyPrompt instance.
    """
    parser = MidjourneyParser()
    return parser.parse_dict(prompt_dict)
</file>

<file path="tests/conftest.py">
"""Pytest configuration and shared fixtures."""

import pytest


@pytest.fixture
def sample_prompts():
    """Return a dictionary of sample prompts for testing."""
    return {
        "basic": "a serene landscape --ar 16:9 --stylize 100",
        "with_image": "https://example.com/image.jpg mystical forest --chaos 20",
        "permutation": "a {red, blue} bird on a {flower, leaf} --ar 16:9",
        "multi_prompt": "mystical forest ::2 foggy mountains ::1 --chaos 20",
        "with_flags": "landscape photo --tile --no blur,cars",
        "escaped_commas": "a {red\\, blue, green} bird",
        "nested": "a {big {red, blue}, small green} bird",
        "multiple_images": "https://example.com/1.jpg https://example.com/2.jpg forest --iw 2",
    }


@pytest.fixture
def invalid_prompts():
    """Return a dictionary of invalid prompts for testing."""
    return {
        "empty": "",
        "only_params": "--ar 16:9",
        "unclosed_brace": "a {red, blue bird",
        "invalid_weight": "forest ::x mountains",
    }
</file>

<file path=".gitignore">
!**/[Pp]ackages/build/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!?*.[Cc]ache/
!Directory.Build.rsp
!dist/.gitkeep
$tf/
*$py.class
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
**/[Pp]ackages/*
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim.layout
*.bim_*.settings
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.cover
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.egg
*.egg-info/
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.py,cover
*.py[cod]
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.swo
*.swp
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
*_autogen/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*~
.*crunch*.local.xml
._*
.axoCover/*
.builds
.cache
.coverage
.coverage.*
.cr/personal
.DS_Store
.DS_Store?
.eggs/
.env
.fake/
.history/
.hypothesis/
.idea/
.installed.cfg
.ionide/
.localhistory/
.mfractor/
.mypy_cache/
.nox/
.ntvs_analysis.dat
.paket/paket.exe
.pytest_cache/
.Python
.ruff_cache/
.sass-cache/
.Spotlight-V100
.tox/
.Trashes
.venv
.vs/
.vscode
.vscode/
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
__pycache__/
__version__.py
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
build/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
cover/
coverage*.info
coverage*.json
coverage*.xml
coverage.xml
csx/
CTestTestfile.cmake
develop-eggs/
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
downloads/
ecf/
eggs/
ehthumbs.db
env.bak/
env/
ENV/
FakesAssemblies/
FodyWeavers.xsd
Generated\ Files/
Generated_Code/
healthchecksdb
htmlcov/
install_manifest.txt
ipch/
lib/
lib64/
Makefile
MANIFEST
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nosetests.xml
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
parts/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
sdist/
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
Thumbs.db
UpgradeLog*.htm
UpgradeLog*.XML
var/
venv.bak/
venv/
wheels/
x64/
x86/
~$*
.aider*
/_private

_private
</file>

<file path=".cursor/rules/midjargon.mdc">
---
description: "Midjargon configuration documentation for folder structure."
globs: []
---
# `midjargon`

`midjargon` is a hatch-managed Python library for parsing and manipulating Midjourney prompts using a specialized syntax. This tool helps you work with Midjourney prompts in a structured way, handling complex features like permutations, parameter validation, and image URL extraction.

## Folder structure

### Root

```
 LICENSE                    # MIT license
 README.md                  # Project introduction and documentation
 TODO.md                    # Task list (clear before release)
 TODO2.md                   # Additional tasks and feature proposals
 dist                       # Distribution files
 docs                       # Project documentation
    midjourney-docs.md      # Original Midjourney documentation
    refactoring-ideas.md    # Refactoring ideas
    specification.md        # Detailed prompt syntax specification
 package.toml               # Hatch project configuration
 pyproject.toml             # Python project configuration
 pytest.ini                 # Pytest configuration
 uv.lock                    # UV dependency lock file
```

### Source Code

```
 src
    midjargon
        __init__.py
        __main__.py        # CLI entry point (Fire-based)
        cli
           __init__.py
           main.py        # CLI command definitions
        core
           __init__.py
           converter.py     # Conversion utilities for prompts
           input.py         # Input processing and permutation expansion
           parameters.py    # Parsing and validation of parameters
           parser.py        # Basic prompt parser converting text to dictionary
           permutations.py  # Permutation expansion logic
           type_defs.py     # Type definitions for midjargon
        engines
            __init__.py
            base.py          # Abstract engine base for converters
            fal            # Fal.ai engine implementation
               __init__.py
               converter.py   # Conversion to Fal.ai API format
            midjourney     # Midjourney engine implementation
                __init__.py
                constants.py   # Parameter constraints and defaults
                models.py      # Pydantic models for validated prompts
                parser.py      # Engine-specific parsing logic
```

### Tests

```
 tests
    cli
       __init__.py
       test_main.py       # CLI tests
    conftest.py            # Pytest shared fixtures
    core
       __init__.py
       test_input.py      # Input handling tests
       test_parameters.py # Parameter parsing tests
       test_permutations.py # Permutation expansion tests
    engines
       __init__.py
       midjourney
          __init__.py
          test_parser.py  # Midjourney engine tests
       test_base.py       # Engine base functionality tests
    integration
       test_workflow.py   # End-to-end workflow tests
    test_package.py        # Package interface tests
```
</file>

<file path="src/midjargon/cli/__init__.py">
"""
CLI interface for midjargon.
"""

from midjargon.cli.main import main

__all__ = ["main"]
</file>

<file path="src/midjargon/core/__init__.py">
"""
midjargon.core
~~~~~~~~~~~~~

Core functionality for prompt parsing and manipulation.

This module provides the base classes and utilities for:
- Prompt parsing and validation
- Parameter handling and normalization
- Text manipulation and splitting
- Type definitions for the midjargon package

The core module is engine-agnostic and provides the foundation for
specific engine implementations (like Midjourney).
"""

from midjargon.core.input import expand_midjargon_input
from midjargon.core.parameters import (ParamDict, ParamName, ParamValue,
                                       parse_parameters)
from midjargon.core.parser import parse_midjargon_prompt_to_dict
from midjargon.core.permutations import expand_text
from midjargon.core.type_defs import (MidjargonDict, MidjargonInput,
                                      MidjargonList, MidjargonPrompt)

__all__ = [
    "MidjargonDict",
    # Type definitions
    "MidjargonInput",
    "MidjargonList",
    "MidjargonPrompt",
    "ParamDict",
    "ParamName",
    "ParamValue",
    # Core functions
    "expand_midjargon_input",
    "expand_text",
    "parse_midjargon_prompt_to_dict",
    "parse_parameters",
]
</file>

<file path="src/midjargon/core/converter.py">
"""
TODO: Here are several end-user functionalites that our code can do. Your task is to implement the body of these functions, following the `TODO` indicators:

1. permute_prompt
2. parse_prompt
3. _prep_conversion
4. to_midjourney_prompts
5. to_fal_dicts

Let's modify the `cli` section of our code and expose these functions as Fire CLI commands. Move the existing CLI handling into a Fire `midjargon` command.
"""

from __future__ import annotations

from typing import TYPE_CHECKING
from typing import Annotated as Doc

from midjargon.core.input import expand_midjargon_input
from midjargon.core.parser import parse_midjargon_prompt_to_dict
from midjargon.engines.fal import FalDict, to_fal_dict
from midjargon.engines.midjourney import (MidjourneyPrompt,
                                          parse_midjourney_dict)

if TYPE_CHECKING:
    from midjargon.core.type_defs import MidjargonDict


def permute_prompt(
    text: Doc[str, Input prompt that may include permutation markers],
) -> Doc[list[str], List of permutated prompt strings]:
    """
    Permute the input prompt, expanding it into a list of strings, by replacing permutation markers with actual values.

    Also, in our CLI, expose this as `permute` command.

    Args:
        text: The input prompt containing permutation markers.

    Returns:
        Always list of permutated prompt strings.
    """
    return expand_midjargon_input(text)


def parse_prompt(
    text: Doc[str, Input prompt string],
    permute: Doc[
        bool,
        if true, we pass the prompt to permute_prompt first and then parse all prompts,
    ],
) -> Doc[MidjargonDict | list[MidjargonDict], List of parsed prompt dicts]:
    """
    Parse the input prompt into:
    - a single dict (if permute is False)
    - or a list of dicts (if permute is True). When permute is True, we always return a list, even if there's only one result.

    Also, in our CLI, expose this as `json` command. In CLI.

    Args:
        text: The input prompt that may contain permutation markers if permute is True.
        permute: If True, we pass the prompt to permute_prompt first and then parse all prompts.

    Returns:
        A single dict (if permute is False) or a list of dicts (if permute is True).
    """
    if not permute:
        return parse_midjargon_prompt_to_dict(text)

    expanded = permute_prompt(text)
    if not expanded:
        return [parse_midjargon_prompt_to_dict(text)]

    return [parse_midjargon_prompt_to_dict(prompt) for prompt in expanded]


def _prep_conversion(
    prompt: Doc[
        str | list[str] | MidjargonDict | list[MidjargonDict],
        Prompt(s) to convert, in various forms,
    ],
) -> Doc[list[MidjargonDict], List of MidJargonDicts]:
    """
    If input is:
        - a single str, permute it and call this function on the list of the result strings
        - a list of strings, call parse_prompt on each, then call this function again on the resulting list of dicts
        - a single dict, treat it as a single-item list of dicts
    Return:
        - a list of MidJargonDict
    """
    if isinstance(prompt, str):
        # Always expand permutations for strings
        expanded = permute_prompt(str(prompt))
        if not expanded:
            # If no permutations, parse as a single prompt
            return [parse_prompt(prompt, permute=False)]  # type: ignore
        # Parse each expanded permutation
        return [parse_prompt(p, permute=False) for p in expanded]  # type: ignore

    if isinstance(prompt, list):
        if not prompt:
            return []
        if all(isinstance(p, str) for p in prompt):
            # For list of strings, parse each one with permutations
            dicts = []
            for p in prompt:
                expanded = permute_prompt(str(p))
                if expanded:
                    dicts.extend(parse_prompt(exp, permute=False) for exp in expanded)  # type: ignore
                else:
                    dicts.append(parse_prompt(p, permute=False))  # type: ignore
            return dicts
        if all(isinstance(p, dict) for p in prompt):
            return list(prompt)  # type: ignore
        msg = f"Unsupported list item type: {type(prompt[0])}"
        raise ValueError(msg)

    if isinstance(prompt, dict):
        return [prompt]

    msg = f"Unsupported prompt type: {type(prompt)}"
    raise ValueError(msg)


def to_midjourney_prompts(
    prompt: Doc[
        str | list[str] | MidjargonDict | list[MidjargonDict],
        Prompt(s) to convert as Midjourney prompt,
    ],
) -> Doc[MidjourneyPrompt | list[MidjourneyPrompt], Midjourney prompt(s)]:
    """
    Convert the input prompt(s) into a Midjourney prompt(s). Pass the inputs to _prep_conversion and then take the resulting list of dicts and perform the actual conversion, calling parse_midjourney_dict on each, and prepare a list of MidjourneyPrompt results.

    Also, in our CLI, expose this as `midjourney` command.

    Return:
        - a single MidjourneyPrompt if input is a single dict or non-permuted string
        - a list of MidjourneyPrompt if input contains permutations or is a list
    """
    dicts = _prep_conversion(prompt)
    if not dicts:
        msg = "No valid prompts found"
        raise ValueError(msg)

    results = [parse_midjourney_dict(d) for d in dicts]
    # Return a list if input was a string with permutations or a list
    if isinstance(prompt, str) and "{" in prompt:
        return results
    if isinstance(prompt, list):
        return results
    return results[0] if len(results) == 1 else results


def to_fal_dicts(
    prompt: Doc[
        str | list[str] | MidjargonDict | list[MidjargonDict],
        Prompt(s) to convert as Fal prompt,
    ],
) -> Doc[FalDict | list[FalDict], Fal prompt(s)]:
    """
    Convert the input prompt(s) into Fal.ai prompt(s). Pass the inputs to _prep_conversion and then take the resulting list of dicts and perform the actual conversion, calling to_fal_dict on each, and prepare a list of FalDict results.

    Also, in our CLI, expose this as `fal` command.

    Return:
        - a single FalDict if input is a single dict or non-permuted string
        - a list of FalDict if input contains permutations or is a list
    """
    dicts = _prep_conversion(prompt)
    if not dicts:
        msg = "No valid prompts found"
        raise ValueError(msg)

    results = [to_fal_dict(d) for d in dicts]
    # Always return a list if input was a string with permutations
    if isinstance(prompt, str) and "{" in prompt:
        return results
    if isinstance(prompt, list):
        return results
    # For single inputs without permutations, return just the first result
    return results[0] if len(results) == 1 else results
</file>

<file path="src/midjargon/core/models.py">
#!/usr/bin/env python3
# this_file: src/midjargon/core/models.py
from __future__ import annotations

from enum import Enum
from typing import Any, TypeVar

from pydantic import (BaseModel, Field, HttpUrl, field_validator,
                      model_validator)

T = TypeVar("T", bound="BaseModel")


class MidjourneyVersion(str, Enum):
    """Midjourney model version."""

    V4 = "v4"
    V5 = "v5"
    V5_1 = "v5.1"
    V5_2 = "v5.2"
    V6 = "v6"
    V6_1 = "v6.1"
    NIJI4 = "niji4"
    NIJI5 = "niji5"
    NIJI6 = "niji6"

    @classmethod
    def _missing_(cls, value: Any) -> MidjourneyVersion | None:
        """Handle missing values by trying to normalize the input."""
        try:
            # Try to normalize version string
            value = str(value).lower().strip()

            # Handle numeric versions (e.g., 4, 5, 6)
            if value.replace(".", "").isdigit():
                value = f"v{value}" if "." not in value else f"v{value}"

            # Handle niji versions
            if value == "niji":
                return cls.NIJI6
            if value.startswith("niji"):
                for member in cls:
                    if member.value == value:
                        return member
                return cls.NIJI6

            # Handle v prefix
            if not value.startswith("v") and not value.startswith("niji"):
                value = f"v{value}"

            # Try exact match first
            for member in cls:
                if member.value == value:
                    return member

            # Try prefix match for v* versions
            if value.startswith("v"):
                base_version = value.split(".")[0]
                latest_version = None
                for member in cls:
                    if member.value.startswith(base_version) and (
                        latest_version is None or member.value > latest_version.value
                    ):
                        latest_version = member
                if latest_version:
                    return latest_version

            return None
        except Exception:
            return None


class StyleMode(str, Enum):
    """Available style modes."""

    RAW = "raw"
    CUTE = "cute"
    EXPRESSIVE = "expressive"
    SCENIC = "scenic"
    ORIGINAL = "original"


class ImageReference(BaseModel):
    """Reference to an image."""

    url: HttpUrl
    weight: float = Field(default=1.0, ge=0.0, le=2.0)

    def __str__(self) -> str:
        """Convert to string format."""
        return str(self.url)


class CharacterReference(BaseModel):
    """Reference to a character."""

    url: HttpUrl | None = None
    code: str | None = None
    weight: float = Field(default=1.0, ge=0.0, le=2.0)

    @model_validator(mode="before")
    @classmethod
    def validate_reference(cls, data: dict[str, Any]) -> dict[str, Any]:
        """Validate that at least one of url or code is provided."""
        if not data.get("url") and not data.get("code"):
            msg = "At least one of url or code must be provided"
            raise ValueError(msg)
        return data


class StyleReference(BaseModel):
    """Reference to a style."""

    url: HttpUrl | None = None
    code: str | None = None
    weight: float = Field(default=1.0, ge=0.0, le=2.0)

    @model_validator(mode="before")
    @classmethod
    def validate_reference(cls, data: dict[str, Any]) -> dict[str, Any]:
        """Validate that at least one of url or code is provided."""
        if not data.get("url") and not data.get("code"):
            msg = "At least one of url or code must be provided"
            raise ValueError(msg)
        return data


class MidjourneyParameters(BaseModel):
    """Parameters for a Midjourney prompt."""

    version: MidjourneyVersion | str | None = None
    style: StyleMode | None = None
    stylize: float = Field(default=100.0, ge=0.0, le=1000.0)
    chaos: float = Field(default=0.0, ge=0.0, le=100.0)
    weird: float = Field(default=0.0, ge=0.0, le=3000.0)
    seed: int | str | None = None
    aspect_width: int | None = None
    aspect_height: int | None = None
    aspect_ratio: str | None = None
    tile: bool = False
    turbo: bool = False
    relax: bool = False
    no: list[str] = Field(default_factory=list)
    character_reference: list[CharacterReference] = Field(default_factory=list)
    style_reference: list[StyleReference] = Field(default_factory=list)
    character_weight: float = Field(default=100.0, ge=0.0, le=200.0)
    style_weight: float | None = Field(default=None, ge=0.0, le=200.0)
    style_version: int = Field(default=2, ge=1, le=3)
    repeat: int | None = Field(default=None, ge=1, le=40)
    personalization: bool = False
    quality: float = Field(default=1.0, ge=0.25, le=2.0)
    negative_prompt: str | None = None
    extra_params: dict[str, Any] = Field(default_factory=dict)

    @field_validator("aspect_ratio")
    @classmethod
    def validate_aspect_ratio(cls, v: str | None) -> str | None:
        """Validate aspect ratio format."""
        if v is not None:
            try:
                parts = v.split(":")
                if len(parts) != 2:
                    msg = "Invalid aspect ratio format: must be width:height"
                    raise ValueError(msg)
                w, h = map(int, parts)
                if w <= 0 or h <= 0:
                    msg = "Invalid aspect ratio: values must be positive"
                    raise ValueError(msg)
                return f"{w}:{h}"
            except ValueError as e:
                msg = f"Invalid aspect ratio format: {e}"
                raise ValueError(msg)
        return v

    @field_validator("version")
    @classmethod
    def validate_version(
        cls, v: MidjourneyVersion | str | None
    ) -> MidjourneyVersion | str | None:
        """Validate version value."""
        if v is None:
            return None
        if isinstance(v, str) and v.lower() == "niji":
            return "niji"
        if isinstance(v, str):
            try:
                return MidjourneyVersion(v)
            except ValueError:
                msg = f"Invalid version value: {v}"
                raise ValueError(msg)
        return v

    @field_validator("seed")
    @classmethod
    def validate_seed(cls, v: int | str | None) -> int | str | None:
        """Validate seed value."""
        if v is None:
            return None
        if isinstance(v, str) and v.lower() in {"random", "none"}:
            return v.lower()
        if isinstance(v, int | str):
            try:
                return int(v)
            except ValueError:
                msg = f"Invalid seed value: {v}"
                raise ValueError(msg)
        return v

    @property
    def aspect(self) -> str | None:
        """Get the aspect ratio string."""
        if self.aspect_ratio:
            return self.aspect_ratio
        if self.aspect_width and self.aspect_height:
            return f"{self.aspect_width}:{self.aspect_height}"
        return None

    def to_string(self) -> str:
        """Convert parameters to string format."""
        parts = []

        # Handle version
        if self.version:
            parts.append(f"--v {self.version}")

        # Handle style
        if self.style:
            parts.append(f"--style {self.style.value}")

        # Handle numeric parameters
        if self.stylize != 100.0:
            parts.append(f"--s {self.stylize}")
        if self.chaos > 0:
            parts.append(f"--c {self.chaos}")
        if self.weird > 0:
            parts.append(f"--weird {self.weird}")
        if self.seed is not None:
            parts.append(f"--seed {self.seed}")

        # Handle aspect ratio
        if self.aspect:
            parts.append(f"--ar {self.aspect}")

        # Handle boolean flags
        if self.tile:
            parts.append("--tile")
        if self.turbo:
            parts.append("--turbo")
        if self.relax:
            parts.append("--relax")

        # Handle negative prompts
        if self.no:
            parts.append(f"--no {','.join(self.no)}")

        # Handle references
        if self.character_reference:
            for ref in self.character_reference:
                if ref.url:
                    parts.append(f"--cref {ref.url}")
                elif ref.code:
                    parts.append(f"--cref {ref.code}")
                if ref.weight != 1.0:
                    parts.append(f"--cw {ref.weight}")

        if self.style_reference:
            for ref in self.style_reference:
                if ref.url:
                    parts.append(f"--sref {ref.url}")
                elif ref.code:
                    parts.append(f"--sref {ref.code}")
                if ref.weight != 1.0:
                    parts.append(f"--sw {ref.weight}")

        # Handle other parameters
        if self.character_weight != 100.0:
            parts.append(f"--cw {self.character_weight}")
        if self.style_weight is not None:
            parts.append(f"--sw {self.style_weight}")
        if self.style_version != 2:
            parts.append(f"--sv {self.style_version}")
        if self.repeat is not None:
            parts.append(f"--r {self.repeat}")
        if self.personalization:
            parts.append("--p")
        if self.quality != 1.0:
            parts.append(f"--q {self.quality}")
        if self.negative_prompt:
            parts.append(f"--no {self.negative_prompt}")

        # Handle extra parameters
        for key, value in self.extra_params.items():
            if value is True:
                parts.append(f"--{key}")
            elif value is not False:
                parts.append(f"--{key} {value}")

        return " ".join(parts)


class MidjourneyPrompt(BaseModel):
    """A Midjourney prompt."""

    text: str
    image_prompts: list[ImageReference] = Field(default_factory=list)
    parameters: MidjourneyParameters = Field(default_factory=MidjourneyParameters)
    weight: float = Field(default=1.0, ge=0.0, le=2.0)

    def __str__(self) -> str:
        """Convert to string format."""
        parts = [self.text]

        # Add image prompts
        for img in self.image_prompts:
            parts.append(str(img))

        # Add parameters
        param_str = self.parameters.to_string()
        if param_str:
            parts.append(param_str)

        return " ".join(parts)

    def to_string(self) -> str:
        """Convert to string format."""
        return str(self)

    def model_dump(self, **kwargs: Any) -> dict[str, Any]:
        """Override model_dump to handle nested models correctly."""
        data = super().model_dump(**kwargs)
        if "parameters" in data:
            params = data["parameters"]
            data.update(params)
            del data["parameters"]
        return data

    # Property methods to expose parameters
    @property
    def version(self) -> MidjourneyVersion | str | None:
        """Get version parameter."""
        return self.parameters.version

    @property
    def style(self) -> StyleMode | None:
        """Get style parameter."""
        return self.parameters.style

    @property
    def stylize(self) -> float:
        """Get stylize parameter."""
        return self.parameters.stylize

    @property
    def chaos(self) -> float:
        """Get chaos parameter."""
        return self.parameters.chaos

    @property
    def weird(self) -> float:
        """Get weird parameter."""
        return self.parameters.weird

    @property
    def seed(self) -> int | str | None:
        """Get seed parameter."""
        return self.parameters.seed

    @property
    def aspect_width(self) -> int | None:
        """Get aspect width parameter."""
        return self.parameters.aspect_width

    @property
    def aspect_height(self) -> int | None:
        """Get aspect height parameter."""
        return self.parameters.aspect_height

    @property
    def aspect_ratio(self) -> str | None:
        """Get aspect ratio parameter."""
        return self.parameters.aspect_ratio

    @property
    def aspect(self) -> str | None:
        """Get aspect ratio string."""
        return self.parameters.aspect

    @property
    def tile(self) -> bool:
        """Get tile parameter."""
        return self.parameters.tile

    @property
    def turbo(self) -> bool:
        """Get turbo parameter."""
        return self.parameters.turbo

    @property
    def relax(self) -> bool:
        """Get relax parameter."""
        return self.parameters.relax

    @property
    def no(self) -> list[str]:
        """Get no parameter."""
        return self.parameters.no

    @property
    def character_reference(self) -> list[CharacterReference]:
        """Get character reference parameter."""
        return self.parameters.character_reference

    @property
    def style_reference(self) -> list[StyleReference]:
        """Get style reference parameter."""
        return self.parameters.style_reference

    @property
    def character_weight(self) -> float:
        """Get character weight parameter."""
        return self.parameters.character_weight

    @property
    def style_weight(self) -> float | None:
        """Get style weight parameter."""
        return self.parameters.style_weight

    @property
    def style_version(self) -> int:
        """Get style version parameter."""
        return self.parameters.style_version

    @property
    def repeat(self) -> int | None:
        """Get repeat parameter."""
        return self.parameters.repeat

    @property
    def personalization(self) -> bool:
        """Get personalization parameter."""
        return self.parameters.personalization

    @property
    def quality(self) -> float:
        """Get quality parameter."""
        return self.parameters.quality

    @property
    def negative_prompt(self) -> str | None:
        """Get negative prompt parameter."""
        return self.parameters.negative_prompt

    @property
    def extra_params(self) -> dict[str, Any]:
        """Get extra parameters."""
        return self.parameters.extra_params


class PromptVariant(BaseModel):
    """A variant of a prompt with weight."""

    prompt: MidjourneyPrompt
    weight: float = 1.0
</file>

<file path="src/midjargon/core/type_defs.py">
"""
type_defs.py

Defines type aliases for clarity in the midjargon package.
"""

# The raw input prompt as a string.
MidjargonInput = str

# A list of expanded prompt strings.
MidjargonList = list[str]

# A single expanded prompt string.
MidjargonPrompt = str

# The basic parsed output:
# - "images": list of image URLs (if any)
# - "text": core text prompt
# - All other parameters (keys without the '--' prefix)
MidjargonDict = dict[str, None | str | list[str]]
</file>

<file path="LOG.md">
---
this_file: LOG.md
---
# Implementation Log

## Current Status (2024-03-21)

### Immediate Focus

Starting work on Priority 0: Critical Model Fixes
1. Model validation issues discovered:
   -  Image reference validation fixed
     - Added proper URL validation
     - Fixed input type handling for image_prompts
   -  Parameter parsing improving
     -  Added proper parameter attribute access
     -  Fixed parameter validation rules
     -  Still issues with some parameter conversions
   -  Model validation issues
     -  Fixed missing attribute access
     -  Some validation rules still not working
2. Test suite status:
   -  17 tests passing
   -  74 tests failing
   - Major failure categories:
     - Parameter conversion
     - CLI implementation
     - Permutation handling
3. Next steps:
   - [ ] Fix remaining parameter conversion issues
   - [ ] Fix CLI implementation
   - [ ] Fix permutation handling

### Recent Changes

1. Model Implementation []
   -  Fixed model validator syntax
     - Updated to Pydantic v2 style
     - Fixed validator signatures
     - Added proper validation mode
   -  Added missing methods
     - Added to_string() method
     - Added property access
     - Fixed model_dump
   -  Fixed image reference handling
     - Added proper URL validation
     - Fixed input type handling
     - Added conversion from strings to HttpUrl
   -  Parameter handling improvements
     -  Added property access for all parameters
     -  Fixed parameter validation rules
     -  Still issues with some parameter conversions

2. Parser Implementation []
   -  Fixed image URL handling
     - Added proper URL validation
     - Added conversion to HttpUrl objects
     - Fixed input type handling
   -  Parameter extraction improved
     -  Added proper parameter mapping
     -  Fixed basic type conversion
     -  Still issues with some parameter types
   -  Model instantiation fixes
     -  Fixed basic parameter handling
     -  Still issues with complex parameters

3. Test Analysis []
   -  Ran full test suite
   -  Analyzed test failures
   -  Identified remaining issues:
     - Parameter conversion
     - CLI implementation
     - Permutation handling
   -  Updated fix plan

### Next Steps

1. Fix Parameter Conversion
   - Fix numeric parameter conversion
   - Fix flag parameter handling
   - Fix reference parameter parsing
   - Fix aspect ratio handling

2. Fix CLI Implementation
   - Fix JSON output formatting
   - Fix command implementations
   - Fix parameter handling
   - Fix output formatting

3. Fix Permutation Handling
   - Fix weighted prompt handling
   - Fix nested permutation groups
   - Fix whitespace handling
   - Fix escape character handling

### Remaining Issues

1. Parser Implementation []
   -  Image URL handling fixed
   -  Parameter extraction improving
   -  Model instantiation needs work

2. CLI Implementation []
   -  JSON output formatting
   -  Command implementations
   -  Parameter handling
   -  Output formatting

3. Test Suite []
   -  Identified failing tests
   -  Analyzed failure patterns
   -  74 tests still failing
   -  Updated fix plan for each category

### Dependencies Status []

All core dependencies are in place and working as expected:
- pydantic>=2.0.0
- rich>=13.0.0
- fire>=0.5.0
- python-box>=7.3.2
- fal-client>=0.5.8

### Development Guidelines Status

1. Type Safety []
   -  Fixed model validation syntax
   -  Fixed image reference validation
   -  Parameter validation improving
   - [ ] Planning remaining fixes

2. Code Quality []
   -  Fixed validator implementations
   -  Parser implementation improving
   -  CLI implementation needs work
   - [ ] Planning improvements

3. Testing []
   -  Test suite running
   -  Test failures analyzed
   -  74 tests failing
   -  Updated fix plan

4. Documentation []
   -  Updated model documentation
   -  CLI documentation incomplete
   -  Parameter documentation needed
   - [ ] Planning updates

## Notes

The focus has shifted from image reference validation to parameter conversion and CLI implementation. The image reference handling is now working correctly with proper URL validation and type conversion. Parameter handling has improved with proper attribute access and basic validation, but there are still issues with some parameter conversions and complex parameter handling. The next major focus will be on fixing the parameter conversion issues and the CLI implementation.
</file>

<file path="src/midjargon/engines/fal/__init__.py">
"""
Fal.ai engine for midjargon.
"""

from midjargon.engines.fal.converter import FalDict, to_fal_dict

__all__ = [
    "FalDict",
    "to_fal_dict",
]
</file>

<file path="src/midjargon/engines/__init__.py">
"""
Engine-specific parsers for midjargon.
"""

from midjargon.engines import fal
from midjargon.engines.midjourney import (MidjourneyPrompt,
                                          parse_midjourney_dict)

__all__ = [
    "MidjourneyPrompt",
    "fal",
    "parse_midjourney_dict",
]
</file>

<file path="tests/core/test_input.py">
"""Tests for input handling."""

from midjargon.core.input import expand_midjargon_input

# Test constants
PERMUTATION_COUNT_2 = 2  # Single permutation with 2 options
PERMUTATION_COUNT_3 = 3  # Single permutation with 3 options


def test_basic_input():
    """Test basic input without permutations."""
    result = expand_midjargon_input("a simple prompt")
    assert len(result) == 1
    assert result[0] == "a simple prompt"


def test_single_permutation():
    """Test input with a single permutation."""
    result = expand_midjargon_input("a {red, blue} bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red bird" in result
    assert "a blue bird" in result


def test_empty_input():
    """Test empty input handling."""
    result = expand_midjargon_input("")
    assert len(result) == 1
    assert result[0] == ""


def test_multiple_permutations():
    """Test input with multiple permutations."""
    result = expand_midjargon_input("a {red, blue, green} bird")
    assert len(result) == PERMUTATION_COUNT_3
    assert "a red bird" in result
    assert "a blue bird" in result
    assert "a green bird" in result


def test_nested_permutations():
    """Test input with nested permutations."""
    result = expand_midjargon_input("a {red {cat, dog}, blue bird}")
    assert len(result) == PERMUTATION_COUNT_3
    assert "a red cat" in result
    assert "a red dog" in result
    assert "a blue bird" in result


def test_escaped_braces():
    """Test input with escaped braces."""
    result = expand_midjargon_input(r"a \{red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"


def test_escaped_commas():
    """Test input with escaped commas."""
    result = expand_midjargon_input(r"a {red\, blue, green} bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red, blue bird" in result
    assert "a green bird" in result


def test_unmatched_braces():
    """Test input with unmatched braces."""
    result = expand_midjargon_input("a {red, blue bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue bird"


def test_empty_permutation():
    """Test input with empty permutation options."""
    result = expand_midjargon_input("a {} bird")
    assert len(result) == 1
    assert result[0] == "a bird"


def test_whitespace_handling():
    """Test input with various whitespace patterns."""
    result = expand_midjargon_input("a {  red  ,  blue  } bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red bird" in result
    assert "a blue bird" in result


def test_expand_midjargon_input():
    """Test expand_midjargon_input function to verify prompt expansion."""
    result = expand_midjargon_input("a {red, blue} bird")
    assert len(result) == 2
    assert "a red bird" in result
    assert "a blue bird" in result

    result = expand_midjargon_input("a {red, blue, green} bird")
    assert len(result) == 3
    assert "a red bird" in result
    assert "a blue bird" in result
    assert "a green bird" in result

    result = expand_midjargon_input("a {red {cat, dog}, blue bird}")
    assert len(result) == 3
    assert "a red cat" in result
    assert "a red dog" in result
    assert "a blue bird" in result


def test_handling_escaped_characters():
    """Test handling of escaped characters in expand_midjargon_input."""
    result = expand_midjargon_input(r"a \{red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"

    result = expand_midjargon_input(r"a {red\, blue, green} bird")
    assert len(result) == 2
    assert "a red, blue bird" in result
    assert "a green bird" in result

    result = expand_midjargon_input(r"a {red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"
</file>

<file path="src/midjargon/engines/midjourney/__init__.py">
"""
Midjourney engine for midjargon.
"""

from midjargon.engines.midjourney.midjourney import (MidjourneyParser,
                                                     MidjourneyPrompt,
                                                     parse_midjourney_dict)

# Create a default parser instance
_parser = MidjourneyParser()

# Export the parse_dict function from the default parser
parse_midjourney_dict = _parser.parse_dict

__all__ = [
    "ImagePrompt",
    "MidjourneyParser",
    "MidjourneyPrompt",
    "parse_midjourney_dict",
]
</file>

<file path="src/midjargon/engines/midjourney/constants.py">
"""
Constants for Midjourney engine.
"""

# Parameter ranges and constraints
STYLIZE_RANGE = (0, 1000)
CHAOS_RANGE = (0, 100)
WEIRD_RANGE = (0, 3000)
IMAGE_WEIGHT_RANGE = (0.0, 3.0)
SEED_RANGE = (0, 4294967295)
STOP_RANGE = (10, 100)

# New parameter ranges (lenient)
QUALITY_RANGE = (0.1, 2.0)  # More lenient than spec
CHARACTER_WEIGHT_RANGE = (0, 200)  # More lenient than spec
STYLE_WEIGHT_RANGE = (0, 2000)  # More lenient than spec
STYLE_VERSION_RANGE = (1, 10)  # More lenient than spec
REPEAT_RANGE = (1, 100)  # More lenient than spec

# Default values from SPEC.md
DEFAULT_STYLIZE = 100  # --s (stylize) default
DEFAULT_CHAOS = 0  # --chaos default
DEFAULT_WEIRD = 0  # --weird default
DEFAULT_IMAGE_WEIGHT = 1.0  # --iw default
DEFAULT_STOP = 100  # --stop default
DEFAULT_QUALITY = 1  # --quality default
DEFAULT_CHARACTER_WEIGHT = 100  # --cw default
DEFAULT_STYLE_VERSION = 2  # --sv default
DEFAULT_ASPECT_RATIO = "1:1"  # --ar default

# Boolean parameter defaults (all False by default)
DEFAULT_TILE = False  # --tile
DEFAULT_TURBO = False  # --turbo
DEFAULT_RELAX = False  # --relax

# File extensions
ALLOWED_IMAGE_EXTENSIONS = (".png", ".jpg", ".jpeg", ".gif", ".webp")

# Mode flags
VALID_STYLES = {"raw", "expressive", "cute", "scenic", "original"}  # Extensible
VALID_VERSIONS = {
    "1",
    "2",
    "3",
    "4",
    "5",
    "5.0",
    "5.1",
    "5.2",
    "6",
    "6.1",
}  # Extensible
VALID_NIJI_VERSIONS = {"4", "5", "6"}  # Extensible
</file>

<file path="src/midjargon/__main__.py">
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["fire", "rich", "pydantic"]
# ///

"""
Main entry point for midjargon CLI.
"""

from midjargon.cli import main

if __name__ == "__main__":
    main()
</file>

<file path="tests/engines/midjourney/test_midjourney_parser.py">
"""Tests for Midjourney parser."""

import pytest
from midjargon.engines.midjourney import MidjourneyParser
from pydantic import HttpUrl

if TYPE_CHECKING:
    from midjargon.core.type_defs import MidjargonDict

# Test constants
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
WEIRD_VALUE = 1000
SEED_VALUE = 12345
STOP_VALUE = 80
IMAGE_WEIGHT_VALUE = 2.0
VERSION_NUMBER = "5.2"
DEFAULT_STYLIZE = 100
QUALITY_VALUE = 1.5
CHARACTER_WEIGHT_VALUE = 50
STYLE_WEIGHT_VALUE = 500
STYLE_VERSION_VALUE = 3
REPEAT_VALUE = 5


def test_numeric_parameters():
    """Test parsing of numeric parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "stylize": str(STYLIZE_VALUE),
            "seed": str(SEED_VALUE),
            "chaos": str(CHAOS_VALUE),
        }
    )

    assert prompt.text == "a photo"
    assert prompt.stylize == STYLIZE_VALUE
    assert prompt.seed == SEED_VALUE
    assert prompt.chaos == CHAOS_VALUE


def test_style_parameters():
    """Test parsing of style parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict({"text": "a photo", "style": "raw", "v": VERSION_NUMBER})

    assert prompt.text == "a photo"
    assert prompt.style == "raw"
    assert prompt.version == f"v{VERSION_NUMBER}"


def test_aspect_ratio():
    """Test parsing of aspect ratio."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict({"text": "a photo", "aspect": "16:9"})

    assert prompt.text == "a photo"
    assert prompt.aspect_width == 16
    assert prompt.aspect_height == 9


def test_image_prompts():
    """Test parsing of image prompts."""
    parser = MidjourneyParser()
    urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = parser.parse_dict({"text": "a fusion", "images": urls})

    assert prompt.text == "a fusion"
    assert len(prompt.image_prompts) == 2
    assert [p.url for p in prompt.image_prompts] == urls


def test_extra_parameters():
    """Test handling of unknown parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "unknown": "value",
            "flag": None,
        }
    )

    assert prompt.text == "a photo"
    assert prompt.extra_params == {"unknown": "value", "flag": None}


def test_parameter_conversion():
    """Test parameter value conversion."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "stylize": str(STYLIZE_VALUE),
            "seed": str(SEED_VALUE),
            "iw": str(IMAGE_WEIGHT_VALUE),
        }
    )

    assert prompt.text == "a photo"
    assert prompt.stylize == STYLIZE_VALUE
    assert prompt.seed == SEED_VALUE
    assert prompt.image_weight == IMAGE_WEIGHT_VALUE


def test_invalid_values():
    """Test handling of invalid parameter values."""
    parser = MidjourneyParser()

    # Invalid aspect ratio - now accepts any value
    result = parser.parse_dict({"text": "a photo", "aspect": "999:999"})
    assert result.aspect_width == 999
    assert result.aspect_height == 999

    # Invalid numeric value - raises ValueError
    with pytest.raises(ValueError, match=r"Invalid numeric value for stylize: 1001"):
        parser.parse_dict({"text": "a photo", "stylize": "1001"})

    # Invalid image URL - treated as extra parameter
    result = parser.parse_dict({"text": "a photo", "image": "not_a_url"})
    assert len(result.image_prompts) == 0
    assert result.extra_params.get("image") == "not_a_url"


def test_parameter_ranges():
    """Test parameter value range validation."""
    parser = MidjourneyParser()

    # Test maximum values
    with pytest.raises(ValueError, match=r"Invalid numeric value for stylize: 2000"):
        parser.parse_dict({"text": "a photo", "stylize": "2000"})

    # Test minimum values
    with pytest.raises(ValueError, match=r"Invalid numeric value for chaos: -1"):
        parser.parse_dict({"text": "a photo", "chaos": "-1"})


def test_empty_values():
    """Test handling of empty values."""
    parser = MidjourneyParser()

    # Empty text
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": ""})

    # Empty image list
    prompt = parser.parse_dict({"text": "a photo", "images": []})
    assert prompt.text == "a photo"
    assert not prompt.image_prompts

    # None values
    prompt = parser.parse_dict({"text": "a photo", "stylize": None})
    assert prompt.text == "a photo"
    assert prompt.stylize is None


def test_niji_parameter():
    """Test parsing of niji parameter."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "niji": "6",
        }
    )

    assert prompt.text == "a photo"
    assert prompt.version == "niji 6"


def test_multiple_permutations():
    """Test handling of multiple permutations."""
    parser = MidjourneyParser()

    # Test with parameter permutations
    input_dicts = [
        {"text": "smooth edges", "stylize": "75"},
        {"text": "smooth edges", "stylize": "300"},
        {"text": "smooth edges", "stylize": "75", "personalization": None},
        {"text": "smooth edges", "stylize": "300", "personalization": None},
    ]

    results = [parser.parse_dict(d) for d in input_dicts]
    assert len(results) == 4

    # Verify each permutation is handled correctly
    result_tuples = {(r.text.strip(), r.stylize, r.personalization) for r in results}

    expected = {
        ("smooth edges", 75, False),
        ("smooth edges", 300, False),
        ("smooth edges", 75, True),
        ("smooth edges", 300, True),
    }

    assert result_tuples == expected

    # Test with flag permutations
    input_dicts = [
        {"text": "photo"},
        {"text": "photo", "tile": None},
        {"text": "photo", "turbo": None},
        {"text": "photo", "tile": None, "turbo": None},
    ]

    results = [parser.parse_dict(d) for d in input_dicts]
    assert len(results) == 4

    # Verify each permutation is handled correctly
    result_tuples = {(r.text.strip(), r.tile is True, r.turbo is True) for r in results}

    expected = {
        ("photo", False, False),
        ("photo", True, False),
        ("photo", False, True),
        ("photo", True, True),
    }

    assert result_tuples == expected


def test_personalization_parameter():
    """Test parsing of personalization parameter."""
    parser = MidjourneyParser()

    # Test flag without value - should be True
    prompt = parser.parse_dict({"text": "a photo", "p": None})
    assert prompt.personalization is True

    # Test flag with empty string - should be True
    prompt = parser.parse_dict({"text": "a photo", "p": ""})
    assert prompt.personalization is True

    # Test with string value - should be list with one item
    prompt = parser.parse_dict({"text": "a photo", "p": "custom"})
    assert prompt.personalization == ["custom"]

    # Test with list value - should keep list
    prompt = parser.parse_dict({"text": "a photo", "p": ["custom1", "custom2"]})
    assert prompt.personalization == ["custom1", "custom2"]

    # Test with empty list - should be False
    prompt = parser.parse_dict({"text": "a photo", "p": []})
    assert prompt.personalization is False

    # Test without personalization - should be False
    prompt = parser.parse_dict({"text": "a photo"})
    assert prompt.personalization is False


def test_complex_permutations():
    """Test handling of complex parameter permutations."""
    parser = MidjourneyParser()

    # Test with multiple parameter types
    input_dicts: list[MidjargonDict] = [
        {
            "text": "portrait modern",
            "aspect": "1:1",
            "stylize": "100",
            "images": [],
        },
        {
            "text": "portrait modern",
            "aspect": "16:9",
            "stylize": "100",
            "images": [],
        },
        {
            "text": "portrait modern",
            "aspect": "1:1",
            "stylize": "100",
            "personalization": "custom",
            "images": [],
        },
        {
            "text": "portrait modern",
            "aspect": "16:9",
            "stylize": "100",
            "personalization": "custom",
            "images": [],
        },
        {
            "text": "portrait vintage",
            "aspect": "1:1",
            "stylize": "100",
            "images": [],
        },
        {
            "text": "portrait vintage",
            "aspect": "16:9",
            "stylize": "100",
            "images": [],
        },
        {
            "text": "portrait vintage",
            "aspect": "1:1",
            "stylize": "100",
            "personalization": "custom",
            "images": [],
        },
        {
            "text": "portrait vintage",
            "aspect": "16:9",
            "stylize": "100",
            "personalization": "custom",
            "images": [],
        },
    ]

    results = [parser.parse_dict(d) for d in input_dicts]
    assert len(results) == 8

    # Verify each permutation is handled correctly
    result_tuples = {
        (
            r.text.strip(),
            r.personalization[0]
            if isinstance(r.personalization, list)
            else r.personalization,
            f"{r.aspect_width}:{r.aspect_height}",
            r.stylize,
        )
        for r in results
    }

    expected = {
        ("portrait modern", False, "1:1", 100),
        ("portrait modern", False, "16:9", 100),
        ("portrait modern", "custom", "1:1", 100),
        ("portrait modern", "custom", "16:9", 100),
        ("portrait vintage", False, "1:1", 100),
        ("portrait vintage", False, "16:9", 100),
        ("portrait vintage", "custom", "1:1", 100),
        ("portrait vintage", "custom", "16:9", 100),
    }

    assert result_tuples == expected


def test_new_parameters():
    """Test parsing of new parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "quality": str(QUALITY_VALUE),
            "character_weight": str(CHARACTER_WEIGHT_VALUE),
            "style_weight": str(STYLE_WEIGHT_VALUE),
            "style_version": str(STYLE_VERSION_VALUE),
            "repeat": str(REPEAT_VALUE),
        }
    )

    assert prompt.text == "a photo"
    assert prompt.quality == QUALITY_VALUE
    assert prompt.character_weight == CHARACTER_WEIGHT_VALUE
    assert prompt.style_weight == STYLE_WEIGHT_VALUE
    assert prompt.style_version == STYLE_VERSION_VALUE
    assert prompt.repeat == REPEAT_VALUE


def test_new_parameter_validation():
    """Test validation of new parameters."""
    parser = MidjourneyParser()

    # Test invalid quality value
    with pytest.raises(ValueError, match=r"Invalid numeric value for quality: 5"):
        parser.parse_dict({"text": "a photo", "quality": "5"})

    # Test invalid character weight value
    with pytest.raises(
        ValueError, match=r"Invalid numeric value for character_weight: 2000"
    ):
        parser.parse_dict({"text": "a photo", "character_weight": "2000"})

    # Test invalid style weight value
    with pytest.raises(
        ValueError, match=r"Invalid numeric value for style_weight: 5000"
    ):
        parser.parse_dict({"text": "a photo", "style_weight": "5000"})

    # Test invalid style version value
    with pytest.raises(
        ValueError, match=r"Invalid numeric value for style_version: 20"
    ):
        parser.parse_dict({"text": "a photo", "style_version": "20"})

    # Test invalid repeat value
    with pytest.raises(ValueError, match=r"Invalid numeric value for repeat: 200"):
        parser.parse_dict({"text": "a photo", "repeat": "200"})


def test_edge_cases():
    """Test handling of edge cases in Midjourney parser."""
    parser = MidjourneyParser()

    # Test empty prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": ""})

    # Test prompt with only spaces
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": "   "})

    # Test prompt with special characters
    prompt = parser.parse_dict({"text": "a photo with special characters !@#$%^&*()"})
    assert prompt.text == "a photo with special characters !@#$%^&*()"

    # Test prompt with long text
    long_text = "a" * 1000
    prompt = parser.parse_dict({"text": long_text})
    assert prompt.text == long_text

    # Test prompt with mixed types in extra parameters - all should be converted to strings
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "extra1": "123",
            "extra2": "45.67",
            "extra3": "true",
            "extra4": None,
            "extra5": "item1",  # Changed from list to string
        }
    )
    assert prompt.extra_params["extra1"] == "123"
    assert prompt.extra_params["extra2"] == "45.67"
    assert prompt.extra_params["extra3"] == "true"
    assert prompt.extra_params["extra4"] is None
    assert prompt.extra_params["extra5"] == "item1"
</file>

<file path="src/midjargon/engines/base.py">
"""
midjargon.engines.base
~~~~~~~~~~~~~~~~~~~

Base engine interface for midjargon.

This module provides the abstract base class that all engine parsers must implement.
Engine parsers are responsible for converting between the generic MidjargonDict format
and engine-specific prompt types.
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, Any, Generic, TypeVar

from pydantic import BaseModel

if TYPE_CHECKING:
    from midjargon.core.type_defs import MidjargonDict

# Type variable for engine-specific prompt type, must be a Pydantic model
T = TypeVar("T", bound=BaseModel)


class EngineParser(ABC, Generic[T]):
    """
    Base class for engine-specific parsers.

    Each engine parser is responsible for:
    1. Converting MidjargonDict to engine-specific prompt types
    2. Validating parameters according to engine rules
    3. Converting engine-specific prompts back to dictionaries

    Type Parameters:
        T: The engine-specific prompt type (must be a Pydantic model)
    """

    @abstractmethod
    def parse_dict(self, midjargon_dict: MidjargonDict) -> T:
        """
        Parse a MidjargonDict into a validated BasePrompt.

        Args:
            midjargon_dict: Dictionary from basic parser or a raw prompt string.

        Returns:
            Validated BasePrompt.

        Raises:
            ValueError: If the prompt text is empty or if validation fails.
        """
        if not isinstance(midjargon_dict, dict):
            midjargon_dict = {"text": str(midjargon_dict)}

        if not midjargon_dict:
            msg = "Empty prompt"
            raise ValueError(msg)

        text_value = midjargon_dict.get("text")
        if text_value is None:
            msg = "Empty prompt"
            raise ValueError(msg)

        text = (
            (text_value[0] if text_value else "")
            if isinstance(text_value, list)
            else str(text_value)
        )

        if not text.strip():
            msg = "Empty prompt"
            raise ValueError(msg)

        return self._parse_dict(midjargon_dict)

    @abstractmethod
    def _parse_dict(self, midjargon_dict: MidjargonDict) -> T:
        """
        Internal method to parse dictionary into model.
        Should be implemented by subclasses.
        """
        msg = "Not implemented"
        raise NotImplementedError(msg)

    @abstractmethod
    def to_dict(self, prompt: T) -> dict[str, Any]:
        """
        Convert a prompt model back to a dictionary.
        Should be implemented by subclasses.
        """
        msg = "Not implemented"
        raise NotImplementedError(msg)

    def validate(self, prompt: T) -> bool:
        """
        Validate an engine-specific prompt.

        By default, this uses Pydantic validation. Override this method
        to implement additional engine-specific validation rules.

        Args:
            prompt: Engine-specific prompt to validate.

        Returns:
            True if the prompt is valid, False otherwise.

        Raises:
            ValueError: If validation fails with specific error messages.
        """
        # Basic Pydantic validation
        prompt.model_validate(prompt.model_dump())
        return True
</file>

<file path="README.md">
# Midjargon

**Midjargon** is a powerful Python library and command-line interface (CLI) tool meticulously designed to parse, manipulate, and convert [Midjourney](https://www.midjourney.com)-style prompts.

Midjourney utilizes a unique and expressive syntax for its prompts, which we refer to as "midjargon." This syntax includes features like permutation using `{}` (e.g., `a {red,blue} cat`) and parameter specification with an `--` prefix (e.g., `--ar 16:9`). While native to Midjourney, this versatile syntax is also beneficial for other applications, such as constructing prompts for different generative AI models.

The `midjargon` package robustly deconstructs these prompts into manageable, structured components, ensuring type-safe operations and comprehensive validation. It excels at expanding permutations, handling complex parameter rules, and converting midjargon prompts into other formats, such as those used by [Fal.ai](https://fal.ai/), as well as serializing them back into the standard Midjourney format.

## Who is Midjargon for?

*   **Midjourney Users:** Anyone who frequently crafts and experiments with Midjourney prompts and wants a better way to manage, generate variations, or understand their structure.
*   **Developers & AI Engineers:** Programmers looking to integrate Midjourney prompt parsing and manipulation into their Python applications, workflows, or custom tools.
*   **Content Creators & Prompt Engineers:** Individuals who need to convert prompts between different AI image generation services or require a systematic way to explore vast prompt spaces.

## Why use Midjargon?

*   **Robust Parsing:** Accurately deconstructs complex Midjourney prompts into their fundamental components: text, image URLs, parameters, and weights.
*   **Advanced Permutation Engine:** Automatically expands all possible prompt combinations from permutation syntax (`{option1, option2}`), including support for nested permutations and escaped characters.
*   **Comprehensive Parameter Handling:** Validates parameter names and their values according to Midjourney rules, supporting numeric ranges, type conversions, boolean flags, and multi-value parameters.
*   **Image URL Processing:** Extracts and validates image URLs, supporting multiple image inputs and common file extensions.
*   **Multi-Prompt & Weighting Support:** Correctly interprets and processes prompts with multiple weighted segments (e.g., `text1 ::1 text2 ::0.5`).
*   **Type Safety:** Built with full type hints and Pydantic models for robust data validation and improved developer experience.
*   **Versatile CLI Tool:** Offers a user-friendly command-line interface for quick parsing, permutation, and conversion tasks, with JSON output for easy automation.
*   **Format Conversion:** Supports conversion of Midjourney prompts to other formats like Fal.ai and can serialize processed prompts back to the Midjourney format.

## Installation

You can install Midjargon using pip:

```bash
pip install midjargon
```
Or, if you use `uv`:
```bash
uv pip install midjargon
```

## How to Use Midjargon

Midjargon can be used both as a command-line tool and as a Python library.

### Command-Line Interface (CLI) Usage

The `midjargon` CLI provides several commands to work with your prompts. You can run it directly, via `python -m midjargon`, or even with `uv run midjargon --` followed by the command arguments if you prefer not to install it globally.

**Basic Invocation:**

```bash
midjargon --help  # Shows all available commands
python -m midjargon --help
```

**Main Commands:**

*   **`perm`**: Expands all permutations in a prompt.
    ```bash
    midjargon perm "A {red, blue} cat sitting on a {mat, rug} --mood {happy, sleepy}"
    ```

*   **`json`**: Parses a prompt and outputs its structured representation in JSON format. This is useful for understanding the prompt's components or for programmatic use. By default, it permutes the prompt first.
    ```bash
    midjargon json "A futuristic cityscape --ar 16:9 --v 6 --style raw"
    ```

*   **`mj`**: Converts a prompt (potentially with non-standard syntax or after manipulation) back into one or more valid Midjourney prompt strings.
    ```bash
    midjargon mj "A detailed portrait --ar 1:1 --stylize 250"
    ```

*   **`fal`**: Converts a Midjourney prompt into the format expected by Fal.ai.
    ```bash
    midjargon fal "photo of a robot --ar 1:1 --seed 123"
    ```

**Getting Help for Specific Commands:**

For detailed options for each command, use `--help`:

```bash
midjargon perm --help
midjargon json --help
midjargon mj --help
midjargon fal --help
```

### Programmatic Usage (Python Library)

Integrate `midjargon` into your Python projects to leverage its parsing and manipulation capabilities.

**Key Functions from `midjargon.core.converter`:**

*   `permute_prompt(text: str) -> list[str]`: Expands permutations.
*   `parse_prompt(text: str, permute: bool = True) -> MidjargonDict | list[MidjargonDict]`: Parses to generic dictionaries.
*   `to_midjourney_prompts(prompt_input) -> MidjourneyPrompt | list[MidjourneyPrompt]`: Parses and validates into `MidjourneyPrompt` Pydantic models.
*   `to_fal_dicts(prompt_input) -> FalDict | list[FalDict]`: Converts to Fal.ai dictionaries.

**Basic Example (Parsing and Validating for Midjourney):**

```python
from midjargon.core.converter import to_midjourney_prompts
from midjargon.engines.midjourney.models import MidjourneyPrompt # Pydantic model
# Assuming MidjourneyParser might be needed for string reconstruction
# from midjargon.engines.midjourney.parser import MidjourneyParser


prompt_string = "A {cyberpunk, steampunk} city --ar 16:9 --chaos {10, 20}"

# to_midjourney_prompts handles permutation and parsing
results = to_midjourney_prompts(prompt_string)

# Results will be a list if there were permutations
if isinstance(results, list):
    for i, mj_prompt_model in enumerate(results):
        print(f"--- Variant {i+1} ---")
        # mj_prompt_model is a MidjourneyPrompt Pydantic object
        print(f"Text: {mj_prompt_model.text}")
        print(f"Aspect Ratio: {mj_prompt_model.aspect_ratio}")
        print(f"Chaos: {mj_prompt_model.chaos}")
        # print(f"Full Model: {mj_prompt_model.model_dump_json(indent=2)}")

        # To convert back to a string, you'd typically use the parser:
        # Example: reconstructed_string = MidjourneyParser().to_prompt_string(mj_prompt_model)
        # print(f"Reconstructed String: {reconstructed_string}")
elif isinstance(results, MidjourneyPrompt):
    # Single result (no permutations or input was already specific)
    print(f"Text: {results.text}")
    # ... and so on
    # Example: reconstructed_string = MidjourneyParser().to_prompt_string(results)
    # print(f"Reconstructed String: {reconstructed_string}")
else:
    print("Unexpected result type")


# For simpler parsing to a generic dictionary without Midjourney-specific validation:
from midjargon.core.converter import parse_prompt
# parse_prompt by default permutes and returns a list of dicts
parsed_dicts = parse_prompt("A simple prompt --param value")

if parsed_dicts: # It will be a list
    print(f"\nGeneric parsed dict example: {parsed_dicts[0]}")

```
*Self-correction: The `MidjourneyPrompt` model itself doesn't have a `to_prompt_string()` method directly. This functionality is part of the `MidjourneyParser`. The example above has been commented to reflect this.*

This provides a glimpse into `midjargon`'s capabilities. For more advanced scenarios, explore the functions and classes within the `midjargon.core` and `midjargon.engines` modules.

## Technical Deep Dive

This section provides a more detailed look into how `midjargon` works internally and outlines guidelines for contributing to the project.

### How Midjargon Works

The `midjargon` library processes prompts in several stages:

1.  **Input Permutation (`midjargon.core.input`, `midjargon.core.permutations`):**
    *   The initial raw prompt string is first processed by the permutation engine (`expand_permutations` in `midjargon.core.permutations`).
    *   This engine identifies permutation groups denoted by curly braces `{option1, option2, ...}`.
    *   It supports nested permutations (e.g., `{a, {b, c}}`) and escaped characters (`\,`, `\{`, `\}`) to allow literal commas and braces within permutations.
    *   The `permute_prompt` function in `midjargon.core.converter` (which uses `expand_midjargon_input` from `midjargon.core.input`) generates a list of all possible prompt strings.

2.  **Core Parsing (`midjargon.core.parser`):**
    *   Each expanded prompt string is then passed to the core parser (`parse_midjargon_prompt_to_dict` in `midjargon.core.parser`).
    *   This parser's primary role is to dissect the string into a structured `MidjargonDict` (a Python dictionary).
    *   **Image URL Extraction:** It first identifies and extracts any image URLs at the beginning of the prompt.
    *   **Text and Parameter Separation:** The remaining string is split into the main textual part of the prompt and the parameter part (which starts with `--`).
    *   **Parameter Parsing (`midjargon.core.parameters`):** The `parse_parameters` function from `midjargon.core.parameters` breaks down the parameter string.
        *   It splits parameters based on the `--` prefix.
        *   It distinguishes parameter names from their values.
        *   It handles boolean flags and normalizes parameter names using aliases.

3.  **Type-Safe Modeling and Engine-Specific Validation (`midjargon.engines`):**
    *   The `MidjargonDict` is a generic representation. For engine-specific interpretation (like Midjourney), this dictionary is processed by an engine parser.
    *   **Pydantic Models:** Each engine (e.g., `midjargon.engines.midjourney`) has its own Pydantic models (e.g., `MidjourneyPrompt` in `midjargon.engines.midjourney.models`). These define structure, data types, and validation rules.
    *   **Engine Parser (`midjargon.engines.base.EngineParser`):**
        *   The `MidjourneyParser` (from `midjargon.engines.midjourney.parser`) takes the `MidjargonDict`.
        *   Its `parse_from_dict` method converts raw values into the strongly-typed fields of its Pydantic model (`MidjourneyPrompt`), involving type conversion, validation against constraints (numeric ranges, enums), and applying defaults.
        *   The `MidjourneyPrompt` model itself (in `midjargon.engines.midjourney.models.py`) uses Pydantic's `@field_validator` and `@model_validator` for these rules, referencing constants from `midjargon.engines.midjourney.constants.py`.

4.  **Conversion and Serialization (`midjargon.core.converter`, `midjargon.engines`):**
    *   The `midjargon.core.converter` module provides high-level functions like `to_midjourney_prompts` and `to_fal_dicts`.
    *   These functions orchestrate permutation, parsing, and engine-specific validation.
    *   **To Midjourney String:** The validated `MidjourneyPrompt` model can be serialized back into a compliant Midjourney prompt string by the `MidjourneyParser`'s `to_prompt_string(model)` method.
    *   **To Fal.ai Dictionary:** The `FalParser` in `midjargon.engines.fal.converter` converts a `MidjargonDict` into a `FalDict` suitable for the Fal.ai API.

5.  **Command-Line Interface (`midjargon.cli.main`):**
    *   The CLI is built using the `fire` library.
    *   The `MidjargonCLI` class in `src/midjargon/cli/main.py` defines commands (`perm`, `json`, `mj`, `fal`).
    *   These CLI commands call the respective functions from `midjargon.core.converter` to perform operations and format the output (Rich console output or JSON).

### Midjourney Prompt Syntax Reference

For a comprehensive understanding of the Midjourney prompt syntax that `midjargon` is designed to parse, including all parameters, their value types, ranges, and advanced features like multi-prompts, permutation syntax, and various reference types (`--cref`, `--sref`), please consult the **[Midjourney Prompt Format Specification](docs/specification.md)**.

### Project Structure

```
.
 LICENSE                    # MIT license
 README.md                  # Project introduction and documentation
 docs                       # Project documentation
    specification.md        # Detailed midjargon prompt syntax specification
    ...                    # Other docs
 pyproject.toml             # Python project configuration (PEP 518, PEP 621)
 src                        # Source code
    midjargon
        __init__.py
        __main__.py        # Main CLI entry point
        cli                # Command-Line Interface logic
           main.py        # CLI command definitions using Fire
        core               # Core parsing, permutation, and conversion logic
           converter.py     # High-level functions for prompt conversion
           input.py         # Input processing, permutation expansion entry
           models.py        # Core Pydantic models (e.g., PromptVariant)
           parameters.py    # Parsing and validation of parameters
           parser.py        # Basic prompt string parsing into MidjargonDict
           permutations.py  # Permutation expansion logic
           type_defs.py     # Core type definitions (MidjargonInput, MidjargonDict)
        engines            # Engine-specific parsers and models
            base.py          # Abstract base class for engine parsers
            fal              # Fal.ai engine implementation
            midjourney       # Midjourney engine implementation
                constants.py   # Parameter constraints, defaults for Midjourney
                models.py      # Pydantic models for validated Midjourney prompts
                parser.py      # Midjourney-specific parsing logic (MidjourneyParser)
 tests                      # Test suite for midjargon
    # ... (test structure mirrors src structure)
```
*(Other files like `package.toml`, `TODO.md` exist but are omitted for brevity in this view).*

### Coding and Contribution Guidelines

We welcome contributions to `midjargon`! Please follow these guidelines:

*   **Development Setup:**
    1.  Clone the repository:
        ```bash
        git clone https://github.com/twardoch/midjargon.git
        cd midjargon
        ```
    2.  It's recommended to use a virtual environment. If you use `uv` (as indicated by `uv.lock` and `pyproject.toml`):
        ```bash
        uv venv  # Create a virtual environment (e.g., .venv)
        uv pip install -e ".[all]" # Install in editable mode with all extras
        ```
        Alternatively, with standard `pip` and `venv`:
        ```bash
        python -m venv .venv
        source .venv/bin/activate  # On Windows: .venv\Scripts\activate
        pip install -e ".[all]"
        ```
    3.  The project uses `hatch` for task management (testing, linting), configured in `pyproject.toml`. Ensure `hatch` is installed (`pip install hatch` or `uv pip install hatch`).

*   **Running Tests:**
    Execute tests using `hatch`:
    ```bash
    hatch test
    ```
    This will run all tests defined in the `tests` directory. New features or bug fixes must include corresponding tests.

*   **Code Formatting and Linting:**
    The project uses `Ruff` for formatting and linting. Configuration is in `pyproject.toml`.
    To format and lint your code via `hatch` (recommended):
    ```bash
    hatch run lint:all  # Runs ruff format and ruff check
    # Or individually:
    hatch run lint:fmt  # Formats and auto-fixes where possible
    hatch run lint:style # Checks for style issues
    ```
    Please ensure your code passes linting before submitting a pull request.

*   **Type Checking:**
    `midjargon` uses `mypy` for static type checking. Configuration is in `pyproject.toml`.
    To run type checks via `hatch`:
    ```bash
    hatch run lint:typing
    ```
    Code must be fully type-hinted and pass type checking.

*   **Commit Messages:**
    Follow conventional commit message standards (e.g., `feat: add new parameter support`, `fix: resolve parsing bug for nested permutations`).

*   **Pull Requests:**
    *   Submit pull requests to the main development branch.
    *   Ensure your PR includes:
        *   A clear description of the changes.
        *   Passing tests (including new tests for your changes).
        *   Passing linter and type checks.
        *   Updates to documentation (README, `docs/specification.md`) if your changes affect user-facing features or the prompt syntax.

*   **Code Style:**
    *   Follow PEP 8 guidelines, enforced by Ruff.
    *   Prioritize clarity and readability.
    *   Use the type hinting system extensively.
    *   Pydantic models are central to data validation and structuring.

### Licensing

`midjargon` is licensed under the MIT License. See the [LICENSE](LICENSE) file for details.
</file>

<file path="src/midjargon/engines/midjourney/parser/core.py">
"""
Core parser implementation for Midjourney engine.
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

from midjargon.engines.base import EngineParser
from midjargon.engines.midjourney.models import ImagePrompt, MidjourneyPrompt
from midjargon.engines.midjourney.parser.exceptions import \
    ParameterValidationError
from midjargon.engines.midjourney.parser.parameters import ParameterHandler

if TYPE_CHECKING:
    from midjargon.core.type_defs import MidjargonDict


class MidjourneyParser(EngineParser[MidjourneyPrompt]):
    """Parser for Midjourney prompts."""

    def __init__(self) -> None:
        """Initialize parser."""
        self.param_handler = ParameterHandler()

    def _init_prompt_data(self) -> dict[str, Any]:
        """Initialize prompt data with default values."""
        return {
            "text": "",
            "image_prompts": [],
            "stylize": 100,
            "chaos": 0,
            "weird": 0,
            "image_weight": 1.0,
            "seed": None,
            "stop": 100,
            "aspect_width": 1,
            "aspect_height": 1,
            "aspect_ratio": "1:1",
            "style": None,
            "version": None,
            "personalization": False,
            "quality": 1.0,
            "character_reference": [],
            "character_weight": 100,
            "style_reference": [],
            "style_weight": None,
            "style_version": 2,
            "repeat": None,
            "turbo": False,
            "relax": False,
            "tile": False,
            "negative_prompt": None,
            "extra_params": {},
        }

    def _process_text_and_images(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Process text and image components of the prompt."""
        # Process text
        text = midjargon_dict.get("text", "")
        if text is None:
            text = ""
        if isinstance(text, list):
            text = text[0] if text else ""
        if not isinstance(text, str):
            text = str(text)
        text = text.strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
        prompt_data["text"] = text

        # Process images
        images = midjargon_dict.get("images", [])
        if not isinstance(images, list):
            images = [str(images)] if images else []
        prompt_data["image_prompts"] = [ImagePrompt(url=str(url)) for url in images]

    def _process_aspect_ratio(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Process aspect ratio parameters."""
        # Check both 'ar' and 'aspect' parameters
        value = midjargon_dict.get("ar") or midjargon_dict.get("aspect")
        if value is None:
            return

        if isinstance(value, list):
            value = value[0] if value else None
            if value is None:
                return

        # Handle value with additional parameters
        value_str = str(value)
        value_parts = value_str.split("--")
        aspect_value = value_parts[0].strip()

        try:
            width_str, height_str = aspect_value.split(":")
            width = int(width_str.strip())
            height = int(height_str.strip())
        except (ValueError, AttributeError) as e:
            msg = f"Invalid aspect ratio format: {aspect_value} - must be width:height"
            raise ValueError(msg) from e

        if width <= 0 or height <= 0:
            msg = f"Invalid aspect ratio: {aspect_value} - values must be positive"
            raise ValueError(msg)

        # Store both formats
        prompt_data["aspect_width"] = width
        prompt_data["aspect_height"] = height
        prompt_data["aspect_ratio"] = f"{width}:{height}"

        # Store decomposed values in extra_params for reference
        if "extra_params" not in prompt_data:
            prompt_data["extra_params"] = {}
        prompt_data["extra_params"]["aspect_width"] = str(width)
        prompt_data["extra_params"]["aspect_height"] = str(height)

    def _process_version(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Process version parameter."""
        for name in ("niji", "version", "v"):
            if name not in midjargon_dict:
                continue

            value = midjargon_dict[name]
            if value is None:
                if name == "niji":
                    prompt_data["version"] = "niji"
                    return
                continue

            # If the key is 'niji', process accordingly
            if name == "niji":
                if isinstance(value, list):
                    value = value[0]
                stripped_value = value.strip()
                if stripped_value == "niji":
                    prompt_data["version"] = "niji"
                else:
                    prompt_data["version"] = f"niji {stripped_value}"
                return

            # For other keys, process as usual
            processed_value = self.param_handler.process(name, value)
            if processed_value is not None:
                # If the processed value starts with 'niji', assign directly, else add 'v' prefix
                if isinstance(
                    processed_value, str
                ) and processed_value.lstrip().lower().startswith("niji"):
                    prompt_data["version"] = processed_value.strip()
                else:
                    prompt_data["version"] = f"v{processed_value}"
                return

    def _process_style(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Process style parameter."""
        if "style" in midjargon_dict:
            value = midjargon_dict["style"]
            if value is not None:
                if isinstance(value, list):
                    value = value[0] if value else None
                if value is not None:
                    prompt_data["style"] = str(value)

    def _process_personalization(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Handle personalization parameter."""
        # Check for both 'p' and 'personalization' keys
        p_value = midjargon_dict.get("p")
        personalization = midjargon_dict.get("personalization")

        # If both are present, personalization takes precedence
        value = personalization if personalization is not None else p_value

        # If no personalization parameter is present, set to False
        if (
            value is None
            and "p" not in midjargon_dict
            and "personalization" not in midjargon_dict
        ):
            prompt_data["personalization"] = False
            return

        # Handle flag-only case (when key exists but value is None or empty string)
        if value is None or value == "":
            prompt_data["personalization"] = True
            return

        # Handle empty list case
        if isinstance(value, list) and not value:
            prompt_data["personalization"] = False
            return

        # Handle list values
        if isinstance(value, list):
            # If list has one empty string, treat as flag
            if len(value) == 1 and value[0] == "":
                prompt_data["personalization"] = True
                return
            # Otherwise, keep each code as a separate item
            prompt_data["personalization"] = [str(v) for v in value]
            return

        # Handle string value
        if value == "":
            prompt_data["personalization"] = True
        else:
            prompt_data["personalization"] = [str(value)]

    def _process_references(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Process reference parameters."""
        ref_map = {
            "character_reference": ["character_reference", "cref"],
            "style_reference": ["style_reference", "sref"],
        }

        for target, sources in ref_map.items():
            for source in sources:
                if source in midjargon_dict:
                    value = midjargon_dict[source]
                    if value:
                        prompt_data[target] = (
                            value if isinstance(value, list) else [value]
                        )
                    break

    def _process_numeric_params(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Process numeric parameters."""
        numeric_params = {
            "stylize": ["s", "stylize"],
            "chaos": ["c", "chaos"],
            "weird": ["w", "weird"],
            "image_weight": ["iw", "image_weight"],
            "seed": ["seed"],
            "stop": ["stop"],
            "quality": ["q", "quality"],
            "character_weight": ["cw", "character_weight"],
            "style_weight": ["sw", "style_weight"],
            "style_version": ["sv", "style_version"],
            "repeat": ["r", "repeat"],
        }

        for target, sources in numeric_params.items():
            for source in sources:
                if source in midjargon_dict:
                    value = midjargon_dict[source]
                    try:
                        processed = self.param_handler.process(source, value)
                        if value is None:  # Explicitly set None values
                            prompt_data[target] = None
                        elif processed is not None:
                            prompt_data[target] = processed
                        break
                    except ParameterValidationError as e:
                        raise ValueError(str(e)) from e

    def _process_flag_params(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Process flag parameters."""
        flag_params = {
            "turbo": ["turbo"],
            "relax": ["relax"],
            "tile": ["tile"],
        }

        for target, sources in flag_params.items():
            for source in sources:
                if source in midjargon_dict:
                    value = midjargon_dict[source]
                    try:
                        processed = self.param_handler.process(source, value)
                        if processed is not None:
                            prompt_data[target] = processed
                            break
                        if value is None:  # Handle flag parameters without values
                            prompt_data[target] = True
                            break
                    except ParameterValidationError as e:
                        raise ValueError(str(e)) from e

    def _process_negative_prompt(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Process negative prompt parameter."""
        if "no" in midjargon_dict:
            value = midjargon_dict["no"]
            if isinstance(value, str):
                prompt_data["negative_prompt"] = value
            elif isinstance(value, list):
                prompt_data["negative_prompt"] = ", ".join(str(v) for v in value)

    def _process_extra_params(
        self, prompt_data: dict[str, Any], midjargon_dict: MidjargonDict
    ) -> None:
        """Process any extra parameters."""
        known_params = {
            "text",
            "images",
            "ar",
            "aspect",
            "version",
            "v",
            "niji",
            "style",
            "p",
            "personalization",
            "character_reference",
            "cref",
            "style_reference",
            "sref",
            "s",
            "stylize",
            "c",
            "chaos",
            "w",
            "weird",
            "iw",
            "image_weight",
            "seed",
            "stop",
            "q",
            "quality",
            "cw",
            "character_weight",
            "sw",
            "style_weight",
            "sv",
            "style_version",
            "r",
            "repeat",
            "turbo",
            "relax",
            "tile",
            "no",
        }

        extra_params = {}
        for key, value in midjargon_dict.items():
            if key not in known_params:
                if value is None:
                    extra_params[key] = None
                elif isinstance(value, list):
                    extra_params[key] = value
                else:
                    extra_params[key] = str(value)
        prompt_data["extra_params"] = extra_params

    def parse_dict(self, midjargon_dict: MidjargonDict) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.

        Args:
            midjargon_dict: Dictionary to parse

        Returns:
            MidjourneyPrompt object

        Raises:
            ValueError: If parsing fails
        """
        prompt_data = self._init_prompt_data()

        # Process text and images first
        self._process_text_and_images(prompt_data, midjargon_dict)

        # Process all other parameters
        self._process_aspect_ratio(prompt_data, midjargon_dict)
        self._process_version(prompt_data, midjargon_dict)
        self._process_style(prompt_data, midjargon_dict)
        self._process_personalization(prompt_data, midjargon_dict)
        self._process_references(prompt_data, midjargon_dict)
        self._process_numeric_params(prompt_data, midjargon_dict)
        self._process_flag_params(prompt_data, midjargon_dict)
        self._process_negative_prompt(prompt_data, midjargon_dict)
        self._process_extra_params(prompt_data, midjargon_dict)

        return MidjourneyPrompt(**prompt_data)

    def _format_numeric_params(self, prompt: MidjourneyPrompt) -> dict[str, str]:
        """Format numeric parameters for dictionary output.

        Args:
            prompt: MidjourneyPrompt instance.

        Returns:
            Dictionary of formatted numeric parameters.
        """
        numeric_params = {
            "stylize": "s",
            "chaos": "c",
            "weird": "w",
            "image_weight": "iw",
            "seed": "seed",
            "stop": "stop",
            "quality": "q",
            "character_weight": "cw",
            "style_weight": "sw",
            "style_version": "sv",
            "repeat": "r",
        }

        result = {}
        for attr, param_name in numeric_params.items():
            value = getattr(prompt, attr)
            if value is not None:
                result[param_name] = str(value)
        return result

    def _format_version(self, version: str | None) -> dict[str, str]:
        """Format version parameter for dictionary output.

        Args:
            version: Version string.

        Returns:
            Dictionary with formatted version parameter.
        """
        if not version:
            return {}

        if version.lower().startswith("niji"):
            parts = version.split()
            return {"niji": parts[1] if len(parts) > 1 else ""}

        version_value = version[1:] if version.startswith("v") else version
        return {"v": version_value}

    def _format_flags(self, prompt: MidjourneyPrompt) -> dict[str, None]:
        """Format flag parameters for dictionary output.

        Args:
            prompt: MidjourneyPrompt instance.

        Returns:
            Dictionary of flag parameters.
        """
        result = {}
        for flag in ("turbo", "relax", "tile"):
            if getattr(prompt, flag):
                result[flag] = None
        return result

    def _format_references(self, prompt: MidjourneyPrompt) -> dict[str, str]:
        """Format reference parameters for dictionary output.

        Args:
            prompt: MidjourneyPrompt instance.

        Returns:
            Dictionary of reference parameters.
        """
        result = {}
        if prompt.character_reference:
            result["cref"] = prompt.character_reference
        if prompt.style_reference:
            result["sref"] = prompt.style_reference
        return result

    def _format_aspect_ratio(self, width: int, height: int) -> dict[str, str]:
        """Format aspect ratio parameter."""
        if width == 1 and height == 1:
            return {}
        return {
            "--ar": f"{width}:{height}",
            "--aspect_width": str(width),
            "--aspect_height": str(height),
        }

    def to_dict(self, prompt: MidjourneyPrompt) -> dict[str, Any]:
        """Convert prompt to dictionary format."""
        result = {
            "text": prompt.text,
            "image_prompts": [ip.url for ip in prompt.image_prompts],
            "stylize": prompt.stylize,
            "chaos": prompt.chaos,
            "weird": prompt.weird,
            "image_weight": prompt.image_weight,
            "seed": prompt.seed,
            "stop": prompt.stop,
            "aspect_width": prompt.aspect_width,
            "aspect_height": prompt.aspect_height,
            "aspect_ratio": f"{prompt.aspect_width}:{prompt.aspect_height}",
            "style": prompt.style,
            "version": prompt.version,
            "personalization": prompt.personalization,
            "quality": prompt.quality,
            "character_reference": prompt.character_reference,
            "character_weight": prompt.character_weight,
            "style_reference": prompt.style_reference,
            "style_weight": prompt.style_weight,
            "style_version": prompt.style_version,
            "repeat": prompt.repeat,
            "turbo": prompt.turbo,
            "relax": prompt.relax,
            "tile": prompt.tile,
            "negative_prompt": prompt.negative_prompt,
            "extra_params": {
                "aspect_width": str(prompt.aspect_width),
                "aspect_height": str(prompt.aspect_height),
                **prompt.extra_params,
            },
        }

        # Remove None values
        return {k: v for k, v in result.items() if v is not None}

    def _parse_dict(self, midjargon_dict: MidjargonDict) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt object.

        This is the implementation of the abstract method from EngineParser.

        Args:
            midjargon_dict: Dictionary to parse.

        Returns:
            MidjourneyPrompt object.

        Raises:
            ValueError: If data is invalid.
        """
        return self.parse_dict(midjargon_dict)
</file>

<file path="src/midjargon/__init__.py">
"""
midjargon

A Python library for parsing and manipulating Midjourney prompts.
"""

from importlib import metadata

from midjargon.core.input import expand_midjargon_input
from midjargon.core.models import (CharacterReference, ImageReference,
                                   MidjourneyParameters, MidjourneyPrompt,
                                   MidjourneyVersion, PromptVariant, StyleMode,
                                   StyleReference)
from midjargon.core.parser import (parse_midjargon_prompt,
                                   parse_midjargon_prompt_to_dict)

__all__ = [
    "MidjargonDict",
    # Core types
    "MidjargonInput",
    "MidjargonList",
    "MidjargonPrompt",
    # Midjourney-specific
    "MidjourneyPrompt",
    # Core functions
    "expand_midjargon_input",
    "parse_midjargon_prompt_to_dict",
    "parse_midjourney_dict",
]
</file>

<file path="tests/core/test_parameters.py">
"""Tests for parameter parsing functionality."""

import pytest
from midjargon.core.parameters import parse_parameters


def test_basic_parameter_parsing():
    """Test parsing of basic parameters."""
    param_str = "--ar 16:9 --stylize 100"
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["stylize"] == "100"


def test_flag_parameters():
    """Test parsing of flag parameters (without values)."""
    param_str = "--tile --turbo --relax"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None


def test_parameter_with_multiple_values():
    """Test parsing parameters that accept multiple values."""
    param_str = "--no blur,cars,watermark"
    params = parse_parameters(param_str)
    assert params["no"] == "blur,cars,watermark"


def test_parameter_with_spaces():
    """Test parsing parameters with values containing spaces."""
    param_str = '--style "raw photo" --seed 123456'
    params = parse_parameters(param_str)
    assert params["style"] == "raw photo"
    assert params["seed"] == "123456"


def test_mixed_parameters():
    """Test parsing a mix of different parameter types."""
    param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["tile"] is None
    assert params["no"] == "blur,cars"
    assert params["style"] == "raw photo"


def test_shorthand_parameters():
    """Test parsing of shorthand parameter names."""
    param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
    params = parse_parameters(param_str)
    assert params["stylize"] == "100"
    assert params["chaos"] == "50"
    assert params["weird"] == "1000"
    assert params["image_weight"] == "2.0"
    assert params["quality"] == "1.0"


def test_niji_version_parameter():
    """Test parsing of niji version parameter."""
    # Test basic niji
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"


def test_version_parameter():
    """Test parsing of version parameter."""
    # Test v parameter
    params = parse_parameters("--v 5.2")
    assert params["version"] == "5.2"


def test_personalization_parameter():
    """Test parsing of personalization parameter."""
    # Test basic p parameter
    params = parse_parameters("--p")
    assert params["personalization"] is None  # Flag without value is None

    # Test p parameter with value
    params = parse_parameters("--p custom")
    assert params["personalization"] == ["custom"]

    # Test p parameter with multiple values
    params = parse_parameters("--p custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]

    # Test personalization parameter with value
    params = parse_parameters("--personalization custom")
    assert params["personalization"] == ["custom"]

    # Test personalization parameter with multiple values
    params = parse_parameters("--personalization custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]


def test_reference_parameters():
    """Test parsing of reference parameters."""
    param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
    params = parse_parameters(param_str)
    assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
    assert params["style_reference"] == ["style1.jpg", "style2.jpg"]


def test_parameter_order():
    """Test that parameter order is preserved in output."""
    param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
    params = parse_parameters(param_str)
    keys = list(params.keys())
    assert keys == ["seed", "aspect", "chaos", "tile"]


def test_invalid_parameters():
    """Test handling of invalid parameter formats."""
    with pytest.raises(ValueError, match="Empty parameter name"):
        parse_parameters("--")  # Empty parameter name

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--ar")  # Missing required value

    with pytest.raises(ValueError, match="Parameter name cannot start with dash"):
        parse_parameters("ar 16:9")  # Missing -- prefix

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--v")  # Missing version value


def test_parse_parameters():
    """Test parse_parameters function to verify parameter parsing."""
    param_str = "--ar 16:9 --stylize 100"
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["stylize"] == "100"

    param_str = "--tile --turbo --relax"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None

    param_str = "--no blur,cars,watermark"
    params = parse_parameters(param_str)
    assert params["no"] == "blur,cars,watermark"

    param_str = '--style "raw photo" --seed 123456'
    params = parse_parameters(param_str)
    assert params["style"] == "raw photo"
    assert params["seed"] == "123456"

    param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["tile"] is None
    assert params["no"] == "blur,cars"
    assert params["style"] == "raw photo"

    param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
    params = parse_parameters(param_str)
    assert params["stylize"] == "100"
    assert params["chaos"] == "50"
    assert params["weird"] == "1000"
    assert params["image_weight"] == "2.0"
    assert params["quality"] == "1.0"

    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"

    params = parse_parameters("--v 5.2")
    assert params["version"] == "5.2"

    params = parse_parameters("--p")
    assert params["personalization"] is None  # Flag without value is None

    params = parse_parameters("--p custom")
    assert params["personalization"] == ["custom"]

    params = parse_parameters("--personalization custom")
    assert params["personalization"] == ["custom"]

    param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
    params = parse_parameters(param_str)
    assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
    assert params["style_reference"] == ["style1.jpg", "style2.jpg"]

    param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
    params = parse_parameters(param_str)
    keys = list(params.keys())
    assert keys == ["seed", "aspect", "chaos", "tile"]

    with pytest.raises(ValueError, match="Empty parameter name"):
        parse_parameters("--")  # Empty parameter name

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--ar")  # Missing required value

    with pytest.raises(ValueError, match="Parameter name cannot start with dash"):
        parse_parameters("ar 16:9")  # Missing -- prefix

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--v")  # Missing version value


def test_flag_parameters_handling():
    """Test handling of flag parameters in parse_parameters."""
    param_str = "--tile --turbo --relax --video --remix"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None
    assert params["video"] is None
    assert params["remix"] is None

    param_str = "--p"
    params = parse_parameters(param_str)
    assert params["personalization"] is None  # Flag without value is None

    param_str = "--p custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]

    param_str = "--personalization custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]


def test_special_seed_values():
    """Test handling of special seed values."""
    # Test random seed
    params = parse_parameters("--seed random")
    assert params["seed"] == "random"

    # Test numeric seed
    params = parse_parameters("--seed 12345")
    assert params["seed"] == "12345"


def test_reference_url_handling():
    """Test handling of URLs in reference parameters."""
    # Test character reference with quoted URL containing spaces
    params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
    assert params["character_reference"] == [
        "https://example.com/image with spaces.jpg"
    ]

    # Test style reference with quoted URL containing spaces
    params = parse_parameters('--sref "https://example.com/style with spaces.jpg"')
    assert params["style_reference"] == ["https://example.com/style with spaces.jpg"]

    # Test character reference with single URL (no quotes)
    params = parse_parameters("--cref https://example.com/image.jpg")
    assert params["character_reference"] == ["https://example.com/image.jpg"]

    # Test style reference with single URL (no quotes)
    params = parse_parameters("--sref https://example.com/style.jpg")
    assert params["style_reference"] == ["https://example.com/style.jpg"]


def test_niji_version_handling():
    """Test handling of niji version parameter."""
    # Test basic niji flag
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 5")
    assert params["version"] == "niji 5"

    # Test niji with version in permutation
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"

    # Ensure no 'v' prefix is added
    version = str(params["version"])  # Convert to string to use startswith
    assert not version.startswith("v")
</file>

<file path="pyproject.toml">
[build-system]
build-backend = "hatchling.build"
requires = ["hatchling>=1.21.0", "hatch-vcs>=0.3.0"]

[[project.authors]]
email = "adam+github@twardoch.com"
name = "Adam Twardoch"

[project]
name = "midjargon"
version = "0.1.0"
description = "A package for parsing and manipulating Midjourney-style prompts"
requires-python = ">=3.10"
readme = "README.md"
license = { text = "Apache-2.0" }
dependencies = [
    "pydantic>=2.0.0",
    "rich>=13.0.0",
    "fire>=0.5.0",
    "python-box>=7.3.2",
    "fal-client>=0.5.8",
]

[[project.authors]]
name = "Adam Twardoch"
email = "adam+github@twardoch.com"

[project.optional-dependencies]
test = [
    "pytest>=8.0.0",
    "pytest-cov>=4.1.0",
]

[project.urls]
Documentation = "https://github.com/twardoch/midjargon#readme"
Issues = "https://github.com/twardoch/midjargon/issues"
Source = "https://github.com/twardoch/midjargon"

[project.scripts]
midjargon = "midjargon.__main__:main"

[build-system]
requires = ["hatchling>=1.21.0", "hatch-vcs>=0.3.0"]
build-backend = "hatchling.build"

[tool.rye]
managed = true
dev-dependencies = [
    "pytest>=8.0.0",
    "pytest-cov>=6.0.0",
    "ruff>=0.2.0",
    "mypy>=1.8.0",
]

[tool.hatch.metadata]
allow-direct-references = true

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
select = [
    "E",  # pycodestyle errors
    "W",  # pycodestyle warnings
    "F",  # pyflakes
    "I",  # isort
    "C",  # flake8-comprehensions
    "B",  # flake8-bugbear
    "UP",  # pyupgrade
]
ignore = []

[tool.ruff.lint.isort]
known-first-party = ["midjargon"]

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true

[tool.coverage.paths]
midjargon = ["src/midjargon", "*/src/midjargon"]
tests = ["tests", "*/midjargon/tests"]

[tool.coverage.run]
branch = true
source = ["midjargon"]
parallel = true
source_pkgs = ["midjargon", "tests"]

[tool.coverage.report]
exclude_lines = [
    "no cov",
    "if __name__ == .__main__.:",
    "if TYPE_CHECKING:",
]

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.pytest.ini_options]
testpaths = ["tests"]
filterwarnings = [
    "error",
    "ignore::DeprecationWarning",
    "ignore::UserWarning",
]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "rounds: Number of rounds",
]

[tool.hatch.build.hooks.vcs]
version-file = "src/midjargon/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/midjargon"]

[[tool.hatch.envs.all.matrix]]
python = ["3.11", "3.12"]

[tool.hatch.envs.default]
dependencies = ["pytest", "pytest-cov", "mypy>=1.0.0", "ruff>=0.1.0"]

[tool.hatch.envs.default.scripts]
lint = ["ruff check src/midjargon tests", "ruff format src/midjargon tests"]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/midjargon --cov=tests {args:tests}"
type-check = "mypy src/midjargon tests"

[tool.hatch.envs.lint]
dependencies = ["mypy>=1.0.0", "ruff>=0.1.0"]
detached = true

[tool.hatch.envs.lint.scripts]
all = ["style", "typing"]
fmt = ["ruff format {args:.}", "ruff check --fix {args:.}"]
style = ["ruff check {args:.}", "ruff format {args:.}"]
typing = "mypy --install-types --non-interactive {args:src/midjargon tests}"

[tool.hatch.envs.test]
dependencies = [
  "pytest>=7.0.0",
  "pytest-cov>=4.0.0",
  "pytest-xdist>=3.0.0",
  "midjargon[test]",
]

[tool.hatch.envs.test.scripts]
test = "pytest --cov=src/midjargon --cov-report=term-missing --cov-branch --no-cov-on-fail {args:tests}"
test-cov = "pytest --cov=src/midjargon --cov-report=term-missing --cov-branch --no-cov-on-fail {args:tests}"

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
] 


[tool.pyright]
include = ["src", "tests"]
exclude = ["**/node_modules",
    "**/__pycache__",
]
ignore = ["_private"]
defineConstant = { DEBUG = true }

reportMissingImports = "error"
reportMissingTypeStubs = false

pythonVersion = "3.10"
pythonPlatform = "Linux"
</file>

<file path="src/midjargon/core/input.py">
#!/usr/bin/env python3
# this_file: src/midjargon/core/input.py
from __future__ import annotations

from midjargon.core.models import PromptVariant
from midjargon.core.parser import parse_midjargon_prompt
from midjargon.core.permutations import expand_permutations

from midjargon.core.permutations import expand_text
# reuse the existing expansion logic
from midjargon.core.type_defs import MidjargonInput, MidjargonList


def expand_midjargon_input(prompt: MidjargonInput) -> MidjargonList:
    """
    if not prompt or not prompt.strip():
        msg = "Empty prompt"
        raise ValueError(msg)

    # Split on double colon and parse weights
    result = []
    current_prompt = []
    i = 0

    while i < len(prompt):
        if prompt[i : i + 2] == "::" and (i == 0 or prompt[i - 1] != "\\"):
            # Found weight separator
            text = "".join(current_prompt).strip()
            if not text:
                msg = "Empty prompt before weight"
                raise ValueError(msg)

            # Parse weight
            i += 2
            weight_start = i
            while i < len(prompt) and (prompt[i].isdigit() or prompt[i] == "."):
                i += 1

            if i == weight_start:
                msg = f"Missing weight after :: at position {i - 2}"
                raise ValueError(msg)

            try:
                weight = float(prompt[weight_start:i])
                if weight <= 0:
                    msg = f"Weight must be positive at position {weight_start}"
                    raise ValueError(msg)
            except ValueError as e:
                msg = f"Invalid weight at position {weight_start}: {prompt[weight_start:i]}"
                raise ValueError(msg) from e

            result.append((text, weight))
            current_prompt = []
        else:
            current_prompt.append(prompt[i])
            i += 1

    # Handle last part
    if current_prompt:
        text = "".join(current_prompt).strip()
        if text:
            result.append((text, 1.0))  # Default weight

    if not result:
        msg = "Empty prompt"
        raise ValueError(msg)

    # Normalize weights to sum to 1.0
    total_weight = sum(weight for _, weight in result)
    if total_weight > 0:
        result = [(text, weight / total_weight) for text, weight in result]

    return result


def expand_midjargon_input(prompt: str) -> list[PromptVariant]:
    """Expand a midjourney prompt by processing permutations and returning a list of prompt variants.

    Args:
        prompt: A raw MidjargonInput string that may contain permutation syntax (e.g. {red, blue}).

    Returns:
        A list of PromptVariant objects, each containing an expanded prompt.

    Raises:
        ValueError: If the prompt is invalid or empty.
    """
    # First split into weighted prompts
    weighted_prompts = parse_weighted_prompt(prompt)

    # Process each weighted prompt
    result = []
    for text, weight in weighted_prompts:
        # Expand permutations for this prompt
        expanded = expand_permutations(text)
        for expanded_text in expanded:
            # Parse the expanded text into a MidjourneyPrompt
            try:
                prompt_obj = parse_midjargon_prompt(expanded_text)
                variant = PromptVariant(prompt=prompt_obj, weight=weight)
                # Ensure the weight is properly set in both places
                variant.prompt.weight = weight
                result.append(variant)
            except ValueError as e:
                msg = f"Failed to parse expanded prompt '{expanded_text}': {e}"
                raise ValueError(msg) from e

    return result
</file>

<file path="src/midjargon/engines/midjourney/models.py">
"""
Models for Midjourney engine.
"""

from __future__ import annotations

import re
from typing import Any

from midjargon.engines.midjourney.constants import (CHAOS_RANGE,
                                                    CHARACTER_WEIGHT_RANGE,
                                                    DEFAULT_ASPECT_RATIO,
                                                    DEFAULT_CHAOS,
                                                    DEFAULT_CHARACTER_WEIGHT,
                                                    DEFAULT_IMAGE_WEIGHT,
                                                    DEFAULT_QUALITY,
                                                    DEFAULT_RELAX,
                                                    DEFAULT_STOP,
                                                    DEFAULT_STYLE_VERSION,
                                                    DEFAULT_STYLIZE,
                                                    DEFAULT_TILE,
                                                    DEFAULT_TURBO,
                                                    DEFAULT_WEIRD,
                                                    IMAGE_WEIGHT_RANGE,
                                                    QUALITY_RANGE,
                                                    REPEAT_RANGE, SEED_RANGE,
                                                    STOP_RANGE,
                                                    STYLE_VERSION_RANGE,
                                                    STYLE_WEIGHT_RANGE,
                                                    STYLIZE_RANGE,
                                                    VALID_NIJI_VERSIONS,
                                                    VALID_STYLES,
                                                    VALID_VERSIONS,
                                                    WEIRD_RANGE)
from pydantic import BaseModel, Field, field_validator, model_validator


class ImagePrompt(BaseModel):
    """Represents a validated image prompt URL."""

    url: str = Field(description="Direct image URL ending with allowed extension")

    @field_validator("url")
    @classmethod
    def validate_extension(cls, v: str) -> str:
        """Validates image URL has an allowed file extension."""
        # if not str(v).lower().endswith(ALLOWED_IMAGE_EXTENSIONS):
        #    msg = f"URL must end with one of: {ALLOWED_IMAGE_EXTENSIONS}"
        #    raise ValueError(msg)

        # Validate URL format
        url_pattern = re.compile(
            r"^https?://"  # http:// or https://
            r"(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|"  # domain
            r"localhost|"  # localhost
            r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})"  # ip
            r"(?::\d+)?"  # optional port
            r"(?:/?|[/?]\S+)$",
            re.IGNORECASE,
        )

        if not url_pattern.match(v):
            msg = "Invalid URL format"
            raise ValueError(msg)

        return v


class MidjourneyPrompt(BaseModel):
    """
    Represents a fully validated Midjourney prompt structure.
    Converts raw parameters into specific validated fields.
    """

    # Core prompt components
    text: str = Field(min_length=1)
    image_prompts: list[ImagePrompt] = Field(default_factory=list)

    # Validated numeric parameters with defaults
    stylize: int | None = Field(
        default=DEFAULT_STYLIZE, ge=STYLIZE_RANGE[0], le=STYLIZE_RANGE[1]
    )
    chaos: int | None = Field(
        default=DEFAULT_CHAOS, ge=CHAOS_RANGE[0], le=CHAOS_RANGE[1]
    )
    weird: int | None = Field(
        default=DEFAULT_WEIRD, ge=WEIRD_RANGE[0], le=WEIRD_RANGE[1]
    )
    image_weight: float | None = Field(
        default=DEFAULT_IMAGE_WEIGHT, ge=IMAGE_WEIGHT_RANGE[0], le=IMAGE_WEIGHT_RANGE[1]
    )
    seed: int | None = Field(default=None, ge=SEED_RANGE[0], le=SEED_RANGE[1])
    stop: int | None = Field(default=DEFAULT_STOP, ge=STOP_RANGE[0], le=STOP_RANGE[1])

    # Aspect ratio parameters
    aspect_width: int = Field(default=1, gt=0)
    aspect_height: int = Field(default=1, gt=0)
    aspect_ratio: str = Field(default=DEFAULT_ASPECT_RATIO)

    # Style parameters
    style: str | None = Field(default=None)  # raw, cute, expressive, etc.
    version: str | None = Field(default=None)  # v5, v6, niji, etc.
    personalization: bool | list[str] | None = Field(
        default=False
    )  # Profile IDs or codes for --p parameter

    # New parameters with defaults
    quality: float | None = Field(
        default=DEFAULT_QUALITY, ge=QUALITY_RANGE[0], le=QUALITY_RANGE[1]
    )
    character_reference: list[str] = Field(default_factory=list)
    character_weight: int | None = Field(
        default=DEFAULT_CHARACTER_WEIGHT,
        ge=CHARACTER_WEIGHT_RANGE[0],
        le=CHARACTER_WEIGHT_RANGE[1],
    )
    style_reference: list[str] = Field(default_factory=list)
    style_weight: int | None = Field(
        default=None, ge=STYLE_WEIGHT_RANGE[0], le=STYLE_WEIGHT_RANGE[1]
    )
    style_version: int | None = Field(
        default=DEFAULT_STYLE_VERSION,
        ge=STYLE_VERSION_RANGE[0],
        le=STYLE_VERSION_RANGE[1],
    )
    repeat: int | None = Field(default=None, ge=REPEAT_RANGE[0], le=REPEAT_RANGE[1])

    # Flag parameters with defaults
    turbo: bool = Field(default=DEFAULT_TURBO)
    relax: bool = Field(default=DEFAULT_RELAX)
    tile: bool = Field(default=DEFAULT_TILE)

    # Negative prompts
    negative_prompt: str | None = Field(default=None)

    # Store any unknown parameters
    extra_params: dict[str, str | None] = Field(default_factory=dict)

    @field_validator("text")
    @classmethod
    def clean_text(cls, v: str) -> str:
        """Basic text cleanup."""
        return v.strip()

    @field_validator("style")
    @classmethod
    def validate_style(cls, v: str | None) -> str | None:
        """Validate style value."""
        if v is not None and v not in VALID_STYLES:
            msg = f"Invalid style value. Must be one of: {VALID_STYLES}"
            raise ValueError(msg)
        return v

    @field_validator("version")
    @classmethod
    def validate_version(cls, v: str | None) -> str | None:
        """Validate version value."""
        if v is None:
            return v

        # Handle Niji version
        if v.startswith("niji"):
            parts = v.split()
            if len(parts) == 1:  # Just "niji"
                return v
            version = parts[-1]
            if version not in VALID_NIJI_VERSIONS:
                msg = f"Invalid niji version. Must be one of: {VALID_NIJI_VERSIONS}"
                raise ValueError(msg)
            return f"niji {version}"  # Return niji version without 'v' prefix

        # Handle Midjourney version
        version = v.lstrip("v")
        if version not in VALID_VERSIONS:
            msg = f"Invalid version value. Must be one of: {VALID_VERSIONS}"
            raise ValueError(msg)
        return f"v{version}"  # Always add 'v' prefix for regular versions

    @model_validator(mode="after")
    def validate_mode_flags(self) -> Any:
        """Validate mode flag combinations."""
        if self.turbo and self.relax:
            msg = "Cannot use both turbo and relax modes"
            raise ValueError(msg)
        return self

    @model_validator(mode="after")
    def parse_aspect_ratio(self) -> Any:
        """Parse and validate aspect ratio."""
        # If aspect_ratio is provided, parse it and update width/height
        if ":" in self.aspect_ratio:
            try:
                width, height = self.aspect_ratio.split(":")
                self.aspect_width = int(width)
                self.aspect_height = int(height)
            except (ValueError, AttributeError):
                # If parsing fails, use the default
                width, height = DEFAULT_ASPECT_RATIO.split(":")
                self.aspect_width = int(width)
                self.aspect_height = int(height)
                self.aspect_ratio = DEFAULT_ASPECT_RATIO
        else:
            # If no valid aspect_ratio, construct it from width/height
            self.aspect_ratio = f"{self.aspect_width}:{self.aspect_height}"

        return self
</file>

<file path="src/midjargon/core/parser.py">
#!/usr/bin/env python3
# this_file: src/midjargon/core/parser.py
from __future__ import annotations

Provides a simple, permissive parser that converts an expanded prompt (a MidjargonPrompt string)
into a flat dictionary (MidjargonDict) with the following keys:
  - "images": list of image URLs (extracted from the beginning of the prompt)
  - "text": the main text of the prompt
  - Additional keys for any parameters found (keys without the '--' prefix)

from midjargon.core.models import (CharacterReference, ImageReference,
                                   MidjourneyPrompt, MidjourneyVersion,
                                   StyleMode, StyleReference)
from pydantic import HttpUrl


def is_valid_image_url(url: str) -> bool:
    """Check if a URL is a valid image URL."""
    try:
        result = urlparse(url)
        return bool(
            result.scheme
            and result.netloc
            and any(
                result.path.lower().endswith(ext)
                for ext in [".jpg", ".jpeg", ".png", ".gif", ".webp"]
            )
        )
    except Exception:
        return False


def is_url(text: str) -> bool:
    """Check if text is a URL."""
    try:
        result = urlparse(text)
        return all([result.scheme, result.netloc])
    except Exception:
        return False

    Args:
        text: The text to split.

def extract_image_urls(prompt: str) -> tuple[list[ImageReference], str]:
    """Extract image URLs from the start of a prompt.

    Args:
        tokens: List of tokens from prompt text.

    Returns:
        A tuple of (list of ImageReference objects, remaining text).
    """
    parts = prompt.strip().split()
    refs = []
    text_start = 0

    for i, part in enumerate(parts):
        if is_url(part):
            refs.append(ImageReference(url=HttpUrl(part)))
            text_start = i + 1
        else:
            break

    return refs, " ".join(parts[text_start:])


def parse_midjargon_prompt_to_dict(expanded_prompt: MidjargonPrompt) -> MidjargonDict:
    """
    Parse an expanded prompt into a dictionary format.
    Handles URL extraction and parameter parsing.

    Args:
        expanded_prompt: Expanded prompt string.

    Returns:
        Dictionary containing parsed prompt components.
    """
    # Extract URLs and text
    urls = []
    text_parts = []

    # Split into individual parameters
    parts = param_str.split("--")
    for part in parts[1:]:  # Skip empty first part
        if not part.strip():
            continue

        # Split parameter name and value
        param_parts = part.strip().split(maxsplit=1)
        param_name = param_parts[0]
        param_value = param_parts[1] if len(param_parts) > 1 else None

        # Handle special parameters
        if param_name == "cref":
            if param_value:
                if is_url(param_value):
                    params["character_reference"].append(
                        CharacterReference(url=HttpUrl(param_value), code=None)
                    )
                else:
                    params["character_reference"].append(
                        CharacterReference(url=None, code=param_value)
                    )
        elif param_name == "sref":
            if param_value:
                if is_url(param_value):
                    params["style_reference"].append(
                        StyleReference(url=HttpUrl(param_value), code=None)
                    )
                else:
                    params["style_reference"].append(
                        StyleReference(url=None, code=param_value)
                    )
        elif param_name == "ar":
            if param_value:
                try:
                    w, h = map(int, param_value.split(":"))
                    params["aspect_ratio"] = f"{w}:{h}"
                    params["aspect_width"] = w
                    params["aspect_height"] = h
                except ValueError as e:
                    msg = f"Invalid aspect ratio format: {e}"
                    raise ValueError(msg) from e
        elif param_name in ("v", "version"):
            if param_value:
                try:
                    version = MidjourneyVersion(param_value)
                    params["version"] = version
                except ValueError as e:
                    msg = f"Invalid version value: {param_value}"
                    raise ValueError(msg) from e
        elif param_name == "style":
            if param_value:
                try:
                    style = StyleMode(param_value.lower())
                    params["style"] = style
                except ValueError as e:
                    msg = f"Invalid style value: {param_value}"
                    raise ValueError(msg) from e
        # Handle flag parameters
        elif param_value is None:
            if param_name in {"tile", "turbo", "relax"}:
                params[param_name] = True
            else:
                msg = f"Invalid flag parameter: {param_name}"
                raise ValueError(msg)
        # Handle numeric parameters
        elif param_value.replace(".", "").isdigit():
            if param_name in {"stylize", "s"}:
                params["stylize"] = int(param_value)
            elif param_name in {"chaos", "c"}:
                params["chaos"] = int(param_value)
            elif param_name in {"weird", "w"}:
                params["weird"] = int(param_value)
            elif param_name == "seed" and param_value != "random":
                params["seed"] = int(param_value)
            elif param_name == "cw":
                params["character_weight"] = float(param_value)
            elif param_name == "sw":
                params["style_weight"] = float(param_value)
            else:
                params[param_name] = (
                    float(param_value) if "." in param_value else int(param_value)
                )
        # Handle boolean parameters
        elif param_value.lower() in ("true", "false"):
            params[param_name] = param_value.lower() == "true"
        # Handle list parameters
        elif param_value.startswith("[") and param_value.endswith("]"):
            try:
                items = [
                    item.strip()
                    for item in param_value[1:-1].split(",")
                    if item.strip()
                ]
                params[param_name] = items
            except Exception as e:
                msg = f"Failed to parse list parameter {param_name}: {e!s}"
                raise ValueError(msg) from e
        # Handle string parameters
        else:
            text_parts.append(part)

    # Join remaining parts as text, preserving original spacing
    text_part = " ".join(text_parts)

    # Find where parameters start (if any)
    param_part = ""
    if "--" in text_part:
        text_split = text_part.split("--", 1)
        text_part = text_split[0].strip()
        param_part = "--" + text_split[1]

    # Parse parameters using the consolidated parameter parsing logic
    params = parse_parameters(param_part) if param_part.startswith("--") else {}

    # Convert numeric values
    numeric_params = {
        "stylize": int,
        "chaos": int,
        "weird": int,
        "image_weight": float,
        "seed": int,
        "stop": int,
        "quality": float,
        "repeat": int,
        "character_weight": int,
        "style_weight": int,
        "style_version": int,
    }

    for param, converter in numeric_params.items():
        if param in params and params[param] is not None:
            with contextlib.suppress(ValueError, TypeError):
                params[param] = converter(params[param])

    Raises:
        ValueError: If the prompt is invalid or missing required components.
    """
    # Extract image URLs
    images, remaining_text = extract_image_urls(prompt)

    # Split into text and parameters
    if " --" in remaining_text:
        text_part, param_part = remaining_text.split(" --", 1)
        text_part = text_part.strip()
        param_str = "--" + param_part.strip()
        try:
            parameters = parse_parameters(param_str)
        except Exception as e:
            msg = f"Failed to parse parameters: {e!s}"
            raise ValueError(msg) from e
    else:
        text_part = remaining_text.strip()
        parameters = {}

    # Create and validate the prompt object
    try:
        return MidjourneyPrompt(
            text=text_part,
            image_prompts=images,
            **parameters,
        )
    except Exception as e:
        msg = f"Failed to create prompt object: {e!s}"
        raise ValueError(msg) from e


def parse_midjargon_prompt_to_dict(prompt: str) -> dict[str, Any]:
    """Parse a Midjourney prompt into a dictionary.

    Args:
        prompt: The raw prompt string to parse.

    return cast(MidjargonDict, result)
</file>

<file path="src/midjargon/core/permutations.py">
#!/usr/bin/env python3
# this_file: src/midjargon/core/permutations.py
from __future__ import annotations

Handles expansion of permutation expressions in Midjourney prompts.
Supports nested permutations and proper spacing handling.
"""

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Sequence

    from midjargon.core.type_defs import MidjargonList

# Constants
ESCAPE_SEQUENCE_LENGTH = 2  # Length of escape sequence: backslash + character


def split_options(text: str) -> list[str]:
    """
    Split permutation options handling escaped commas and nested braces.

    Args:
        text: Text inside {} brackets containing comma-separated options.

    Returns:
        List of individual options with escaped characters unescaped.
    """
    options = []
    current = []
    i = 0
    depth = 0  # Track nested braces

    while i < len(text):
        if text[i] == "\\" and i + 1 < len(text):
            # Keep escaped characters as-is
            if text[i + 1] in (",", "{", "}"):
                current.append(text[i + 1])
            else:
                current.extend([text[i], text[i + 1]])
            i += ESCAPE_SEQUENCE_LENGTH
        elif text[i] == "{":
            depth += 1
            current.append(text[i])
            i += 1
        elif text[i] == "}":
            depth -= 1
            current.append(text[i])
            i += 1
        elif text[i] == "," and depth == 0:
            # Add current option after stripping whitespace
            opt = "".join(current).strip()
            if opt or not options:  # Include empty options
                options.append(opt)
            current = []
            i += 1
        else:
            current.append(text[i])
            i += 1

    # Add the last option after stripping whitespace
    if current or not options:
        opt = "".join(current).strip()
        options.append(opt)

    return options


def _find_matching_brace(text: str, start: int) -> int:
    """
    Find the matching closing brace for an opening brace.

    Args:
        text: Text to search in.
        start: Starting position of opening brace.

    Returns:
        Position of matching closing brace.

    Raises:
        ValueError: If no matching brace is found.
    """
    depth = 1  # Start at 1 since we're starting at an opening brace
    pos = start + 1
    while pos < len(text):
        # Check for escaped braces
        if text[pos - 1] == "\\" and text[pos] in {"{", "}"}:
            pos += 1
            continue
        if text[pos] == "{" and (pos == 0 or text[pos - 1] != "\\"):
            depth += 1
        elif text[pos] == "}" and (pos == 0 or text[pos - 1] != "\\"):
            depth -= 1
            if depth == 0:
                return pos
        pos += 1
    # If we reach here, treat unmatched braces as literal text
    return start


def _extract_options(text: str, start: int, end: int) -> list[str]:
    """
    Extract options from a permutation group.

    Args:
        text: Full text containing permutation.
        start: Start index of opening brace.
        end: End index of closing brace.

    Returns:
        List of extracted options.
    """
    # Extract text between braces
    inner_text = text[start + 1 : end]
    return split_options(inner_text)


def _format_part(before: str, option: str, after: str) -> str:
    """
    Format a part of the expanded text with proper spacing.

    Args:
        before: Text before the permutation.
        option: The current option being formatted.
        after: Text after the permutation.

    Returns:
        Formatted text with proper spacing.
    """
    # Handle empty option
    if not option:
        # If after starts with a parameter (--), return before + after without space
        if after.lstrip().startswith("--"):
            return before.rstrip() + after.lstrip()
        # Otherwise ensure we keep one space between words
        if before.rstrip() and after.lstrip():
            return before.rstrip() + " " + after.lstrip()
        return before.rstrip() + after.lstrip()

    # Add proper spacing
    before_spaced, after_spaced = _add_spacing(before, after)
    return before_spaced + option + after_spaced


def _add_spacing(before: str, after: str) -> tuple[str, str]:
    """
    Add spacing between words if needed.

    Args:
        before: Text before permutation.
        after: Text after permutation.

    Returns:
        Tuple of (before, after) with proper spacing added.
    """
    if before and before[-1].isalnum():
        before = before + " "
    if after and after[0].isalnum():
        after = " " + after
    return before, after


def _expand_nested(options: Sequence[str]) -> MidjargonList:
    """
    Recursively expand any nested permutations in options.

    Args:
        options: List of options that may contain nested permutations.

    Returns:
        List of fully expanded options.
    """
    return [
        expanded_opt
        for opt in options
        for expanded_opt in (expand_single(opt) if "{" in opt else [opt])
    ]


def expand_single(text: str) -> list[str]:
    """
    Expand a single level of permutations in text.

    Args:
        text: Text to expand.

    Returns:
        List of expanded texts.
    """
    # Find first unescaped opening brace
    i = 0
    while i < len(text):
        if text[i] == "{" and (i == 0 or text[i - 1] != "\\"):
            break
        i += 1
    else:
        # No unescaped opening brace found
        return [text]

    # Find matching closing brace
    j = _find_matching_brace(text, i)
    if j == i:  # No matching brace found, treat as literal
        return [text]

    # Extract and process options
    options = _extract_options(text, i, j)
    if not options:  # Empty permutation
        return [_format_part(text[:i], "", text[j + 1 :])]

    # Generate permutations
    prefix = text[:i]
    suffix = text[j + 1 :]

    # Handle nested permutations
    expanded_options = []
    for opt in options:
        if opt == "":  # Handle empty option
            expanded_options.append("")
        elif "{" in opt:
            expanded = expand_text(opt)
            expanded_options.extend(expanded)
        else:
            expanded_options.append(opt)

    # Format each option with proper spacing
    return [_format_part(prefix, opt, suffix) for opt in expanded_options]


def expand_text(text: str) -> MidjargonList:
    """
    Expand all permutations in text into separate complete prompts.

    Args:
        text: Text containing permutations in {} brackets.

    Returns:
        List of expanded variations with all permutations resolved.
    """
    expanded = [text] if text else [""]
    max_iterations = 100  # Safety limit to prevent infinite loops
    iterations = 0

    while any("{" in t for t in expanded):
        next_level = []
        for t in expanded:
            next_level.extend(expand_single(t))

        # If no changes were made or we hit the iteration limit, break
        if set(next_level) == set(expanded) or iterations >= max_iterations:
            break

        expanded = next_level
        iterations += 1

    return expanded


def split_permutation_options(text: str) -> list[str]:
    """
    Split permutation text into individual options.

    Args:
        text: Text to split.

    Returns:
        List of options.
    """
    if not text.strip():
        return [""]

    options = []
    current = []
    in_quotes = False
    pos = 0

    while pos < len(text):
        char = text[pos]
        if char == '"':
            in_quotes = not in_quotes
            current.append(char)
        elif char == "," and not in_quotes:
            options.append("".join(current).strip())
            current = []
        else:
            current.append(char)
        pos += 1

    if current:
        options.append("".join(current).strip())

    # Filter out empty options
    options = [opt for opt in options if opt]
    if not options:
        return [""]

    return options


def _handle_escaped_char(text: str, pos: int, result: list[str]) -> int:
    """Handle escaped characters in the text."""
    for i in range(len(result)):
        result[i] += text[pos]
    return pos + 1


def _handle_permutation(
    text: str, pos: int, result: list[str]
) -> tuple[list[str], int]:
    """Handle permutation expansion at the current position."""
    try:
        end = _find_matching_brace(text, pos)
        prefix = result[:]
        options = split_permutation_options(text[pos + 1 : end])
        new_result = [p + opt for p in prefix for opt in options]
        return new_result, end + 1
    except ValueError:
        # If no matching brace is found, treat as literal text
        for i in range(len(result)):
            result[i] += text[pos]
        return result, pos + 1


def _handle_literal_char(text: str, pos: int, result: list[str]) -> None:
    """Handle literal character in the text."""
    for i in range(len(result)):
        result[i] += text[pos]


def expand_permutations(text: str) -> list[str]:
    """
    Expand all permutations in a text string.

    Args:
        text: Text to expand.

    Returns:
        List of expanded texts.

    Raises:
        ValueError: If permutation syntax is invalid.
    """
    if not text:
        return [""]

    result = [""]
    pos = 0

    while pos < len(text):
        if pos > 0 and text[pos - 1] == "\\":
            pos = _handle_escaped_char(text, pos, result)
            continue

        if text[pos] == "{":
            result, pos = _handle_permutation(text, pos, result)
        else:
            _handle_literal_char(text, pos, result)
            pos += 1

    return result
</file>

<file path="tests/cli/test_main.py">
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pytest", "rich"]
# ///

"""Tests for CLI functionality."""

import json
import re
import sys
from io import StringIO
from typing import Any

import pytest
from midjargon.cli.main import MidjargonCLI
from rich.console import Console

# Test constants
ASPECT_WIDTH = 16
ASPECT_HEIGHT = 9
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
IMAGE_PROMPTS_COUNT = 2
PERMUTATION_COUNT_2X2 = 4  # 2 options x 2 options

ANSI_ESCAPE = re.compile(r"\x1B[@-_][0-?]*[ -/]*[@-~]")


def parse_json_output(output_stream: StringIO) -> Any:
    """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
    output_stream.seek(0)
    output = output_stream.getvalue()
    # Remove ANSI escape sequences
    output = ANSI_ESCAPE.sub("", output)
    output = output.strip()
    if not output:
        msg = "No JSON found in output"
        raise ValueError(msg)
    try:
        return json.loads(output)
    except json.JSONDecodeError as e:
        msg = "No JSON found in output"
        raise ValueError(msg) from e


@pytest.fixture
def cli():
    """Fixture to provide CLI instance."""
    return MidjargonCLI()


def test_basic_prompt(cli):
    """Test basic prompt processing."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(
            f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT}",
            json_output=True,
        )
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a beautiful landscape"
    assert data["aspect"] == f"{ASPECT_WIDTH}:{ASPECT_HEIGHT}"


def test_permutations(cli):
    """Test permutation processing."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm("a {red, blue} bird", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 2
    texts = set(data)
    assert texts == {"a red bird", "a blue bird"}


def test_raw_output(cli):
    """Test raw output mode."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(f"a photo --stylize {STYLIZE_VALUE}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"
    assert data["stylize"] == STYLIZE_VALUE


def test_json_output_formatting(cli):
    """Test JSON output formatting."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"
    assert "images" in data


def test_invalid_input(cli):
    """Test handling of invalid input."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
        assert data["text"] == ""


def test_parameter_validation(cli):
    """Test parameter validation."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(
            f"a photo --stylize {STYLIZE_VALUE * 20}", json_output=True
        )  # Over max
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
        assert data["stylize"] == STYLIZE_VALUE * 20  # Now accepts any value


def test_image_url_handling(cli):
    """Test handling of image URLs."""
    url = "https://example.com/image.jpg"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(f"{url} a fusion", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a fusion"
    assert len(data["images"]) == 1
    assert data["images"][0] == url


def test_no_color_output(cli):
    """Test no-color output mode."""
    Console(force_terminal=False)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo", json_output=True, no_color=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"


def test_complex_prompt(cli):
    """Test complex prompt with multiple features."""
    prompt = (
        "https://example.com/img1.jpg https://example.com/img2.jpg "
        "a {red, blue} bird on a {branch, rock} "
        f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
    )
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == PERMUTATION_COUNT_2X2
    for prompt in data:
        assert len(prompt["images"]) == IMAGE_PROMPTS_COUNT
        assert prompt["stylize"] == STYLIZE_VALUE
        assert prompt["chaos"] == CHAOS_VALUE
        assert prompt["aspect"] == f"{ASPECT_WIDTH}:{ASPECT_HEIGHT}"


def test_personalization_parameter(cli):
    """Test personalization parameter handling in different forms."""
    # Test flag form (--p)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --p", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] is None  # Flag parameters should be None

    # Test with code (--p CODE1)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --p CODE1", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] == ["CODE1"]

    # Test with multiple codes (--p "CODE1 CODE2")
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json('a photo --p "CODE1 CODE2"', json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] == ["CODE1", "CODE2"]


def test_numeric_range_permutations(cli):
    """Test handling of numeric parameters in permutations."""
    # Test stylize parameter range
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 2
    stylize_values = {prompt["stylize"] for prompt in data}
    assert stylize_values == {75, 300}

    # Test multiple numeric parameters
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --s {75, 300} --c {0, 50}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4  # 2x2 combinations
    stylize_values = {prompt["stylize"] for prompt in data}
    chaos_values = {prompt["chaos"] for prompt in data}
    assert stylize_values == {75, 300}
    assert chaos_values == {0, 50}


def test_nested_parameter_permutations(cli):
    """Test handling of nested permutations with parameters."""
    # Test personalization with nested options
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("smooth edges {, --p {, CODE1}} --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 6  # 3x2 combinations (no --p, empty --p, --p CODE1) x (75, 300)

    # Verify all combinations
    variants = [
        (None, 75),  # No --p, stylize 75
        (None, 300),  # No --p, stylize 300
        (True, 75),  # Empty --p, stylize 75
        (True, 300),  # Empty --p, stylize 300
        (["CODE1"], 75),  # --p with code, stylize 75
        (["CODE1"], 300),  # --p with code, stylize 300
    ]
    for prompt in data:
        assert prompt["text"] == "smooth edges"
        assert (prompt.get("personalization"), prompt["stylize"]) in variants

    # Test more complex nested permutations
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("smooth edges {, --p {, CODE1 CODE2}} --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 6  # 3x2 combinations

    # Verify all combinations
    variants = [
        (None, 75),  # No --p, stylize 75
        (None, 300),  # No --p, stylize 300
        (True, 75),  # Empty --p, stylize 75
        (True, 300),  # Empty --p, stylize 300
        (["CODE1", "CODE2"], 75),  # --p with codes, stylize 75
        (["CODE1", "CODE2"], 300),  # --p with codes, stylize 300
    ]
    for prompt in data:
        assert prompt["text"] == "smooth edges"
        assert (prompt.get("personalization"), prompt["stylize"]) in variants


def test_mj_command(cli):
    """Test Midjourney prompt conversion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.mj("a serene landscape --ar 16:9 --stylize 100", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)  # Changed from list to dict
    assert data["text"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_fal_command(cli):
    """Test Fal.ai prompt conversion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.fal("a serene landscape --ar 16:9 --stylize 100", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["prompt"] == "a serene landscape"
    assert data["aspect_ratio"] == "16:9"
    assert data["stylize"] == 100


def test_perm_command(cli):
    """Test permutation expansion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm("a {red, blue} bird on a {branch, rock}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4
    expected = [
        "a red bird on a branch",
        "a red bird on a rock",
        "a blue bird on a branch",
        "a blue bird on a rock",
    ]
    assert set(data) == set(expected)
</file>

<file path="tests/integration/test_workflow.py">
"""Integration tests for complete midjargon workflow."""

from __future__ import annotations

from __future__ import annotations

import sys
from io import StringIO

import pytest
from midjargon.cli.main import MidjargonCLI
from midjargon.engines.midjourney import (MidjourneyPrompt,
                                          parse_midjourney_dict)
from tests.cli.test_main import \
    parse_json_output  # Added import for JSON parsing

# Test constants
ASPECT_WIDTH = 16
ASPECT_HEIGHT = 9
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
WEIRD_VALUE = 1000
SEED_VALUE = 12345
STOP_VALUE = 80
IMAGE_WEIGHT_VALUE = 2.0
QUALITY_VALUE = 1.0
CHARACTER_WEIGHT_VALUE = 100
STYLE_WEIGHT_VALUE = 200
STYLE_VERSION_VALUE = 2
REPEAT_VALUE = 3
PERMUTATION_COUNT_2X2 = 4  # 2 options x 2 options
PERMUTATION_COUNT_2X2X2 = 8  # 2 options x 2 options x 2 options


def process_prompt(prompt: str) -> list[MidjourneyPrompt]:
    """Process a prompt through the complete workflow."""
    # Step 1: Expand permutations
    expanded = expand_midjargon_input(prompt)

    # Step 2: Parse each expanded prompt to a dictionary
    midjargon_dicts = [parse_midjargon_prompt_to_dict(p) for p in expanded]

    # Step 3: Convert each dictionary to a MidjourneyPrompt
    return [parse_midjourney_dict(d) for d in midjargon_dicts]


def test_basic_workflow():
    """Test basic prompt workflow without permutations."""
    prompt = f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "a beautiful landscape"
    assert result.aspect_width == ASPECT_WIDTH
    assert result.aspect_height == ASPECT_HEIGHT
    assert result.stylize == STYLIZE_VALUE


def test_permutation_workflow():
    """Test workflow with permutations."""
    prompt = f"a {{red, blue}} bird on a {{branch, rock}} --stylize {STYLIZE_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == PERMUTATION_COUNT_2X2  # 2x2 permutations
    texts = {r.text for r in results}
    expected = {
        "a red bird on a branch",
        "a red bird on a rock",
        "a blue bird on a branch",
        "a blue bird on a rock",
    }
    assert texts == expected
    assert all(r.stylize == STYLIZE_VALUE for r in results)


def test_image_workflow():
    """Test workflow with image URLs."""
    urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = f"{' '.join(urls)} abstract fusion --iw {IMAGE_WEIGHT_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "abstract fusion"
    assert len(result.image_prompts) == 2
    assert [p.url for p in result.image_prompts] == urls
    assert result.image_weight == IMAGE_WEIGHT_VALUE


def test_parameter_workflow():
    """Test workflow with various parameter types."""
    prompt = (
        "cyberpunk city --v 5.2 --style raw "
        f"--chaos {CHAOS_VALUE} --weird {WEIRD_VALUE} "
        f"--seed {SEED_VALUE} --stop {STOP_VALUE} "
        "--turbo --tile"
    )
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "cyberpunk city"
    assert result.version == "v5.2"
    assert result.style == "raw"
    assert result.chaos == CHAOS_VALUE
    assert result.weird == WEIRD_VALUE
    assert result.seed == SEED_VALUE
    assert result.stop == STOP_VALUE
    assert result.turbo is True
    assert result.tile is True


def test_new_parameters_workflow():
    """Test workflow with new parameter types."""
    prompt = (
        "portrait photo "
        f"--quality {QUALITY_VALUE} "
        f"--cw {CHARACTER_WEIGHT_VALUE} "
        f"--sw {STYLE_WEIGHT_VALUE} "
        f"--sv {STYLE_VERSION_VALUE} "
        f"--repeat {REPEAT_VALUE} "
        "--cref ref1.jpg ref2.jpg "
        "--sref style1.jpg style2.jpg "
        "--p custom_profile1 custom_profile2"
    )
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "portrait photo"
    assert result.quality == QUALITY_VALUE
    assert result.character_weight == CHARACTER_WEIGHT_VALUE
    assert result.style_weight == STYLE_WEIGHT_VALUE
    assert result.style_version == STYLE_VERSION_VALUE
    assert result.repeat == REPEAT_VALUE
    assert result.character_reference == ["ref1.jpg", "ref2.jpg"]
    assert result.style_reference == ["style1.jpg", "style2.jpg"]
    assert result.personalization == ["custom_profile1", "custom_profile2"]


def test_weighted_prompts_workflow():
    """Test workflow with weighted prompts."""
    prompt = "cyberpunk city::2 neon lights::1"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]
    assert result.text == "cyberpunk city::2 neon lights::1"


def test_error_workflow():
    """Test error handling in workflow."""
    # Test empty prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        process_prompt("")

    # Test whitespace-only prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        process_prompt("   ")

    # Test invalid parameter value - raises ValueError
    with pytest.raises(ValueError, match=r"Invalid numeric value for stylize: 2000"):
        process_prompt(f"photo --stylize {STYLIZE_VALUE * 20}")

    # Test invalid image URL - treated as extra parameter
    results = process_prompt("photo --image not_a_url")
    assert len(results) == 1
    assert len(results[0].image_prompts) == 0
    assert results[0].extra_params.get("image") == "not_a_url"


def test_complex_workflow():
    """Test workflow with multiple features combined."""
    prompt = (
        "https://example.com/img1.jpg https://example.com/img2.jpg "
        "a {vintage, modern} {portrait, landscape} "
        "with {warm, cool} tones "
        f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} "
        f"--chaos {CHAOS_VALUE} --v 5.2 --style raw "
        f"--quality {QUALITY_VALUE} --cw {CHARACTER_WEIGHT_VALUE} "
        "--turbo"
    )
    results = process_prompt(prompt)

    # 2x2x2 = 8 permutations
    assert len(results) == PERMUTATION_COUNT_2X2X2

    # Check common attributes
    for result in results:
        assert len(result.image_prompts) == 2
        assert result.aspect_width == ASPECT_WIDTH
        assert result.aspect_height == ASPECT_HEIGHT
        assert result.stylize == STYLIZE_VALUE
        assert result.chaos == CHAOS_VALUE
        assert result.version == "v5.2"
        assert result.style == "raw"
        assert result.quality == QUALITY_VALUE
        assert result.character_weight == CHARACTER_WEIGHT_VALUE
        assert result.turbo is True

    # Check text variations
    texts = {r.text for r in results}
    assert len(texts) == PERMUTATION_COUNT_2X2X2  # All combinations are unique


def test_permutations_with_parameters():
    """Test permutations with parameters are handled correctly."""
    prompt = "smooth edges {, --p} --s {75, 300}"
    results = process_prompt(prompt)

    assert len(results) == 4  # Should have 4 permutations

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (r.text.strip(), bool(r.personalization), r.stylize) for r in results
    }

    # Expected combinations
    expected = {
        ("smooth edges", False, 75),
        ("smooth edges", False, 300),
        ("smooth edges", True, 75),
        ("smooth edges", True, 300),
    }

    assert result_tuples == expected


def test_permutations_with_flag_parameters():
    """Test permutations with flag parameters (no value) are handled correctly."""
    prompt = "photo {, --tile} {, --turbo}"
    results = process_prompt(prompt)

    assert len(results) == 4  # Should have 4 permutations

    # Convert results to set of tuples for easier comparison
    result_tuples = {(r.text.strip(), r.tile is True, r.turbo is True) for r in results}

    # Expected combinations
    expected = {
        ("photo", False, False),
        ("photo", False, True),
        ("photo", True, False),
        ("photo", True, True),
    }

    assert result_tuples == expected


def test_permutations_with_complex_parameters():
    """Test permutations with complex parameter combinations."""
    prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
    results = process_prompt(prompt)

    assert len(results) == 8  # Should have 8 permutations (2 x 2 x 2)

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (
            r.text.strip(),
            r.personalization[0]
            if isinstance(r.personalization, list)
            else r.personalization,
            f"{r.aspect_width}:{r.aspect_height}",
            r.stylize,
        )
        for r in results
    }

    expected = {
        ("portrait modern", False, "1:1", 100),
        ("portrait modern", False, "16:9", 100),
        ("portrait modern", "custom", "1:1", 100),
        ("portrait modern", "custom", "16:9", 100),
        ("portrait vintage", False, "1:1", 100),
        ("portrait vintage", False, "16:9", 100),
        ("portrait vintage", "custom", "1:1", 100),
        ("portrait vintage", "custom", "16:9", 100),
    }

    assert result_tuples == expected


def test_cli_mj_command():
    """Test Midjourney prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.mj(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_cli_fal_command():
    """Test Fal.ai prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.fal(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["prompt"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_cli_perm_command():
    """Test permutation expansion using CLI."""
    cli = MidjargonCLI()
    prompt = "a {red, blue} bird on a {branch, rock}"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4
    assert "a red bird on a branch" in data
    assert "a red bird on a rock" in data
    assert "a blue bird on a branch" in data
    assert "a blue bird on a rock" in data
</file>

<file path="src/midjargon/engines/midjourney/parser.py">
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/parser.py
from __future__ import annotations

from typing import Any

from midjargon.core.models import MidjourneyParameters, MidjourneyPrompt
from midjargon.core.parameters import parse_parameters


class MidjourneyParser:
    """Parser for Midjourney prompts."""

    def __init__(self, prompt_dict: dict[str, Any] | None = None):
        """Initialize the parser.

        Args:
            prompt_dict: Optional dictionary containing prompt data.
        """
        self.prompt_dict = prompt_dict or {}
        self.prompt = MidjourneyPrompt(
            text=self.prompt_dict.get("text", ""),
            images=self.prompt_dict.get("images", []),
            parameters=MidjourneyParameters(**self.prompt_dict.get("parameters", {})),
        )

    def parse(self) -> MidjourneyPrompt:
        """Parse the prompt data into a MidjourneyPrompt object.

        Returns:
            A validated MidjourneyPrompt object.
        """
        return self.prompt

    @staticmethod
    def from_string(prompt_str: str) -> MidjourneyParser:
        """Create a parser from a prompt string.

        Args:
            prompt_str: The raw prompt string to parse.

        Returns:
            A MidjourneyParser instance.

        Raises:
            ValueError: If prompt parsing fails.
        """
        # Split into text and parameters
        if " --" in prompt_str:
            text_part, param_part = prompt_str.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg) from e
        else:
            text_part = prompt_str.strip()
            parameters = {}

        # Create prompt dictionary
        prompt_dict = {
            "text": text_part,
            "images": [],
            "parameters": parameters,
        }

        return MidjourneyParser(prompt_dict)
</file>

<file path="TODO.md">
---
this_file: TODO.md
---
# Midjargon Package Implementation Plan

## Priority 0: Python Version and Build System Fixes [IMMEDIATE]

### 0.1 Fix Python Version Compatibility [CRITICAL]
- [ ] Update Python version requirements in pyproject.toml
  - [ ] Change requires-python to ">=3.10" to match current environment
  - [ ] Update tool.ruff.target-version to "py310"
  - [ ] Update tool.mypy.python_version to "3.10"
  - [ ] Remove Python 3.10 from tool.hatch.envs.all.matrix (since we'll support it)
  - Detailed steps:
    1. [ ] Edit pyproject.toml:
       ```toml
       [project]
       requires-python = ">=3.10"
       
       [tool.ruff]
       target-version = "py310"
       
       [tool.mypy]
       python_version = "3.10"
       ```
    2. [ ] Update tool.hatch.envs.all.matrix to only include 3.11 and 3.12

### 0.2 Fix Build System Configuration [CRITICAL]
- [ ] Update build system dependencies
  - [ ] Verify hatchling and hatch-vcs versions
  - [ ] Add missing development dependencies
  - [ ] Fix dependency resolution issues
  - Detailed steps:
    1. [ ] Check and update build-system.requires versions
    2. [ ] Add any missing dev dependencies to tool.rye.dev-dependencies
    3. [ ] Verify all dependency versions are compatible

## Priority 1: Critical Model and Parser Fixes

### 1.1 Fix Pydantic Model Implementation [CRITICAL]
- [ ] Fix MidjourneyPrompt model validation issues
  - [ ] Fix character_reference and style_reference list validation
  - [ ] Ensure proper type conversion for list fields
  - [ ] Add proper validation for empty lists
  - [ ] Fix extra_params handling in model_dump()
  - [ ] Fix aspect ratio handling and validation
  - [ ] Fix computed_field for images property
  - [ ] Fix parameters property implementation
  - Detailed steps:
    1. [ ] Update src/midjargon/core/models.py:
       - [ ] Add proper validators for character_reference and style_reference
       - [ ] Implement proper type conversion for list fields
       - [ ] Add validation for empty lists with custom error messages
       - [ ] Fix model_dump() method to handle extra_params correctly
       - [ ] Add proper aspect ratio validation with regex pattern
       - [ ] Fix computed_field decorator usage for images property
       - [ ] Implement parameters property with proper caching

### 1.2 Fix Parameter Parsing [CRITICAL]
- [ ] Fix parse_parameters function
  - [ ] Fix type conversion for numeric parameters
  - [ ] Fix flag parameter handling (True/False values)
  - [ ] Fix list parameter parsing (character_reference, style_reference)
  - [ ] Fix aspect ratio parameter parsing
  - [ ] Add proper validation for all parameter types
  - [ ] Fix version parameter handling
  - Detailed steps:
    1. [ ] Update src/midjargon/core/parameters.py:
       - [ ] Add proper numeric type conversion with error handling
       - [ ] Implement consistent flag parameter handling
       - [ ] Fix list parameter parsing with proper delimiter handling
       - [ ] Add regex validation for aspect ratio
       - [ ] Add comprehensive parameter validation
       - [ ] Implement version parameter normalization

### 1.3 Fix Core Parser [CRITICAL]
- [ ] Fix parse_midjargon_prompt function
  - [ ] Fix parameter extraction and validation
  - [ ] Fix image URL extraction
  - [ ] Fix text part extraction
  - [ ] Add proper error handling and messages
  - [ ] Fix model instantiation with parameters
  - Detailed steps:
    1. [ ] Update src/midjargon/core/parser.py:
       - [ ] Implement robust parameter extraction
       - [ ] Add proper URL validation for images
       - [ ] Fix text extraction with proper escaping
       - [ ] Add detailed error messages
       - [ ] Fix model instantiation with validated parameters

## Priority 2: Code Quality Fixes

### 2.1 Fix Linting Issues
- [ ] Fix FBT001/FBT002 issues in CLI
  - [ ] Replace boolean positional arguments with proper flags
  - [ ] Use dataclasses or Pydantic models for CLI options
- [ ] Fix complexity issues
  - [ ] Refactor `parse_weighted_prompt` (C901)
  - [ ] Refactor `convert_parameter_value` (C901)
  - [ ] Refactor `parse_parameters` (C901)
- [ ] Fix error handling
  - [ ] Replace bare excepts with specific exception handling
  - [ ] Add proper error chaining with `raise ... from`
  - [ ] Add descriptive error messages

### 2.2 Fix Type Safety
- [ ] Add proper type hints throughout
- [ ] Fix unused arguments (ARG003)
- [ ] Add validation for all input parameters
- [ ] Add runtime type checking where necessary

## Priority 3: Core Functionality Fixes

### 3.1 Fix Permutation Handling
- [ ] Fix expand_midjargon_input function
  - [ ] Fix weighted prompt handling
  - [ ] Fix nested permutation groups
  - [ ] Fix whitespace handling
  - [ ] Fix escape character handling
  - [ ] Add proper validation for permutation syntax

### 3.2 Fix Input Processing
- [ ] Fix input validation and sanitization
  - [ ] Add proper URL validation
  - [ ] Fix multi-prompt handling
  - [ ] Fix weight parsing
  - [ ] Add proper input sanitization
  - [ ] Fix escape character handling

### 3.3 Fix CLI Implementation
- [ ] Fix command implementations
  - [ ] Fix 'mj' command
  - [ ] Fix 'fal' command
  - [ ] Fix 'perm' command
  - [ ] Fix JSON output formatting
  - [ ] Add proper error handling

## Priority 4: Engine-Specific Fixes

### 4.1 Fix Midjourney Engine
- [ ] Fix MidjourneyParser implementation
  - [ ] Fix parameter mapping
  - [ ] Fix type conversion
  - [ ] Fix validation
  - [ ] Fix reference handling

### 4.2 Fix Fal.ai Engine
- [ ] Fix FalParser implementation
  - [ ] Fix parameter mapping
  - [ ] Fix type conversion
  - [ ] Fix validation
  - [ ] Fix reference handling

## Priority 5: Testing and Documentation

### 5.1 Fix Test Suite
- [ ] Fix core functionality tests
  - [ ] Fix parameter parsing tests
  - [ ] Fix model validation tests
  - [ ] Fix permutation tests
  - [ ] Add missing edge cases

### 5.2 Update Documentation
- [ ] Update API documentation
  - [ ] Document model attributes
  - [ ] Document parameter handling
  - [ ] Document CLI commands
  - [ ] Add error handling guide

## Implementation Order

1. Start with Priority 0: Fix missing exports (IMMEDIATE)
   - This is blocking the test suite from running
   - Add missing exports to __init__.py

2. Move to Priority 1: Critical Model and Parser Fixes
   - Fix MidjourneyPrompt model validation issues
   - Fix parameter parsing
   - Fix core parser implementation

3. Address Priority 2: Code Quality Fixes
   - Fix linting issues
   - Improve type safety
   - Clean up error handling

4. Then proceed with remaining priorities in order

## Current Focus

The immediate focus should be on fixing the missing exports in __init__.py:
1. Add `expand_midjargon_input` to exports
2. Add `PromptVariant` to exports
3. Verify all necessary types and functions are exported

## Dependencies
- pydantic (>=2.0.0)
- rich (>=13.0.0)
- fire (>=0.5.0)
- python-box (>=7.3.2)
- fal-client (>=0.5.8)

## Development Guidelines
1. Maintain type safety
2. Follow code quality standards
3. Add comprehensive tests
4. Keep documentation updated
5. Consider performance
6. Handle errors gracefully

## Priority 0: Model Implementation Fixes [IMMEDIATE]

### 0.1 Fix MidjourneyPrompt Model [CRITICAL]
- [ ] Add missing methods to MidjourneyPrompt class
  - [ ] Implement `to_string()` method
  - [ ] Fix model validation for image references
  - [ ] Add proper attribute access for parameters
  - Detailed steps:
    1. [ ] Update src/midjargon/core/models.py:
       ```python
       def to_string(self) -> str:
           """Convert prompt back to string format."""
           parts = [self.text]
           if self.image_prompts:
               parts = [str(img) for img in self.image_prompts] + parts
           if self.parameters:
               parts.append(self.parameters.to_string())
           return " ".join(parts)
       ```
    2. [ ] Fix image reference validation in model definition
    3. [ ] Add proper parameter attribute access

### 0.2 Fix MidjourneyParameters Model [CRITICAL]
- [ ] Add missing attributes to MidjourneyParameters class
  - [ ] Add `aspect` property
  - [ ] Add `style_reference` handling
  - [ ] Add `character_reference` handling
  - [ ] Fix parameter validation
  - Detailed steps:
    1. [ ] Update parameter model in src/midjargon/core/models.py
    2. [ ] Add computed properties for convenience access
    3. [ ] Fix parameter validation rules

### 0.3 Fix Parameter Parsing [CRITICAL]
- [ ] Fix parameter parsing in core/parameters.py
  - [ ] Fix flag parameter handling
  - [ ] Fix numeric parameter validation
  - [ ] Fix reference parameter parsing
  - [ ] Add proper error handling
  - Detailed steps:
    1. [ ] Update parameter parsing logic
    2. [ ] Add proper validation for all parameter types
    3. [ ] Improve error messages

## Priority 1: CLI Implementation Fixes

### 1.1 Fix CLI Commands [HIGH]
- [ ] Fix CLI command implementations
  - [ ] Fix JSON output formatting
  - [ ] Fix command error handling
  - [ ] Fix parameter handling in commands
  - Detailed steps:
    1. [ ] Update src/midjargon/cli/main.py
    2. [ ] Fix JSON serialization
    3. [ ] Add proper error handling
    4. [ ] Fix parameter processing

### 1.2 Fix Integration Tests [HIGH]
- [ ] Fix integration test failures
  - [ ] Fix workflow tests
  - [ ] Fix CLI command tests
  - [ ] Fix parameter handling tests
  - Detailed steps:
    1. [ ] Update test assertions
    2. [ ] Fix test data
    3. [ ] Add missing test cases

## Priority 2: Core Functionality Fixes

### 2.1 Fix Permutation Handling
- [ ] Fix expand_midjargon_input function
  - [ ] Fix weighted prompt handling
  - [ ] Fix nested permutation groups
  - [ ] Fix whitespace handling
  - [ ] Fix escape character handling
  - [ ] Add proper validation for permutation syntax

### 2.2 Fix Input Processing
- [ ] Fix input validation and sanitization
  - [ ] Add proper URL validation
  - [ ] Fix multi-prompt handling
  - [ ] Fix weight parsing
  - [ ] Add proper input sanitization
  - [ ] Fix escape character handling

### 2.3 Fix CLI Implementation
- [ ] Fix command implementations
  - [ ] Fix 'mj' command
  - [ ] Fix 'fal' command
  - [ ] Fix 'perm' command
  - [ ] Fix JSON output formatting
  - [ ] Add proper error handling

### 2.4 Fix Engine-Specific Implementations
- [ ] Fix MidjourneyParser implementation
  - [ ] Fix parameter mapping
  - [ ] Fix type conversion
  - [ ] Fix validation
  - [ ] Fix reference handling

- [ ] Fix FalParser implementation
  - [ ] Fix parameter mapping
  - [ ] Fix type conversion
  - [ ] Fix validation
  - [ ] Fix reference handling

## Priority 3: Testing and Documentation

### 3.1 Fix Test Suite
- [ ] Fix core functionality tests
  - [ ] Fix parameter parsing tests
  - [ ] Fix model validation tests
  - [ ] Fix permutation tests
  - [ ] Add missing edge cases

### 3.2 Update Documentation
- [ ] Update API documentation
  - [ ] Document model attributes
  - [ ] Document parameter handling
  - [ ] Document CLI commands
  - [ ] Add error handling guide

## Implementation Order

1. Start with Priority 0: Fix missing exports (IMMEDIATE)
   - This is blocking the test suite from running
   - Add missing exports to __init__.py

2. Move to Priority 1: Critical Model and Parser Fixes
   - Fix MidjourneyPrompt model validation issues
   - Fix parameter parsing
   - Fix core parser implementation

3. Address Priority 2: Code Quality Fixes
   - Fix linting issues
   - Improve type safety
   - Clean up error handling

4. Then proceed with remaining priorities in order

## Current Focus

The immediate focus should be on fixing the missing exports in __init__.py:
1. Add `expand_midjargon_input` to exports
2. Add `PromptVariant` to exports
3. Verify all necessary types and functions are exported

## Dependencies
- pydantic (>=2.0.0)
- rich (>=13.0.0)
- fire (>=0.5.0)
- python-box (>=7.3.2)
- fal-client (>=0.5.8)

## Development Guidelines
1. Maintain type safety
2. Follow code quality standards
3. Add comprehensive tests
4. Keep documentation updated
5. Consider performance
6. Handle errors gracefully
</file>

<file path="src/midjargon/core/parameters.py">
#!/usr/bin/env python3
# this_file: src/midjargon/core/parameters.py
from __future__ import annotations

Handles parsing and validation of Midjourney prompt parameters.
This module provides a unified interface for parameter handling,
supporting both raw string parsing and structured parameter handling.
"""

from midjargon.core.models import (CharacterReference, MidjourneyVersion,
                                   StyleMode, StyleReference)
from pydantic import HttpUrl

# Parameter aliases mapping
ALIASES = {
    # Version aliases
    "v": "version",
    "ver": "version",
    "niji": "version",
    # Style aliases
    "s": "stylize",
    "c": "chaos",
    "w": "weird",
    # Seed aliases
    "sameseed": "seed",
    # Aspect ratio aliases
    "ar": "aspect_ratio",
    # Character reference aliases
    "cref": "character_reference",
    "sref": "style_reference",
    "cw": "character_weight",
    "sw": "style_weight",
    "sv": "style_version",
    # Repeat parameter
    "r": "repeat",
    # Mode flags
    "turbo": None,  # Flag parameter
    "relax": None,  # Flag parameter
    "video": None,  # Flag parameter
    "remix": None,  # Flag parameter
}

# Constants
NIJI_PREFIX_LENGTH = 4  # Length of "niji" in version string
SPECIAL_SEED_VALUES = {"random"}  # Special values for seed parameter

# Update the parameter aliases
PARAMETER_ALIASES = {
    "s": "stylize",
    "c": "chaos",
    "w": "weird",
    "iw": "image_weight",
    "ar": "aspect",
    "p": "personalization",
    "v": "version",
    "q": "quality",
    "cw": "character_weight",
    "sw": "style_weight",
    "sv": "style_version",
    "r": "repeat",
    "cref": "character_reference",
    "sref": "style_reference",
}


# Parameters that should remain as strings
STRING_PARAMS = {"aspect_ratio", "negative_prompt"}

# Parameters that should be integers
INT_PARAMS = {"style_version", "repeat"}

# Special seed values
SPECIAL_SEED_VALUES = {"random", "none"}

    Raises:
        ValueError: If name is empty or contains invalid characters.
    """
    if not name:
        msg = "Empty parameter name"
        raise ValueError(msg)
    if not isinstance(name, str):
        msg = f"Parameter name must be a string, got: {type(name)}"
        raise TypeError(msg)
    if not name.replace("-", "").replace("_", "").isalnum():
        msg = f"Invalid parameter name: {name}"
        raise ValueError(msg)
    if name.startswith("-"):
        msg = f"Parameter name cannot start with dash: {name}"
        raise ValueError(msg)


def validate_param_value(name: str, value: ParamValue) -> None:
    """
    Basic syntactic validation of a parameter value.
    Semantic validation is handled by the engine layer.

def convert_parameter_value(param: str, value: str | None) -> Any:
    """Convert a parameter value to the appropriate type."""
    # Handle flag parameters
    if param in FLAG_PARAMS:
        if value is None:
            return True
        val_lower = value.lower()
        if val_lower in {"true", "1", "yes", "on"}:
            return True
        if val_lower in {"false", "0", "no", "off"}:
            return False
        return bool(value)

    Raises:
        ValueError: If value has invalid syntax.
    """
    if value is None:
        return

    # Handle string parameters
    if param in STRING_PARAMS:
        return str(value)

    # Handle version parameter
    if param == "version":
        if value.lower() == "niji":
            return "niji"
        try:
            return MidjourneyVersion(value)
        except ValueError:
            msg = f"Invalid version value: {value}"
            raise ValueError(msg)

    # Handle seed parameter
    if param == "seed":
        if value.lower() in SPECIAL_SEED_VALUES:
            return value.lower()
        try:
            return int(value)
        except ValueError:
            msg = f"Invalid seed value: {value}"
            raise ValueError(msg)

    # Handle integer parameters
    if param in INT_PARAMS:
        try:
            return int(value)
        except ValueError:
            msg = f"Invalid integer value for {param}: {value}"
            raise ValueError(msg)

    # Validate numeric parameters can be converted to float
    if name in {
        "stylize",
        "chaos",
        "weird",
        "image_weight",
        "quality",
        "character_weight",
        "style_weight",
        "style_version",
        "repeat",
        "seed",
        "stop",
    }:
        try:
            float(value)
        except ValueError as e:
            msg = f"Invalid numeric value for {name}: {value}"
            raise ValueError(msg) from e

    # Handle style parameter
    if param == "style":
        try:
            return StyleMode(value)
        except ValueError:
            msg = f"Invalid style value: {value}"
            raise ValueError(msg)

    # Handle character and style references
    if param in {"character_reference", "style_reference"}:
        ref_class = (
            CharacterReference if param == "character_reference" else StyleReference
        )
        try:
            if is_url(value):
                return ref_class(url=HttpUrl(value), weight=1.0)
            else:
                # Handle reference codes (e.g., p123456)
                return ref_class(code=value, weight=1.0)
        except Exception as e:
            msg = f"Invalid reference value for {param}: {value} ({e!s})"
            raise ValueError(msg)

    # Default case: return as string
    return value


def parse_parameters(param_str: str) -> dict[str, Any]:
    """Parse parameters from a string into a dictionary."""
    if not param_str:
        return []

    # Handle empty parameter case
    if param_str == "--":
        msg = "Empty parameter name"
        raise ValueError(msg)

    chunks = []
    current_chunk = []
    in_quotes = False
    quote_char = None
    current_param = None

    for char in param_str:
        if char in {'"', "'"}:
            if not in_quotes:
                in_quotes = True
                quote_char = char
            elif char == quote_char:
                in_quotes = False
                quote_char = None
            current_chunk.append(char)
        elif char.isspace() and not in_quotes:
            if current_chunk:
                chunk_str = "".join(current_chunk)
                if chunk_str.startswith("--"):
                    if current_param:
                        chunks.append(current_param)
                    current_param = chunk_str
                elif current_param:
                    current_param = f"{current_param} {chunk_str}"
                else:
                    current_param = chunk_str
                current_chunk = []
        else:
            current_chunk.append(char)

    # Handle last chunk
    if current_chunk:
        chunk_str = "".join(current_chunk)
        if chunk_str.startswith("--"):
            if current_param:
                chunks.append(current_param)
            current_param = chunk_str
        elif current_param:
            current_param = f"{current_param} {chunk_str}"
        else:
            current_param = chunk_str

    if current_param:
        chunks.append(current_param)

    return chunks


def _process_param_chunk(
    chunk: str, params: dict[str, str | list[str] | None]
) -> tuple[str, str | list[str] | None]:
    """
    Process a parameter chunk into name and value.

    Args:
        chunk: Parameter chunk to process.
        params: Dictionary to store parameters in.

    Returns:
        Tuple of parameter name and value.

    Raises:
        ValueError: If chunk has invalid syntax or missing required value.
    """
    if not chunk or chunk == "--":
        msg = "Empty parameter name"
        raise ValueError(msg)

    # Split on first double dash
    parts = chunk.split("--", 1)
    if len(parts) != 2:
        msg = f"Parameter name cannot start with dash: {chunk}"
        raise ValueError(msg)

    # Split parameter name and value
    param_parts = parts[1].split(maxsplit=1)
    name = param_parts[0].lower()
    expanded_name = PARAMETER_ALIASES.get(name, name)

    # Define flag parameters that don't require values
    flag_params = {"tile", "turbo", "relax", "video", "remix"}

    # Handle flag parameters (no value)
    if len(param_parts) == 1:
        if expanded_name in {"personalization", "p"}:
            return "personalization", None
        if expanded_name == "niji":
            return "version", "niji"
        if expanded_name in flag_params:
            return expanded_name, None
        # For non-flag parameters, raise error if value is missing
        msg = f"Missing value for parameter: {name}"
        raise ValueError(msg)

    # Get value part (everything after the first space)
    value = param_parts[1]

    # Process the value based on parameter type
    if expanded_name in {"personalization", "p"}:
        # Return list of space-separated values for personalization codes
        # Handle quoted values
        if (value.startswith('"') and value.endswith('"')) or (
            value.startswith("'") and value.endswith("'")
        ):
            value = value[1:-1]  # Remove quotes
        return "personalization", value.split() if value else None
    elif expanded_name in {"character_reference", "cref"}:
        if value.startswith("<") and value.endswith(">"):
            return "character_reference", [value]
        if value.startswith('"') and value.endswith('"'):
            return "character_reference", [value[1:-1]]
        if value.startswith("'") and value.endswith("'"):
            return "character_reference", [value[1:-1]]
        return "character_reference", value.split()
    elif expanded_name in {"style_reference", "sref"}:
        # Return list of values for style references; if enclosed in angle brackets, treat as single value
        if value.startswith("<") and value.endswith(">"):
            return "style_reference", [value]
        if value.startswith('"') and value.endswith('"'):
            return "style_reference", [value[1:-1]]
        if value.startswith("'") and value.endswith("'"):
            return "style_reference", [value[1:-1]]
        return "style_reference", value.split()
    elif expanded_name == "version" or name == "v":
        # Handle version parameter
        if value.startswith("v"):
            value = value[1:]  # Strip 'v' prefix
        return "version", value
    elif expanded_name == "niji":
        # Handle niji version without adding 'v' prefix; store under key 'version'
        if value.startswith("v"):
            value = value[1:]
        return "version", f"niji {value}"
    else:
        # Handle quoted values for other parameters
        if (value.startswith('"') and value.endswith('"')) or (
            value.startswith("'") and value.endswith("'")
        ):
            value = value[1:-1]  # Remove quotes
        # All other parameters are returned as strings
        return expanded_name, value


def _process_current_param(
    current_param: str | None,
    current_values: list[str],
    params: ParamDict,
) -> None:
    """Process and store the current parameter."""
    if current_param is None:
        return
    if current_param == "":
        msg = "Empty parameter name"
        raise ValueError(msg)

    # Validate that required parameters have values
    expanded_name, is_flag = expand_shorthand_param(current_param)

    # Special handling for personalization parameter
    if expanded_name == "personalization":
        if not current_values:
            params[expanded_name] = None  # None for flag usage
            return
        value = process_param_value(current_values)
        validate_param_value(expanded_name, value)
        params[expanded_name] = value
        return

    # Special handling for niji parameter
    if expanded_name == "niji":
        if not current_values:
            params["version"] = "niji"  # Just niji without version
            return
        value = process_param_value(current_values)
        if isinstance(value, str):
            if value.startswith("v"):
                value = value[1:]  # Strip 'v' prefix if present
            params["version"] = f"niji {value}"  # niji with version
        return

    # Regular parameter handling
    if not is_flag and not current_values:
        msg = f"Missing value for parameter: {current_param}"
        raise ValueError(msg)

    # Process and store the parameter
    value = process_param_value(current_values)
    validate_param_value(expanded_name, value)
    if expanded_name == "version":
        if isinstance(value, str):
            if value.startswith("v"):
                value = value[1:]  # Strip 'v' prefix if present
            params[expanded_name] = value
    else:
        params[expanded_name] = value


def parse_parameters(param_str: str) -> dict[str, str | list[str] | None]:
    """
    Parse parameter string into a dictionary.

    Args:
        param_str: Parameter string to parse.

    Returns:
        Dictionary of parameter names and values.

    Raises:
        ValueError: If parameter string has invalid syntax.
    """
    if not param_str:
        return {}

    params: dict[str, str | list[str] | None] = {}
    chunks = _split_param_chunks(param_str)

    for chunk in chunks:
        name, value = _process_param_chunk(chunk, params)
        params[name] = value

    return params
</file>

<file path="src/midjargon/cli/main.py">
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["fire", "rich", "pydantic"]
# ///
from __future__ import annotations

"""
midjargon.cli.main
~~~~~~~~~~~~~~~~~

A CLI tool that parses and validates Midjourney prompts.
Supports both raw parsing and Midjourney-specific validation.
"""

import json
import sys
from typing import TYPE_CHECKING, Any

import fire
from midjargon.core.input import expand_midjargon_input
from midjargon.engines.fal import FalParser
from midjargon.engines.midjourney import MidjourneyParser
from rich.console import Console

if TYPE_CHECKING:
    from collections.abc import Sequence

    from midjargon.core.models import PromptVariant


def _handle_error(console: Console, error: Exception) -> NoReturn:
    """Handle errors by printing to stderr and exiting."""
    error_console = Console(stderr=True)
    error_console.print(f"Error: {error!s}", style="red")
    sys.exit(1)


def _output_json(data: Any) -> None:
    """Output data as formatted JSON without any Rich formatting."""
    sys.stdout.write(json.dumps(data, indent=2))
    sys.stdout.flush()


def _format_prompt(prompt: Any) -> str:
    """Format a prompt for display."""
    if hasattr(prompt, "model_dump"):
        return json.dumps(prompt.model_dump(), indent=2)
    return json.dumps(prompt, indent=2)


class MidjargonCLI:
    """Midjargon CLI interface."""

    def perm(
        self,
        prompt: str,
        *,
        json_output: bool = False,
        no_color: bool = False,
    ) -> None:
        """
        Permute a prompt string, expanding all permutation markers.

        Args:
            prompt: The prompt string to permute.
            json_output: If True, output in JSON format (alias: -j).
            no_color: If True, disable colored output.

        Example prompts:
            "A {red, blue, green} bird on a {branch, rock}"
            "elephant {, --s {200, 300}}"
        """
        console = Console(force_terminal=not no_color)

        try:
            results = permute_prompt(prompt)

            if json_output:
                _output_json(results)
                return

            for i, result in enumerate(results, 1):
                if len(results) > 1:
                    console.print(f"\nVariant {i}:", style="bold blue")
                console.print(Panel(result))

        except (
            ValueError,
            TypeError,
            SyntaxError,
        ) as error:  # More specific exceptions
            if json_output:
                _output_json({"error": str(error)})
                sys.exit(1)
            else:
                _handle_error(console, error)

    def json(
        self,
        prompt: str,
        *,
        json_output: bool = True,
        no_color: bool = False,
    ) -> None:
        """
        Parse a prompt into MidjargonDict format.

        Args:
            prompt: The prompt string to parse.
            json_output: If True, output in JSON format (alias: -j).
            no_color: If True, disable colored output.

        Example prompts:
            "A portrait of a wise old man --style raw --v 5.1"
            "A {red, blue, green} bird on a {branch, rock} --ar 16:9"
        """
        console = Console(force_terminal=not no_color)

        try:
            # Always expand permutations to ensure consistent behavior with other commands
            results = parse_prompt(prompt, permute=True)

            # If there are no permutations (result is a single-item list), return just the dict
            if isinstance(results, list) and len(results) == 1:
                results = results[0]

            if json_output:
                _output_json(results)
                return

            if isinstance(results, list):
                for i, result in enumerate(results, 1):
                    if len(results) > 1:
                        console.print(f"\nVariant {i}:", style="bold blue")
                    console.print(Panel(_format_prompt(result)))
            else:
                console.print(Panel(_format_prompt(results)))

        except (
            ValueError,
            TypeError,
            SyntaxError,
        ) as error:  # More specific exceptions
            if json_output:
                _output_json({"error": str(error)})
                sys.exit(1)
            else:
                _handle_error(console, error)

    def mj(
        self,
        prompt: str,
        *,
        json_output: bool = False,
        no_color: bool = False,
    ) -> None:
        """
        Convert a prompt to Midjourney format.

        Args:
            prompt: The prompt string to convert.
            json_output: If True, output in JSON format (alias: -j).
            no_color: If True, disable colored output.

        Example prompts:
            "A portrait of a wise old man --style raw --v 5.1"
            "A {red, blue, green} bird on a {branch, rock} --ar 16:9"
        """
        console = Console(force_terminal=not no_color)

        try:
            results = to_midjourney_prompts(prompt)

            if json_output:
                if isinstance(results, list):
                    json_results = [prompt.model_dump() for prompt in results]
                else:
                    json_results = results.model_dump()
                _output_json(json_results)
                return

            if isinstance(results, list):
                for i, result in enumerate(results, 1):
                    if len(results) > 1:
                        console.print(f"\nVariant {i}:", style="bold blue")
                    console.print(Panel(_format_prompt(result)))
            else:
                console.print(Panel(_format_prompt(results)))

        except (
            ValueError,
            TypeError,
            SyntaxError,
        ) as error:  # More specific exceptions
            if json_output:
                _output_json({"error": str(error)})
                sys.exit(1)
            else:
                _handle_error(console, error)

    def fal(
        self,
        prompt: str,
        *,
        json_output: bool = False,
        no_color: bool = False,
    ) -> None:
        """
        Convert a prompt to Fal.ai format.

        Args:
            prompt: The prompt string to convert.
            json_output: If True, output in JSON format (alias: -j).
            no_color: If True, disable colored output.

        Example prompts:
            "A portrait of a wise old man --style raw --v 5.1"
            "A {red, blue, green} bird on a {branch, rock} --ar 16:9"
        """
        console = Console(force_terminal=not no_color)

        try:
            results = to_fal_dicts(prompt)

            if json_output:
                _output_json(results)
                return

            if isinstance(results, list):
                for i, result in enumerate(results, 1):
                    if len(results) > 1:
                        console.print(f"\nVariant {i}:", style="bold blue")
                    console.print(Panel(_format_prompt(result)))
            else:
                console.print(Panel(_format_prompt(results)))

        except (
            ValueError,
            TypeError,
            SyntaxError,
        ) as error:  # More specific exceptions
            if json_output:
                _output_json({"error": str(error)})
                sys.exit(1)
            else:
                _handle_error(console, error)


def main() -> None:
    from rich.ansi import AnsiDecoder
    from rich.console import Console, Group
    from rich.theme import Theme
    from rich.traceback import install

    install(show_locals=True)
    ansi_decoder = AnsiDecoder()
    console = Console(theme=Theme({"prompt": "cyan", "question": "bold cyan"}))

    def display(lines, out):
        console.print(Group(*map(ansi_decoder.decode_line, lines)))

    fire.core.Display = display

    """Run the CLI application."""
    fire.Fire(MidjargonCLI())


if __name__ == "__main__":
    main()
</file>

</files>
