# Folder Tree Structure

.
├── ERRORS.txt
├── LICENSE
├── LOG.md
├── README.md
├── TODO.md
├── dist
├── docs
│   └── specification.md
├── examples
│   └── basic_usage.py
├── package.toml
├── pyproject.toml
├── src
│   └── midjargon
│       ├── __init__.py
│       ├── cli
│       │   ├── __init__.py
│       │   └── main.py
│       ├── core
│       │   ├── __init__.py
│       │   ├── input.py
│       │   ├── main.py
│       │   ├── models.py
│       │   ├── parameters.py
│       │   ├── parser.py
│       │   └── permutations.py
│       └── engines
│           ├── __init__.py
│           ├── fal
│           │   ├── __init__.py
│           │   └── fal.py
│           └── midjourney
│               ├── __init__.py
│               ├── midjourney.py
│               └── parser.py
├── test-cases
│   ├── prompts-fal.txt
│   ├── prompts-in.txt
│   ├── prompts-json.txt
│   ├── prompts-mj.txt
│   ├── prompts-out.txt
│   ├── prompts-perm.txt
│   └── prompts.sh
├── tests
│   ├── __init__.py
│   ├── cli
│   │   ├── __init__.py
│   │   └── test_main.py
│   ├── conftest.py
│   ├── core
│   │   ├── __init__.py
│   │   ├── test_input.py
│   │   ├── test_parameters.py
│   │   └── test_parser.py
│   ├── engines
│   │   ├── __init__.py
│   │   └── midjourney
│   │       ├── __init__.py
│   │       └── test_midjourney_parser.py
│   ├── integration
│   │   ├── __init__.py
│   │   └── test_workflow.py
│   ├── test_core.py
│   └── test_package.py
└── updateme.sh

18 directories, 48 files



# Folder: .

## File: .cursor/rules/midjargon.mdc (Size: 3.53 KB)

```
---
description: "Midjargon configuration documentation for folder structure."
globs: []
---

Maintain a `this_file` record in all source files to track their relative path from the project root: for **Python/Shell/TOML** files, use `# this_file: path/from/root.ext` as the first comment (after any shebang line `#!`), and for **Markdown** files, include `this_file: path/from/root.md` in the YAML front matter block at the document start. Update paths when moving files. Keep the entry as the first metadata element. Use Unix-style `/` path separators. Omit leading `./` in paths. *Example:* A Python file in `src/utils` would start with `#!/usr/bin/env python3\n# this_file: src/utils/helpers.py`.

# `midjargon`

`midjargon` is a hatch-managed Python library for parsing and manipulating Midjourney prompts using a specialized syntax. This tool helps you work with Midjourney prompts in a structured way, handling complex features like permutations, parameter validation, and image URL extraction.

<guidelines for python>
1. WHEN YOU WRITE PYTHON: 

a. CORE STYLE: Follow PEP 8 for consistent formatting & naming. Write clear, descriptive names for functions & variables. Keep code simple & explicit (PEP 20). Prioritize readability over cleverness. 
b. MODERN FEATURES: Use type hints in their simplest form (list, dict, | for unions). Write clear, imperative docstrings (PEP 257). Employ f-strings for string formatting. Use structural pattern matching where appropriate. 
c. CODE STRUCTURE: Extract repeated logic into focused functions. Handle errors explicitly and gracefully. Keep functions small and single-purpose. Prefer flat over nested structures. 
d. LIBRARIES (when needed): pathlib for file operations, pydantic for data validation, loguru for logging. Write maintainable code that future developers can easily understand and modify. 
e. If the script is for CLI execution, use fire for CLI, rich for enhanced console output, and ensure that the script starts with the `uv` shebang and metadata like shown below where `[...]` is a list of Python dependency specifiers, like `["fire", "rich"]`: 

```
#!/usr/bin/env -S uv run 
# /// script
# dependencies = [...]
# ///
```

f. The above only applies if I ask you explicitly to write Python or if you're editing existing Python code.
</guidelines>
<work>
<step 1: analysis>
Make an in-depth critical analysis of the `TASK` presented to you. Read the content of the @TODO.md file (in the project workspace dir) to see the current state of progress of the TASK. Then make an in-depth critical analysis of the inputs presented. 
</step>
<step 2: gather up-to-date insights>
Consult the @Web if you can. Consult the most up-to-date @Docs and run `hatch fmt; hatch test`. 
</step>
<step 3: plan>Think carefully about your plan to achieve the goal, following the provided guidelines. Write out general principles, then propose specific changes. 
</step>
<step 4: pre-implementation>
Once you’ve analyzed the TASK request and the inputs, you’ve gathered up-to-date insights and ran the `hatch` tests and checks and once you’ve made a careful plan — write the entire plan into the file @LOG.md (in the project workspace folder) — be very detailed and specific. 
</step>
<step 5: implementation>
You can start implementing the plan. Whenever you’ve made larger edits to Python files, run `hatch fmt; hatch test` to see how your changes impacted the @Codebase , then refine your plan. Keep progress documentation in @LOG.md (in the project workspace folder) , remove completed items. Work until you CLEAR the @TODO.md !     
</step>
</work>
```

## File: .github/copilot-instructions.md (Size: 3.43 KB)

```

Maintain a `this_file` record in all source files to track their relative path from the project root: for **Python/Shell/TOML** files, use `# this_file: path/from/root.ext` as the first comment (after any shebang line `#!`), and for **Markdown** files, include `this_file: path/from/root.md` in the YAML front matter block at the document start. Update paths when moving files. Keep the entry as the first metadata element. Use Unix-style `/` path separators. Omit leading `./` in paths. *Example:* A Python file in `src/utils` would start with `#!/usr/bin/env python3\n# this_file: src/utils/helpers.py`.

# `midjargon`

`midjargon` is a hatch-managed Python library for parsing and manipulating Midjourney prompts using a specialized syntax. This tool helps you work with Midjourney prompts in a structured way, handling complex features like permutations, parameter validation, and image URL extraction.

<guidelines for python>
1. WHEN YOU WRITE PYTHON: 

a. CORE STYLE: Follow PEP 8 for consistent formatting & naming. Write clear, descriptive names for functions & variables. Keep code simple & explicit (PEP 20). Prioritize readability over cleverness. 
b. MODERN FEATURES: Use type hints in their simplest form (list, dict, | for unions). Write clear, imperative docstrings (PEP 257). Employ f-strings for string formatting. Use structural pattern matching where appropriate. 
c. CODE STRUCTURE: Extract repeated logic into focused functions. Handle errors explicitly and gracefully. Keep functions small and single-purpose. Prefer flat over nested structures. 
d. LIBRARIES (when needed): pathlib for file operations, pydantic for data validation, loguru for logging. Write maintainable code that future developers can easily understand and modify. 
e. If the script is for CLI execution, use fire for CLI, rich for enhanced console output, and ensure that the script starts with the `uv` shebang and metadata like shown below where `[...]` is a list of Python dependency specifiers, like `["fire", "rich"]`: 

```
#!/usr/bin/env -S uv run 
# /// script
# dependencies = [...]
# ///
```

f. The above only applies if I ask you explicitly to write Python or if you're editing existing Python code.
</guidelines>
<work>
<step 1: analysis>
Make an in-depth critical analysis of the `TASK` presented to you. Read the content of the @TODO.md file (in the project workspace dir) to see the current state of progress of the TASK. Then make an in-depth critical analysis of the inputs presented. 
</step>
<step 2: gather up-to-date insights>
Consult the @Web if you can. Consult the most up-to-date @Docs and run `hatch fmt; hatch test`. 
</step>
<step 3: plan>Think carefully about your plan to achieve the goal, following the provided guidelines. Write out general principles, then propose specific changes. 
</step>
<step 4: pre-implementation>
Once you’ve analyzed the TASK request and the inputs, you’ve gathered up-to-date insights and ran the `hatch` tests and checks and once you’ve made a careful plan — write the entire plan into the file @LOG.md (in the project workspace folder) — be very detailed and specific. 
</step>
<step 5: implementation>
You can start implementing the plan. Whenever you’ve made larger edits to Python files, run `hatch fmt; hatch test` to see how your changes impacted the @Codebase , then refine your plan. Keep progress documentation in @LOG.md (in the project workspace folder) , remove completed items. Work until you CLEAR the @TODO.md !     
</step>
</work>
```

## File: .github/workflows/push.yml (Size: 2.70 KB)

```
name: Build & Test

on:
  push:
    branches: [main]
    tags-ignore: ["v*"]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Ruff lint
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "check --output-format=github"

      - name: Run Ruff Format
        uses: astral-sh/ruff-action@v3
        with:
          version: "latest"
          args: "format --check --respect-gitignore"

  test:
    name: Run Tests
    needs: quality
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]
        os: [ubuntu-latest]
      fail-fast: true
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: ${{ matrix.python-version }}
          enable-cache: true
          cache-suffix: ${{ matrix.os }}-${{ matrix.python-version }}

      - name: Install test dependencies
        run: |
          uv pip install --system --upgrade pip
          uv pip install --system ".[test]"

      - name: Run tests with Pytest
        run: uv run pytest -n auto --maxfail=1 --disable-warnings --cov-report=xml --cov-config=pyproject.toml --cov=src/midjargon --cov=tests tests/

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}-${{ matrix.os }}
          path: coverage.xml

  build:
    name: Build Distribution
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist/
          retention-days: 5
```

## File: .github/workflows/release.yml (Size: 1.41 KB)

```
name: Release

on:
  push:
    tags: ["v*"]

permissions:
  contents: write
  id-token: write

jobs:
  release:
    name: Release to PyPI
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/midjargon
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install UV
        uses: astral-sh/setup-uv@v5
        with:
          version: "latest"
          python-version: "3.12"
          enable-cache: true

      - name: Install build tools
        run: uv pip install build hatchling hatch-vcs

      - name: Build distributions
        run: uv run python -m build --outdir dist

      - name: Verify distribution files
        run: |
          ls -la dist/
          test -n "$(find dist -name '*.whl')" || (echo "Wheel file missing" && exit 1)
          test -n "$(find dist -name '*.tar.gz')" || (echo "Source distribution missing" && exit 1)

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_TOKEN }}

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## File: .gitignore (Size: 3.42 KB)

```
!**/[Pp]ackages/build/
!.axoCover/settings.json
!.vscode/extensions.json
!.vscode/launch.json
!.vscode/settings.json
!.vscode/tasks.json
!?*.[Cc]ache/
!Directory.Build.rsp
!dist/.gitkeep
$tf/
*$py.class
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.HTMLClient/GeneratedArtifacts
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
**/[Pp]ackages/*
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl
*- [Bb]ackup.rdl
*.[Cc]ache
*.[Pp]ublish.xml
*.[Rr]e[Ss]harper
*.a
*.app
*.appx
*.appxbundle
*.appxupload
*.aps
*.azurePubxml
*.bim.layout
*.bim_*.settings
*.binlog
*.btm.cs
*.btp.cs
*.build.csdef
*.cab
*.cachefile
*.code-workspace
*.cover
*.coverage
*.coveragexml
*.d
*.dbmdl
*.dbproj.schemaview
*.dll
*.dotCover
*.DotSettings.user
*.dsp
*.dsw
*.dylib
*.e2e
*.egg
*.egg-info/
*.exe
*.gch
*.GhostDoc.xml
*.gpState
*.ilk
*.iobj
*.ipdb
*.jfm
*.jmconfig
*.la
*.lai
*.ldf
*.lib
*.lo
*.log
*.mdf
*.meta
*.mm.*
*.mod
*.msi
*.msix
*.msm
*.msp
*.ncb
*.ndf
*.nuget.props
*.nuget.targets
*.nupkg
*.nvuser
*.o
*.obj
*.odx.cs
*.opendb
*.opensdf
*.opt
*.out
*.pch
*.pdb
*.pfx
*.pgc
*.pgd
*.pidb
*.plg
*.psess
*.publishproj
*.publishsettings
*.pubxml
*.py,cover
*.py[cod]
*.pyc
*.rdl.data
*.rptproj.bak
*.rptproj.rsuser
*.rsp
*.rsuser
*.sap
*.sbr
*.scc
*.sdf
*.sln.docstates
*.sln.iml
*.slo
*.smod
*.snupkg
*.so
*.suo
*.svclog
*.swo
*.swp
*.tlb
*.tlh
*.tli
*.tlog
*.tmp
*.tmp_proj
*.tss
*.user
*.userosscache
*.userprefs
*.vbp
*.vbw
*.VC.db
*.VC.VC.opendb
*.VisualState.xml
*.vsp
*.vspscc
*.vspx
*.vssscc
*.xsd.cs
*_autogen/
*_h.h
*_i.c
*_p.c
*_wpftmp.csproj
*~
.*crunch*.local.xml
._*
.axoCover/*
.builds
.cache
.coverage
.coverage.*
.cr/personal
.DS_Store
.DS_Store?
.eggs/
.env
.fake/
.history/
.hypothesis/
.idea/
.installed.cfg
.ionide/
.localhistory/
.mfractor/
.mypy_cache/
.nox/
.ntvs_analysis.dat
.paket/paket.exe
.pytest_cache/
.Python
.ruff_cache/
.sass-cache/
.Spotlight-V100
.tox/
.Trashes
.venv
.vs/
.vscode
.vscode/
.vscode/*
.vshistory/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
[Bb]in/
[Bb]uild[Ll]og.*
[Dd]ebug/
[Dd]ebugPS/
[Dd]ebugPublic/
[Ee]xpress/
[Ll]og/
[Ll]ogs/
[Oo]bj/
[Rr]elease/
[Rr]eleasePS/
[Rr]eleases/
[Tt]est[Rr]esult*/
[Ww][Ii][Nn]32/
__pycache__/
__version__.py
_Chutzpah*
_deps
_NCrunch_*
_pkginfo.txt
_Pvt_Extensions
_ReSharper*/
_TeamCity*
_UpgradeReport_Files/
AppPackages/
artifacts/
ASALocalRun/
AutoTest.Net/
Backup*/
BenchmarkDotNet.Artifacts/
bld/
build/
BundleArtifacts/
ClientBin/
cmake_install.cmake
CMakeCache.txt
CMakeFiles
CMakeLists.txt.user
CMakeScripts
CMakeUserPresets.json
compile_commands.json
cover/
coverage*.info
coverage*.json
coverage*.xml
coverage.xml
csx/
CTestTestfile.cmake
develop-eggs/
dlldata.c
DocProject/buildhelp/
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/*.HxC
DocProject/Help/*.HxT
DocProject/Help/html
DocProject/Help/Html2
downloads/
ecf/
eggs/
ehthumbs.db
env.bak/
env/
ENV/
FakesAssemblies/
FodyWeavers.xsd
Generated\ Files/
Generated_Code/
healthchecksdb
htmlcov/
install_manifest.txt
ipch/
lib/
lib64/
Makefile
MANIFEST
MigrationBackup/
mono_crash.*
nCrunchTemp_*
node_modules/
nosetests.xml
nunit-*.xml
OpenCover/
orleans.codegen.cs
Package.StoreAssociation.xml
paket-files/
parts/
project.fragment.lock.json
project.lock.json
publish/
PublishScripts/
rcf/
ScaffoldingReadMe.txt
sdist/
ServiceFabricBackup/
StyleCopReport.xml
Testing
TestResult.xml
Thumbs.db
UpgradeLog*.htm
UpgradeLog*.XML
var/
venv.bak/
venv/
wheels/
x64/
x86/
~$*
.aider*
/_private

_private
```

## File: .pre-commit-config.yaml (Size: 0.52 KB)

```
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.3.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format
        args: [--respect-gitignore]
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.5.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-toml
      - id: check-added-large-files
      - id: debug-statements
      - id: check-case-conflict
      - id: mixed-line-ending
        args: [--fix=lf]
```

## File: ERRORS.txt (Size: 185.85 KB)

```
cmd [1] | fd -e py -x pyupgrade --keep-runtime-typing --py310-plus
cmd [2] | ruff format .
32 files left unchanged
cmd [3] | ruff check --fix --unsafe-fixes .
src/midjargon/cli/main.py:39:33: FBT001 Boolean-typed positional argument in function definition
   |
37 |     """CLI interface for midjargon."""
38 |
39 |     def json(self, prompt: str, no_color: bool = False) -> None:
   |                                 ^^^^^^^^ FBT001
40 |         """Parse a prompt to MidjargonDict format.
   |

src/midjargon/cli/main.py:39:33: FBT002 Boolean default positional argument in function definition
   |
37 |     """CLI interface for midjargon."""
38 |
39 |     def json(self, prompt: str, no_color: bool = False) -> None:
   |                                 ^^^^^^^^ FBT002
40 |         """Parse a prompt to MidjargonDict format.
   |

src/midjargon/cli/main.py:54:28: FBT001 Boolean-typed positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT001
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:54:28: FBT002 Boolean default positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT002
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:54:55: FBT001 Boolean-typed positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT001
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:54:55: FBT002 Boolean default positional argument in function definition
   |
53 |     def mj(
54 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT002
55 |     ) -> None:
56 |         """Convert a prompt to Midjourney format.
   |

src/midjargon/cli/main.py:92:28: FBT001 Boolean-typed positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT001
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:92:28: FBT002 Boolean default positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                            ^^^^^^^^^^^ FBT002
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:92:55: FBT001 Boolean-typed positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT001
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:92:55: FBT002 Boolean default positional argument in function definition
   |
91 |     def fal(
92 |         self, prompt: str, json_output: bool = False, no_color: bool = False
   |                                                       ^^^^^^^^ FBT002
93 |     ) -> None:
94 |         """Convert a prompt to Fal.ai format.
   |

src/midjargon/cli/main.py:124:28: FBT001 Boolean-typed positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                            ^^^^^^^^^^^ FBT001
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/cli/main.py:124:28: FBT002 Boolean default positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                            ^^^^^^^^^^^ FBT002
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/cli/main.py:124:55: FBT001 Boolean-typed positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                                                       ^^^^^^^^ FBT001
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/cli/main.py:124:55: FBT002 Boolean default positional argument in function definition
    |
123 |     def perm(
124 |         self, prompt: str, json_output: bool = False, no_color: bool = False
    |                                                       ^^^^^^^^ FBT002
125 |     ) -> None:
126 |         """Expand permutations in a prompt.
    |

src/midjargon/core/input.py:8:5: C901 `parse_weighted_prompt` is too complex (12 > 10)
  |
8 | def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
  |     ^^^^^^^^^^^^^^^^^^^^^ C901
9 |     """Parse a prompt with optional weights.
  |

src/midjargon/core/main.py:9:36: FBT001 Boolean-typed positional argument in function definition
   |
 8 | def format_json_output(
 9 |     variants: list[PromptVariant], include_parsed: bool = False
   |                                    ^^^^^^^^^^^^^^ FBT001
10 | ) -> dict[str, Any]:
11 |     """Format prompt variants as JSON output.
   |

src/midjargon/core/main.py:9:36: FBT002 Boolean default positional argument in function definition
   |
 8 | def format_json_output(
 9 |     variants: list[PromptVariant], include_parsed: bool = False
   |                                    ^^^^^^^^^^^^^^ FBT002
10 | ) -> dict[str, Any]:
11 |     """Format prompt variants as JSON output.
   |

src/midjargon/core/models.py:31:9: C901 `_missing_` is too complex (16 > 10)
   |
30 |     @classmethod
31 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ C901
32 |         """Handle missing values by trying to normalize the input."""
33 |         try:
   |

src/midjargon/core/models.py:31:9: PLR0911 Too many return statements (7 > 6)
   |
30 |     @classmethod
31 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ PLR0911
32 |         """Handle missing values by trying to normalize the input."""
33 |         try:
   |

src/midjargon/core/models.py:31:9: PLR0912 Too many branches (16 > 12)
   |
30 |     @classmethod
31 |     def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
   |         ^^^^^^^^^ PLR0912
32 |         """Handle missing values by trying to normalize the input."""
33 |         try:
   |

src/midjargon/core/models.py:77:9: E722 Do not use bare `except`
   |
76 |             return None
77 |         except:
   |         ^^^^^^ E722
78 |             return None
   |

src/midjargon/core/models.py:140:9: E722 Do not use bare `except`
    |
138 |                 raise ValueError
139 |             return f"{w}:{h}"
140 |         except:
    |         ^^^^^^ E722
141 |             msg = "Invalid aspect ratio format. Expected W:H"
142 |             raise ValueError(msg)
    |

src/midjargon/core/models.py:142:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
140 |         except:
141 |             msg = "Invalid aspect ratio format. Expected W:H"
142 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
143 |
144 |     @field_validator("stylize")
    |

src/midjargon/core/models.py:216:17: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
214 |             except ValueError as e:
215 |                 msg = f"Invalid aspect ratio format: {e}"
216 |                 raise ValueError(msg)
    |                 ^^^^^^^^^^^^^^^^^^^^^ B904
217 |         return v
    |

src/midjargon/core/parameters.py:65:5: E722 Do not use bare `except`
   |
63 |         result = urlparse(value)
64 |         return all([result.scheme, result.netloc])
65 |     except:
   |     ^^^^^^ E722
66 |         return False
   |

src/midjargon/core/parameters.py:69:5: C901 `convert_parameter_value` is too complex (15 > 10)
   |
69 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ C901
70 |     """Convert a parameter value to the appropriate type."""
71 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:69:5: PLR0911 Too many return statements (10 > 6)
   |
69 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ PLR0911
70 |     """Convert a parameter value to the appropriate type."""
71 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:69:5: PLR0912 Too many branches (15 > 12)
   |
69 | def convert_parameter_value(param: str, value: str | None) -> Any:
   |     ^^^^^^^^^^^^^^^^^^^^^^^ PLR0912
70 |     """Convert a parameter value to the appropriate type."""
71 |     # Handle flag parameters
   |

src/midjargon/core/parameters.py:89:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
87 |         except ValueError:
88 |             msg = f"Invalid version value: {value}"
89 |             raise ValueError(msg)
   |             ^^^^^^^^^^^^^^^^^^^^^ B904
90 |
91 |     # Handle integer parameters
   |

src/midjargon/core/parameters.py:97:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
   |
95 |         except ValueError:
96 |             msg = f"Invalid integer value for {param}: {value}"
97 |             raise ValueError(msg)
   |             ^^^^^^^^^^^^^^^^^^^^^ B904
98 |
99 |     # Handle float parameters
   |

src/midjargon/core/parameters.py:114:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
112 |         except ValueError:
113 |             msg = f"Invalid numeric value for {param}: {value}"
114 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
115 |
116 |     # Handle style parameter
    |

src/midjargon/core/parameters.py:122:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
120 |         except ValueError:
121 |             msg = f"Invalid style value: {value}"
122 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
123 |
124 |     # Handle character and style references
    |

src/midjargon/core/parameters.py:139:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
137 |         except Exception:
138 |             msg = f"Invalid reference value for {param}: {value}"
139 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
140 |
141 |     # Default case: return as string
    |

src/midjargon/core/parameters.py:145:5: C901 `parse_parameters` is too complex (14 > 10)
    |
145 | def parse_parameters(param_str: str) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^ C901
146 |     """Parse parameters from a string into a dictionary."""
147 |     if not param_str:
    |

src/midjargon/core/parameters.py:145:5: PLR0912 Too many branches (18 > 12)
    |
145 | def parse_parameters(param_str: str) -> dict[str, Any]:
    |     ^^^^^^^^^^^^^^^^ PLR0912
146 |     """Parse parameters from a string into a dictionary."""
147 |     if not param_str:
    |

src/midjargon/core/parameters.py:155:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
153 |     except ValueError as e:
154 |         msg = f"Failed to parse parameters: {e}"
155 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
156 |
157 |     result: dict[str, Any] = {}
    |

src/midjargon/core/parameters.py:188:21: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
186 |                 except Exception as e:
187 |                     msg = f"Failed to parse parameter {current_param}: {e}"
188 |                     raise ValueError(msg)
    |                     ^^^^^^^^^^^^^^^^^^^^^ B904
189 |
190 |             # Start new parameter
    |

src/midjargon/core/parameters.py:221:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
219 |         except Exception as e:
220 |             msg = f"Failed to parse parameter {current_param}: {e}"
221 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
222 |
223 |     return result
    |

src/midjargon/core/parser.py:24:5: E722 Do not use bare `except`
   |
22 |             )
23 |         )
24 |     except:
   |     ^^^^^^ E722
25 |         return False
   |

src/midjargon/core/parser.py:60:5: C901 `parse_parameters` is too complex (12 > 10)
   |
60 | def parse_parameters(param_str: str) -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^ C901
61 |     """Parse parameter string into a dictionary.
   |

src/midjargon/core/parser.py:60:5: PLR0912 Too many branches (15 > 12)
   |
60 | def parse_parameters(param_str: str) -> dict[str, Any]:
   |     ^^^^^^^^^^^^^^^^ PLR0912
61 |     """Parse parameter string into a dictionary.
   |

src/midjargon/core/parser.py:146:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
144 |         except Exception as e:
145 |             msg = f"Failed to parse parameters: {e!s}"
146 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
147 |     else:
148 |         text_part = remaining_text.strip()
    |

src/midjargon/core/parser.py:160:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
158 |     except Exception as e:
159 |         msg = f"Failed to create prompt object: {e!s}"
160 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
    |

src/midjargon/core/permutations.py:127:9: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
125 |     except Exception as e:
126 |         msg = f"Failed to parse options at position {start}: {e!s}"
127 |         raise ValueError(msg)
    |         ^^^^^^^^^^^^^^^^^^^^^ B904
128 |
129 |     if not options:
    |

src/midjargon/core/permutations.py:145:13: B904 Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling
    |
143 |         except Exception as e:
144 |             msg = f"Failed to expand option '{option}': {e!s}"
145 |             raise ValueError(msg)
    |             ^^^^^^^^^^^^^^^^^^^^^ B904
146 |
147 |     return results
    |

tests/core/test_parameters.py:134:5: PLR0915 Too many statements (58 > 50)
    |
134 | def test_parse_parameters():
    |     ^^^^^^^^^^^^^^^^^^^^^ PLR0915
135 |     """Test parse_parameters function to verify parameter parsing."""
136 |     param_str = "--ar 16:9 --stylize 100"
    |

Found 46 errors.
============================= test session starts ==============================
platform darwin -- Python 3.12.8, pytest-8.3.4, pluggy-1.5.0 -- /Users/adam/Library/Application Support/hatch/env/virtual/midjargon/XMQ91zt9/hatch-test.py3.12/bin/python3
cachedir: .pytest_cache
rootdir: /Users/adam/Developer/vcs/github.twardoch/pub/twat-packages/midjargon
configfile: pyproject.toml
plugins: rerunfailures-14.0, anyio-4.8.0, mock-3.14.0, xdist-3.6.1
collecting ... collected 92 items

tests/cli/test_main.py::test_basic_prompt FAILED                         [  1%]
tests/cli/test_main.py::test_permutations FAILED                         [  2%]
tests/cli/test_main.py::test_raw_output FAILED                           [  3%]
tests/cli/test_main.py::test_json_output_formatting FAILED               [  4%]
tests/cli/test_main.py::test_invalid_input FAILED                        [  5%]
tests/cli/test_main.py::test_parameter_validation FAILED                 [  6%]
tests/cli/test_main.py::test_image_url_handling FAILED                   [  7%]
tests/cli/test_main.py::test_no_color_output FAILED                      [  8%]
tests/cli/test_main.py::test_complex_prompt FAILED                       [  9%]
tests/cli/test_main.py::test_personalization_parameter FAILED            [ 10%]
tests/cli/test_main.py::test_numeric_range_permutations FAILED           [ 11%]
tests/cli/test_main.py::test_nested_parameter_permutations FAILED        [ 13%]
tests/cli/test_main.py::test_mj_command FAILED                           [ 14%]
tests/cli/test_main.py::test_fal_command FAILED                          [ 15%]
tests/cli/test_main.py::test_perm_command FAILED                         [ 16%]
tests/core/test_input.py::test_basic_input FAILED                        [ 17%]
tests/core/test_input.py::test_single_permutation FAILED                 [ 18%]
tests/core/test_input.py::test_empty_input FAILED                        [ 19%]
tests/core/test_input.py::test_multiple_permutations FAILED              [ 20%]
tests/core/test_input.py::test_nested_permutations FAILED                [ 21%]
tests/core/test_input.py::test_escaped_braces FAILED                     [ 22%]
tests/core/test_input.py::test_escaped_commas FAILED                     [ 23%]
tests/core/test_input.py::test_unmatched_braces FAILED                   [ 25%]
tests/core/test_input.py::test_empty_permutation FAILED                  [ 26%]
tests/core/test_input.py::test_whitespace_handling FAILED                [ 27%]
tests/core/test_input.py::test_expand_midjargon_input FAILED             [ 28%]
tests/core/test_input.py::test_handling_escaped_characters FAILED        [ 29%]
tests/core/test_parameters.py::test_basic_parameter_parsing FAILED       [ 30%]
tests/core/test_parameters.py::test_flag_parameters FAILED               [ 31%]
tests/core/test_parameters.py::test_parameter_with_multiple_values FAILED [ 32%]
tests/core/test_parameters.py::test_parameter_with_spaces FAILED         [ 33%]
tests/core/test_parameters.py::test_mixed_parameters FAILED              [ 34%]
tests/core/test_parameters.py::test_shorthand_parameters FAILED          [ 35%]
tests/core/test_parameters.py::test_niji_version_parameter FAILED        [ 36%]
tests/core/test_parameters.py::test_version_parameter FAILED             [ 38%]
tests/core/test_parameters.py::test_personalization_parameter FAILED     [ 39%]
tests/core/test_parameters.py::test_reference_parameters FAILED          [ 40%]
tests/core/test_parameters.py::test_parameter_order PASSED               [ 41%]
tests/core/test_parameters.py::test_invalid_parameters FAILED            [ 42%]
tests/core/test_parameters.py::test_parse_parameters FAILED              [ 43%]
tests/core/test_parameters.py::test_flag_parameters_handling FAILED      [ 44%]
tests/core/test_parameters.py::test_special_seed_values FAILED           [ 45%]
tests/core/test_parameters.py::test_reference_url_handling FAILED        [ 46%]
tests/core/test_parameters.py::test_niji_version_handling FAILED         [ 47%]
tests/core/test_parser.py::test_basic_prompt_parsing FAILED              [ 48%]
tests/core/test_parser.py::test_prompt_with_image_url FAILED             [ 50%]
tests/core/test_parser.py::test_prompt_with_multiple_image_urls FAILED   [ 51%]
tests/core/test_parser.py::test_prompt_with_parameters FAILED            [ 52%]
tests/core/test_parser.py::test_prompt_with_empty_parameters FAILED      [ 53%]
tests/core/test_parser.py::test_prompt_with_escaped_characters PASSED    [ 54%]
tests/core/test_parser.py::test_prompt_with_nested_permutations PASSED   [ 55%]
tests/core/test_parser.py::test_prompt_with_unmatched_braces PASSED      [ 56%]
tests/core/test_parser.py::test_prompt_with_empty_permutation PASSED     [ 57%]
tests/core/test_parser.py::test_prompt_with_whitespace_handling PASSED   [ 58%]
tests/engines/midjourney/test_midjourney_parser.py::test_numeric_parameters PASSED [ 59%]
tests/engines/midjourney/test_midjourney_parser.py::test_style_parameters PASSED [ 60%]
tests/engines/midjourney/test_midjourney_parser.py::test_aspect_ratio FAILED [ 61%]
tests/engines/midjourney/test_midjourney_parser.py::test_image_prompts PASSED [ 63%]
tests/engines/midjourney/test_midjourney_parser.py::test_extra_parameters PASSED [ 64%]
tests/engines/midjourney/test_midjourney_parser.py::test_parameter_conversion PASSED [ 65%]
tests/engines/midjourney/test_midjourney_parser.py::test_invalid_values FAILED [ 66%]
tests/engines/midjourney/test_midjourney_parser.py::test_empty_values FAILED [ 67%]
tests/engines/midjourney/test_midjourney_parser.py::test_version_parameter PASSED [ 68%]
tests/engines/midjourney/test_midjourney_parser.py::test_multiple_permutations PASSED [ 69%]
tests/engines/midjourney/test_midjourney_parser.py::test_personalization_parameter PASSED [ 70%]
tests/engines/midjourney/test_midjourney_parser.py::test_edge_cases PASSED [ 71%]
tests/integration/test_workflow.py::test_basic_workflow FAILED           [ 72%]
tests/integration/test_workflow.py::test_permutation_workflow FAILED     [ 73%]
tests/integration/test_workflow.py::test_image_workflow FAILED           [ 75%]
tests/integration/test_workflow.py::test_parameter_workflow FAILED       [ 76%]
tests/integration/test_workflow.py::test_new_parameters_workflow FAILED  [ 77%]
tests/integration/test_workflow.py::test_weighted_prompts_workflow FAILED [ 78%]
tests/integration/test_workflow.py::test_error_workflow FAILED           [ 79%]
tests/integration/test_workflow.py::test_complex_workflow FAILED         [ 80%]
tests/integration/test_workflow.py::test_permutations_with_parameters FAILED [ 81%]
tests/integration/test_workflow.py::test_permutations_with_flag_parameters FAILED [ 82%]
tests/integration/test_workflow.py::test_permutations_with_complex_parameters FAILED [ 83%]
tests/integration/test_workflow.py::test_cli_mj_command FAILED           [ 84%]
tests/integration/test_workflow.py::test_cli_fal_command FAILED          [ 85%]
tests/integration/test_workflow.py::test_cli_perm_command FAILED         [ 86%]
tests/test_core.py::test_basic_prompt_parsing PASSED                     [ 88%]
tests/test_core.py::test_prompt_with_parameters FAILED                   [ 89%]
tests/test_core.py::test_prompt_with_image PASSED                        [ 90%]
tests/test_core.py::test_invalid_parameters FAILED                       [ 91%]
tests/test_core.py::test_permutation_expansion PASSED                    [ 92%]
tests/test_core.py::test_escaped_permutations PASSED                     [ 93%]
tests/test_core.py::test_weighted_prompts FAILED                         [ 94%]
tests/test_core.py::test_combined_features FAILED                        [ 95%]
tests/test_core.py::test_style_reference PASSED                          [ 96%]
tests/test_core.py::test_character_reference FAILED                      [ 97%]
tests/test_core.py::test_prompt_to_string FAILED                         [ 98%]
tests/test_package.py::test_version PASSED                               [100%]

=================================== FAILURES ===================================
______________________________ test_basic_prompt _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e6600>

    def test_basic_prompt(cli):
        """Test basic prompt processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT}",
                json_output=True,
            )
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:58: TypeError
______________________________ test_permutations _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e65d0>

    def test_permutations(cli):
        """Test permutation processing."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10402c4c0>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_raw_output ________________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e6fc0>

    def test_raw_output(cli):
        """Test raw output mode."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"a photo --stylize {STYLIZE_VALUE}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:86: TypeError
_________________________ test_json_output_formatting __________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e47a0>

    def test_json_output_formatting(cli):
        """Test JSON output formatting."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:98: TypeError
______________________________ test_invalid_input ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10409f680>

    def test_invalid_input(cli):
        """Test handling of invalid input."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:110: TypeError
__________________________ test_parameter_validation ___________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10409f380>

    def test_parameter_validation(cli):
        """Test parameter validation."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(
                f"a photo --stylize {STYLIZE_VALUE * 20}", json_output=True
            )  # Over max
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:120: TypeError
___________________________ test_image_url_handling ____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x103fdcfe0>

    def test_image_url_handling(cli):
        """Test handling of image URLs."""
        url = "https://example.com/image.jpg"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(f"{url} a fusion", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:133: TypeError
_____________________________ test_no_color_output _____________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x10407bfe0>

    def test_no_color_output(cli):
        """Test no-color output mode."""
        Console(force_terminal=False)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo", json_output=True, no_color=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:147: TypeError
_____________________________ test_complex_prompt ______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x104078770>

    def test_complex_prompt(cli):
        """Test complex prompt with multiple features."""
        prompt = (
            "https://example.com/img1.jpg https://example.com/img2.jpg "
            "a {red, blue} bird on a {branch, rock} "
            f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
        )
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json(prompt, json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:163: TypeError
________________________ test_personalization_parameter ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x104078da0>

    def test_personalization_parameter(cli):
        """Test personalization parameter handling in different forms."""
        # Test flag form (--p)
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --p", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:180: TypeError
_______________________ test_numeric_range_permutations ________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x104079610>

    def test_numeric_range_permutations(cli):
        """Test handling of numeric parameters in permutations."""
        # Test stylize parameter range
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("a photo --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:210: TypeError
______________________ test_nested_parameter_permutations ______________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x104079ee0>

    def test_nested_parameter_permutations(cli):
        """Test handling of nested permutations with parameters."""
        # Test personalization with nested options
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.json("smooth edges {, --p {, CODE1}} --s {75, 300}", json_output=True)
E           TypeError: MidjargonCLI.json() got an unexpected keyword argument 'json_output'

tests/cli/test_main.py:237: TypeError
_______________________________ test_mj_command ________________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10409ff80>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
>               mj_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x1039e37a0>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/midjourney/midjourney.py:46: TypeError

During handling of the above exception, another exception occurred:

cli = <midjargon.cli.main.MidjargonCLI object at 0x10409ff80>

    def test_mj_command(cli):
        """Test Midjourney prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.mj("a serene landscape --ar 16:9 --stylize 100", json_output=True)

tests/cli/test_main.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10409ff80>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
                mj_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(mj_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    params = " ".join(
                        f"--{k} {v}"
                        for k, v in result.items()
                        if k not in {"text", "image_prompts", "extra_params"}
                        and v is not None
                    )
                    console.print(
                        f"{result['text']} {params}",
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:89: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword 
argument 'extra_params'
_______________________________ test_fal_command _______________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x1040e5430>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x1040e6960>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e5430>

    def test_fal_command(cli):
        """Test Fal.ai prompt conversion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal("a serene landscape --ar 16:9 --stylize 100", json_output=True)

tests/cli/test_main.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x1040e5430>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
______________________________ test_perm_command _______________________________

cli = <midjargon.cli.main.MidjargonCLI object at 0x1040e63c0>

    def test_perm_command(cli):
        """Test permutation expansion."""
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm("a {red, blue} bird on a {branch, rock}", json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/cli/test_main.py:311: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10402f4c0>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_______________________________ test_basic_input _______________________________

    def test_basic_input():
        """Test basic input without permutations."""
        result = expand_midjargon_input("a simple prompt")
        assert len(result) == 1
>       assert result[0] == "a simple prompt"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a simple prompt', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == 'a simple prompt'

tests/core/test_input.py:15: AssertionError
___________________________ test_single_permutation ____________________________

    def test_single_permutation():
        """Test input with a single permutation."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:22: AssertionError
_______________________________ test_empty_input _______________________________

    def test_empty_input():
        """Test empty input handling."""
        result = expand_midjargon_input("")
        assert len(result) == 1
>       assert result[0] == ""
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == ''

tests/core/test_input.py:30: AssertionError
__________________________ test_multiple_permutations __________________________

    def test_multiple_permutations():
        """Test input with multiple permutations."""
        result = expand_midjargon_input("a {red, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_3
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a green bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:37: AssertionError
___________________________ test_nested_permutations ___________________________

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
>               results.extend(expand_permutations(new_s))

src/midjargon/core/permutations.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a red {cat'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 6

src/midjargon/core/permutations.py:119: ValueError

During handling of the above exception, another exception occurred:

    def test_nested_permutations():
        """Test input with nested permutations."""
>       result = expand_midjargon_input("a {red {cat, dog}, blue bird}")

tests/core/test_input.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:84: in expand_midjargon_input
    permutation_options = expand_permutations(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red {cat, dog}, blue bird}'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
            raise ValueError(msg)
    
        # Recursively expand each option
        results = []
        prefix = s[:start]
        suffix = s[end + 1 :]
    
        for option in options:
            # Replace the entire '{...}' with the option
            new_s = prefix + option + suffix
            try:
                results.extend(expand_permutations(new_s))
            except Exception as e:
                msg = f"Failed to expand option '{option}': {e!s}"
>               raise ValueError(msg)
E               ValueError: Failed to expand option 'red {cat': Unclosed brace at position 6

src/midjargon/core/permutations.py:145: ValueError
_____________________________ test_escaped_braces ______________________________

    def test_escaped_braces():
        """Test input with escaped braces."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:55: AssertionError
_____________________________ test_escaped_commas ______________________________

    def test_escaped_commas():
        """Test input with escaped commas."""
        result = expand_midjargon_input(r"a {red\, blue, green} bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red, blue bird" in result
E       AssertionError: assert 'a red, blue bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red, blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a green bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:62: AssertionError
____________________________ test_unmatched_braces _____________________________

    def test_unmatched_braces():
        """Test input with unmatched braces."""
>       result = expand_midjargon_input("a {red, blue bird")

tests/core/test_input.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:84: in expand_midjargon_input
    permutation_options = expand_permutations(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {red, blue bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
>           raise ValueError(error)
E           ValueError: Unclosed brace at position 2

src/midjargon/core/permutations.py:119: ValueError
____________________________ test_empty_permutation ____________________________

    def test_empty_permutation():
        """Test input with empty permutation options."""
>       result = expand_midjargon_input("a {} bird")

tests/core/test_input.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/midjargon/core/input.py:84: in expand_midjargon_input
    permutation_options = expand_permutations(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

s = 'a {} bird'

    def expand_permutations(s: str) -> list[str]:
        """Recursively expand permutations in the prompt string using {a, b, ...} syntax.
    
        Handles:
        - Nested permutation groups
        - Escaped characters (\\, \\{, \\}, \\,)
        - Proper error reporting
    
        Args:
            s: String containing permutation groups.
    
        Returns:
            List of all possible permutations.
    
        Raises:
            ValueError: If the permutation syntax is invalid.
        """
        # Find first unescaped opening brace
        start = find_unescaped(s, "{")
        if start == -1:
            return [s]
    
        # Find matching closing brace
        end, error = find_matching_brace(s, start)
        if end == -1:
            raise ValueError(error)
    
        # Extract and split options
        options_str = s[start + 1 : end]
        try:
            options = split_unescaped(options_str)
        except Exception as e:
            msg = f"Failed to parse options at position {start}: {e!s}"
            raise ValueError(msg)
    
        if not options:
            msg = f"Empty permutation group at position {start}"
>           raise ValueError(msg)
E           ValueError: Empty permutation group at position 2

src/midjargon/core/permutations.py:131: ValueError
___________________________ test_whitespace_handling ___________________________

    def test_whitespace_handling():
        """Test input with various whitespace patterns."""
        result = expand_midjargon_input("a {  red  ,  blue  } bird")
        assert len(result) == PERMUTATION_COUNT_2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:84: AssertionError
_________________________ test_expand_midjargon_input __________________________

    def test_expand_midjargon_input():
        """Test expand_midjargon_input function to verify prompt expansion."""
        result = expand_midjargon_input("a {red, blue} bird")
        assert len(result) == 2
>       assert "a red bird" in result
E       AssertionError: assert 'a red bird' in [PromptVariant(prompt=MidjourneyPrompt(text='a red bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)]

tests/core/test_input.py:92: AssertionError
_______________________ test_handling_escaped_characters _______________________

    def test_handling_escaped_characters():
        """Test handling of escaped characters in expand_midjargon_input."""
        result = expand_midjargon_input(r"a \{red, blue\} bird")
        assert len(result) == 1
>       assert result[0] == "a {red, blue} bird"
E       AssertionError: assert PromptVariant(prompt=MidjourneyPrompt(text='a \\{red, blue\\} bird', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0) == 'a {red, blue} bird'

tests/core/test_input.py:112: AssertionError
_________________________ test_basic_parameter_parsing _________________________

    def test_basic_parameter_parsing():
        """Test parsing of basic parameters."""
        param_str = "--ar 16:9 --stylize 100"
        params = parse_parameters(param_str)
        assert params["aspect"] == "16:9"
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:14: AssertionError
_____________________________ test_flag_parameters _____________________________

    def test_flag_parameters():
        """Test parsing of flag parameters (without values)."""
        param_str = "--tile --turbo --relax"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:21: AssertionError
_____________________ test_parameter_with_multiple_values ______________________

    def test_parameter_with_multiple_values():
        """Test parsing parameters that accept multiple values."""
        param_str = "--no blur,cars,watermark"
        params = parse_parameters(param_str)
>       assert params["no"] == "blur,cars,watermark"
E       AssertionError: assert ['blur,cars,watermark'] == 'blur,cars,watermark'

tests/core/test_parameters.py:30: AssertionError
__________________________ test_parameter_with_spaces __________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
>                           value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )

src/midjargon/core/parameters.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:122: ValueError

During handling of the above exception, another exception occurred:

    def test_parameter_with_spaces():
        """Test parsing parameters with values containing spaces."""
        param_str = '--style "raw photo" --seed 123456'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--style "raw photo" --seed 123456'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
>                       raise ValueError(msg)
E                       ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:188: ValueError
____________________________ test_mixed_parameters _____________________________

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
>               return StyleMode(value)

src/midjargon/core/parameters.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:751: in __call__
    return cls.__new__(cls, value)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

cls = <enum 'StyleMode'>, value = 'raw photo'

    def __new__(cls, value):
        # all enum instances are actually created during class construction
        # without calling this method; this method is called by the metaclass'
        # __call__ (i.e. Color(3) ), and by pickle
        if type(value) is cls:
            # For lookups like Color(Color.RED)
            return value
        # by-value search for a matching enum member
        # see if it's in the reverse mapping (for hashable values)
        try:
            return cls._value2member_map_[value]
        except KeyError:
            # Not found, no need to do long O(n) search
            pass
        except TypeError:
            # not there, now do long search -- O(n) behavior
            for member in cls._member_map_.values():
                if member._value_ == value:
                    return member
        # still not found -- verify that members exist, in-case somebody got here mistakenly
        # (such as via super when trying to override __new__)
        if not cls._member_map_:
            raise TypeError("%r has no members defined" % cls)
        #
        # still not found -- try _missing_ hook
        try:
            exc = None
            result = cls._missing_(value)
        except Exception as e:
            exc = e
            result = None
        try:
            if isinstance(result, cls):
                return result
            elif (
                    Flag is not None and issubclass(cls, Flag)
                    and cls._boundary_ is EJECT and isinstance(result, int)
                ):
                return result
            else:
                ve_exc = ValueError("%r is not a valid %s" % (value, cls.__qualname__))
                if result is None and exc is None:
>                   raise ve_exc
E                   ValueError: 'raw photo' is not a valid StyleMode

/Library/Frameworks/Python.framework/Versions/3.12/lib/python3.12/enum.py:1165: ValueError

During handling of the above exception, another exception occurred:

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
>                   value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )

src/midjargon/core/parameters.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'style', value = 'raw photo'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle float parameters
        if param in {
            "stylize",
            "chaos",
            "weird",
            "quality",
            "character_weight",
            "style_weight",
            "image_weight",
            "stop",
        }:
            try:
                return float(value)
            except ValueError:
                msg = f"Invalid numeric value for {param}: {value}"
                raise ValueError(msg)
    
        # Handle style parameter
        if param == "style":
            try:
                return StyleMode(value)
            except ValueError:
                msg = f"Invalid style value: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid style value: raw photo

src/midjargon/core/parameters.py:122: ValueError

During handling of the above exception, another exception occurred:

    def test_mixed_parameters():
        """Test parsing a mix of different parameter types."""
        param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
>       params = parse_parameters(param_str)

tests/core/test_parameters.py:44: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
                    value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )
                    result[current_param] = value
            except Exception as e:
                msg = f"Failed to parse parameter {current_param}: {e}"
>               raise ValueError(msg)
E               ValueError: Failed to parse parameter style: Invalid style value: raw photo

src/midjargon/core/parameters.py:221: ValueError
__________________________ test_shorthand_parameters ___________________________

    def test_shorthand_parameters():
        """Test parsing of shorthand parameter names."""
        param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
        params = parse_parameters(param_str)
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:55: AssertionError
_________________________ test_niji_version_parameter __________________________

    def test_niji_version_parameter():
        """Test parsing of niji version parameter."""
        # Test basic niji
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:66: AssertionError
____________________________ test_version_parameter ____________________________

    def test_version_parameter():
        """Test parsing of version parameter."""
        # Test v parameter
        params = parse_parameters("--v 5.2")
>       assert params["version"] == "5.2"
E       AssertionError: assert <MidjourneyVe....V5_2: 'v5.2'> == '5.2'
E         
E         - 5.2
E         + v5.2
E         ? +

tests/core/test_parameters.py:77: AssertionError
________________________ test_personalization_parameter ________________________

    def test_personalization_parameter():
        """Test parsing of personalization parameter."""
        # Test basic p parameter
        params = parse_parameters("--p")
>       assert params["personalization"] is None  # Flag without value is None
E       assert True is None

tests/core/test_parameters.py:84: AssertionError
__________________________ test_reference_parameters ___________________________

    def test_reference_parameters():
        """Test parsing of reference parameters."""
        param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
        params = parse_parameters(param_str)
>       assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
E       AssertionError: assert [CharacterRef...e='img2.jpg')] == ['img1.jpg', 'img2.jpg']
E         
E         At index 0 diff: CharacterReference(url=HttpUrl('https://example.com/img1.jpg'), weight=1.0, code='img1.jpg') != 'img1.jpg'
E         
E         Full diff:
E           [
E         -     'img1.jpg',
E         -     'img2.jpg',...
E         
E         ...Full output truncated (3 lines hidden), use '-vv' to show

tests/core/test_parameters.py:107: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameter formats."""
>       with pytest.raises(ValueError, match="Empty parameter name"):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/core/test_parameters.py:121: Failed
____________________________ test_parse_parameters _____________________________

    def test_parse_parameters():
        """Test parse_parameters function to verify parameter parsing."""
        param_str = "--ar 16:9 --stylize 100"
        params = parse_parameters(param_str)
        assert params["aspect"] == "16:9"
>       assert params["stylize"] == "100"
E       AssertionError: assert 100.0 == '100'

tests/core/test_parameters.py:139: AssertionError
________________________ test_flag_parameters_handling _________________________

    def test_flag_parameters_handling():
        """Test handling of flag parameters in parse_parameters."""
        param_str = "--tile --turbo --relax --video --remix"
        params = parse_parameters(param_str)
>       assert params["tile"] is None
E       assert True is None

tests/core/test_parameters.py:216: AssertionError
___________________________ test_special_seed_values ___________________________

param = 'seed', value = 'random'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
>               return int(value)
E               ValueError: invalid literal for int() with base 10: 'random'

src/midjargon/core/parameters.py:94: ValueError

During handling of the above exception, another exception occurred:

param_str = '--seed random'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
>                   value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )

src/midjargon/core/parameters.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param = 'seed', value = 'random'

    def convert_parameter_value(param: str, value: str | None) -> Any:
        """Convert a parameter value to the appropriate type."""
        # Handle flag parameters
        if param in FLAG_PARAMS:
            return True if value is None else value.lower() == "true"
    
        # Handle empty values
        if value is None:
            return None
    
        # Handle string parameters
        if param in STRING_PARAMS:
            return str(value)
    
        # Handle version parameter
        if param == "version":
            try:
                return MidjourneyVersion(value)
            except ValueError:
                msg = f"Invalid version value: {value}"
                raise ValueError(msg)
    
        # Handle integer parameters
        if param in INT_PARAMS:
            try:
                return int(value)
            except ValueError:
                msg = f"Invalid integer value for {param}: {value}"
>               raise ValueError(msg)
E               ValueError: Invalid integer value for seed: random

src/midjargon/core/parameters.py:97: ValueError

During handling of the above exception, another exception occurred:

    def test_special_seed_values():
        """Test handling of special seed values."""
        # Test random seed
>       params = parse_parameters("--seed random")

tests/core/test_parameters.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

param_str = '--seed random'

    def parse_parameters(param_str: str) -> dict[str, Any]:
        """Parse parameters from a string into a dictionary."""
        if not param_str:
            return {}
    
        # Split parameters while preserving quoted strings
        try:
            parts = shlex.split(param_str)
        except ValueError as e:
            msg = f"Failed to parse parameters: {e}"
            raise ValueError(msg)
    
        result: dict[str, Any] = {}
        current_param = None
        current_values = []
    
        for part in parts:
            if part.startswith("--"):
                # Store previous parameter if exists
                if current_param:
                    try:
                        if current_param in MULTI_VALUE_PARAMS:
                            # Handle multi-value parameters
                            values = (
                                [
                                    convert_parameter_value(current_param, v)
                                    for v in current_values
                                ]
                                if current_values
                                else [True]
                            )
                            if current_param in result:
                                result[current_param].extend(values)
                            else:
                                result[current_param] = values
                        else:
                            # Handle single value parameters
                            value = convert_parameter_value(
                                current_param, current_values[0] if current_values else None
                            )
                            result[current_param] = value
                    except Exception as e:
                        msg = f"Failed to parse parameter {current_param}: {e}"
                        raise ValueError(msg)
    
                # Start new parameter
                current_param = ALIASES.get(
                    part[2:], part[2:]
                )  # Remove -- and resolve alias
                current_values = []
            elif current_param:
                current_values.append(part)
            else:
                msg = f"Unexpected value without parameter: {part}"
                raise ValueError(msg)
    
        # Handle last parameter
        if current_param:
            try:
                if current_param in MULTI_VALUE_PARAMS:
                    values = (
                        [convert_parameter_value(current_param, v) for v in current_values]
                        if current_values
                        else [True]
                    )
                    if current_param in result:
                        result[current_param].extend(values)
                    else:
                        result[current_param] = values
                else:
                    value = convert_parameter_value(
                        current_param, current_values[0] if current_values else None
                    )
                    result[current_param] = value
            except Exception as e:
                msg = f"Failed to parse parameter {current_param}: {e}"
>               raise ValueError(msg)
E               ValueError: Failed to parse parameter seed: Invalid integer value for seed: random

src/midjargon/core/parameters.py:221: ValueError
_________________________ test_reference_url_handling __________________________

    def test_reference_url_handling():
        """Test handling of URLs in reference parameters."""
        # Test character reference with quoted URL containing spaces
        params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
>       assert params["character_reference"] == [
            "https://example.com/image with spaces.jpg"
        ]
E       AssertionError: assert [CharacterRef...0, code=None)] == ['https://exa...h spaces.jpg']
E         
E         At index 0 diff: CharacterReference(url=HttpUrl('https://example.com/image%20with%20spaces.jpg'), weight=1.0, code=None) != 'https://example.com/image with spaces.jpg'
E         
E         Full diff:
E           [
E         -     'https://example.com/image with spaces.jpg',
E         +     CharacterReference(url=HttpUrl('https://example.com/image%20with%20spaces.jpg'), weight=1.0, code=None),
E           ]

tests/core/test_parameters.py:250: AssertionError
__________________________ test_niji_version_handling __________________________

    def test_niji_version_handling():
        """Test handling of niji version parameter."""
        # Test basic niji flag
        params = parse_parameters("--niji")
>       assert params["version"] == "niji"
E       AssertionError: assert None == 'niji'

tests/core/test_parameters.py:271: AssertionError
__________________________ test_basic_prompt_parsing ___________________________

    def test_basic_prompt_parsing():
        """Test basic prompt parsing."""
        prompt = "a beautiful landscape --ar 16:9 --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a beautiful landscape"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:18: KeyError
__________________________ test_prompt_with_image_url __________________________

    def test_prompt_with_image_url():
        """Test prompt parsing with image URL."""
        prompt = f"{IMAGE_URL} a mystical forest --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a mystical forest"
>       assert result["images"] == [IMAGE_URL]
E       AssertionError: assert [HttpUrl('htt...m/image.jpg')] == ['https://exa...om/image.jpg']
E         
E         At index 0 diff: HttpUrl('https://example.com/image.jpg') != 'https://example.com/image.jpg'
E         
E         Full diff:
E           [
E         -     'https://example.com/image.jpg',
E         +     HttpUrl('https://example.com/image.jpg'),
E         ?     ++++++++                               +
E           ]

tests/core/test_parser.py:27: AssertionError
_____________________ test_prompt_with_multiple_image_urls _____________________

    def test_prompt_with_multiple_image_urls():
        """Test prompt parsing with multiple image URLs."""
        image_urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
        prompt = f"{image_urls[0]} {image_urls[1]} a serene landscape --stylize 100"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a serene landscape"
>       assert result["images"] == image_urls
E       AssertionError: assert [HttpUrl('htt.../image2.jpg')] == ['https://exa...m/image2.jpg']
E         
E         At index 0 diff: HttpUrl('https://example.com/image1.jpg') != 'https://example.com/image1.jpg'
E         
E         Full diff:
E           [
E         -     'https://example.com/image1.jpg',
E         +     HttpUrl('https://example.com/image1.jpg'),...
E         
E         ...Full output truncated (5 lines hidden), use '-vv' to show

tests/core/test_parser.py:40: AssertionError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a futuristic city --ar 16:9 --stylize 100 --chaos 50"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a futuristic city"
>       assert result["aspect"] == ASPECT_RATIO
E       KeyError: 'aspect'

tests/core/test_parser.py:49: KeyError
______________________ test_prompt_with_empty_parameters _______________________

    def test_prompt_with_empty_parameters():
        """Test prompt parsing with empty parameters."""
        prompt = "a landscape photo --tile --no blur,cars"
        result = parse_midjargon_prompt_to_dict(prompt)
        assert result["text"] == "a landscape photo"
>       assert result["tile"] is None
E       assert True is None

tests/core/test_parser.py:59: AssertionError
______________________________ test_aspect_ratio _______________________________

    def test_aspect_ratio():
        """Test parsing of aspect ratio."""
        parser = MidjourneyParser()
        prompt = parser.parse_dict({"text": "a photo", "ar": "16:9"})
    
        assert prompt.text == "a photo"
>       assert prompt.aspect_width == 16
E       AssertionError: assert None == 16
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={'ar': '16:9'}, images=[]).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:61: AssertionError
_____________________________ test_invalid_values ______________________________

    def test_invalid_values():
        """Test handling of invalid parameter values."""
        parser = MidjourneyParser()
    
        # Invalid aspect ratio - now accepts any value
        result = parser.parse_dict({"text": "a photo", "ar": "999:999"})
>       assert result.aspect_width == 999
E       AssertionError: assert None == 999
E        +  where None = MidjourneyPrompt(text='a photo', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={'ar': '999:999'}, images=[]).aspect_width

tests/engines/midjourney/test_midjourney_parser.py:120: AssertionError
______________________________ test_empty_values _______________________________

    def test_empty_values():
        """Test handling of empty values."""
        parser = MidjourneyParser()
    
        # Empty text
        with pytest.raises(ValueError, match="Empty prompt"):
            parser.parse_dict({"text": ""})
    
        # Empty image list
        prompt = parser.parse_dict({"text": "a photo", "image_prompts": []})
        assert prompt.text == "a photo"
        assert not prompt.image_prompts
    
        # None values
>       prompt = parser.parse_dict({"text": "a photo", "stylize": None})

tests/engines/midjourney/test_midjourney_parser.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x10409f8f0>
prompt_dict = {'stylize': None}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       pydantic_core._pydantic_core.ValidationError: 1 validation error for MidjourneyPrompt
E       stylize
E         Input should be a valid number [type=float_type, input_value=None, input_type=NoneType]
E           For further information visit https://errors.pydantic.dev/2.10/v/float_type

src/midjargon/engines/midjourney/midjourney.py:46: ValidationError
_____________________________ test_basic_workflow ______________________________

prompt = 'a beautiful landscape --ar 16:9 --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_basic_workflow():
        """Test basic prompt workflow without permutations."""
        prompt = f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'a beautiful landscape --ar 16:9 --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
__________________________ test_permutation_workflow ___________________________

prompt = 'a red bird on a branch --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutation_workflow():
        """Test workflow with permutations."""
        prompt = f"a {{red, blue}} bird on a {{branch, rock}} --stylize {STYLIZE_VALUE}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'a red bird on a branch --stylize 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_____________________________ test_image_workflow ______________________________

prompt = 'https://example.com/image1.jpg https://example.com/image2.jpg abstract fusion --iw 2.0 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_image_workflow():
        """Test workflow with image URLs."""
        urls = [
            "https://example.com/image1.jpg",
            "https://example.com/image2.jpg",
        ]
        prompt = f"{' '.join(urls)} abstract fusion --iw {IMAGE_WEIGHT_VALUE}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'https://example.com/image1.jpg https://example.com/image2.jpg abstract fusion --iw 2.0 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
___________________________ test_parameter_workflow ____________________________

prompt = 'cyberpunk city --v 5.2 --style raw --chaos 50 --weird 1000 --seed 12345 --stop 80 --turbo --tile --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_parameter_workflow():
        """Test workflow with various parameter types."""
        prompt = (
            "cyberpunk city --v 5.2 --style raw "
            f"--chaos {CHAOS_VALUE} --weird {WEIRD_VALUE} "
            f"--seed {SEED_VALUE} --stop {STOP_VALUE} "
            "--turbo --tile"
        )
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'cyberpunk city --v 5.2 --style raw --chaos 50 --weird 1000 --seed 12345 --stop 80 --turbo --tile --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_________________________ test_new_parameters_workflow _________________________

prompt = 'portrait photo --quality 1.0 --cw 100 --sw 200 --sv 2 --repeat 3 --cref ref1.jpg ref2.jpg --sref style1.jpg style2.jp... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_new_parameters_workflow():
        """Test workflow with new parameter types."""
        prompt = (
            "portrait photo "
            f"--quality {QUALITY_VALUE} "
            f"--cw {CHARACTER_WEIGHT_VALUE} "
            f"--sw {STYLE_WEIGHT_VALUE} "
            f"--sv {STYLE_VERSION_VALUE} "
            f"--repeat {REPEAT_VALUE} "
            "--cref ref1.jpg ref2.jpg "
            "--sref style1.jpg style2.jpg "
            "--p custom_profile1 custom_profile2"
        )
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:135: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'portrait photo --quality 1.0 --cw 100 --sw 200 --sv 2 --repeat 3 --cref ref1.jpg ref2.jpg --sref style1.jpg style2.jp... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
________________________ test_weighted_prompts_workflow ________________________

prompt = 'cyberpunk city::2 neon lights::1 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_weighted_prompts_workflow():
        """Test workflow with weighted prompts."""
        prompt = "cyberpunk city::2 neon lights::1"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'cyberpunk city::2 neon lights::1 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_____________________________ test_error_workflow ______________________________

prompt = ' --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_error_workflow():
        """Test error handling in workflow."""
        # Test empty prompt
        with pytest.raises(ValueError, match="Empty prompt"):
>           process_prompt("")

tests/integration/test_workflow.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = ' --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError

During handling of the above exception, another exception occurred:

    def test_error_workflow():
        """Test error handling in workflow."""
        # Test empty prompt
>       with pytest.raises(ValueError, match="Empty prompt"):
E       AssertionError: Regex pattern did not match.
E        Regex: 'Empty prompt'
E        Input: "Failed to create prompt object: 2 validation errors for MidjourneyPrompt\ncharacter_reference\n  Input should be a valid list [type=list_type, input_value='[]', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/list_type\nstyle_reference\n  Input should be a valid list [type=list_type, input_value='[]', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/list_type"

tests/integration/test_workflow.py:164: AssertionError
____________________________ test_complex_workflow _____________________________

prompt = 'https://example.com/img1.jpg https://example.com/img2.jpg a vintage portrait with warm tones --ar 16:9 --stylize 100 ... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_complex_workflow():
        """Test workflow with multiple features combined."""
        prompt = (
            "https://example.com/img1.jpg https://example.com/img2.jpg "
            "a {vintage, modern} {portrait, landscape} "
            "with {warm, cool} tones "
            f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} "
            f"--chaos {CHAOS_VALUE} --v 5.2 --style raw "
            f"--quality {QUALITY_VALUE} --cw {CHARACTER_WEIGHT_VALUE} "
            "--turbo"
        )
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'https://example.com/img1.jpg https://example.com/img2.jpg a vintage portrait with warm tones --ar 16:9 --stylize 100 ... --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
______________________ test_permutations_with_parameters _______________________

prompt = 'smooth edges  --s 75 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutations_with_parameters():
        """Test permutations with parameters are handled correctly."""
        prompt = "smooth edges {, --p} --s {75, 300}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'smooth edges  --s 75 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
____________________ test_permutations_with_flag_parameters ____________________

prompt = 'photo   --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutations_with_flag_parameters():
        """Test permutations with flag parameters (no value) are handled correctly."""
        prompt = "photo {, --tile} {, --turbo}"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:242: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'photo   --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
__________________ test_permutations_with_complex_parameters ___________________

prompt = 'portrait modern  --ar 1:1 --s 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_permutations_with_complex_parameters():
        """Test permutations with complex parameter combinations."""
        prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
>       results = process_prompt(prompt)

tests/integration/test_workflow.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/integration/test_workflow.py:41: in process_prompt
    parse_midjargon_prompt_to_dict(variant.prompt.to_string())
src/midjargon/core/parser.py:172: in parse_midjargon_prompt_to_dict
    parsed = parse_midjargon_prompt(prompt)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'portrait modern  --ar 1:1 --s 100 --stylize 100 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
_____________________________ test_cli_mj_command ______________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10460f350>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
>               mj_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.midjourney.midjourney.MidjourneyParser object at 0x10460cd10>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            MidjourneyPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return MidjourneyPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/midjourney/midjourney.py:46: TypeError

During handling of the above exception, another exception occurred:

    def test_cli_mj_command():
        """Test Midjourney prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.mj(prompt, json_output=True)

tests/integration/test_workflow.py:300: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10460f350>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
                mj_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(mj_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    params = " ".join(
                        f"--{k} {v}"
                        for k, v in result.items()
                        if k not in {"text", "image_prompts", "extra_params"}
                        and v is not None
                    )
                    console.print(
                        f"{result['text']} {params}",
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:89: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.core.models.MidjourneyPrompt() got multiple values for keyword 
argument 'extra_params'
_____________________________ test_cli_fal_command _____________________________

self = <midjargon.cli.main.MidjargonCLI object at 0x10401ce30>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
>               fal_prompt = parser.parse_dict(variant.prompt.model_dump())

src/midjargon/cli/main.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.engines.fal.fal.FalParser object at 0x10401d760>
prompt_dict = {'aspect_height': None, 'aspect_ratio': None, 'aspect_width': None, 'chaos': 0, ...}

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.
    
        Args:
            prompt_dict: Dictionary containing prompt data.
    
        Returns:
            FalPrompt instance.
    
        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)
    
        # Extract known fields
        known_fields = set(FalPrompt.model_fields)
    
        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value
    
        # Create prompt with all parameters
>       return FalPrompt(text=text, **params, extra_params=extra_params)
E       TypeError: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword argument 'extra_params'

src/midjargon/engines/fal/fal.py:102: TypeError

During handling of the above exception, another exception occurred:

    def test_cli_fal_command():
        """Test Fal.ai prompt conversion using CLI."""
        cli = MidjargonCLI()
        prompt = "a serene landscape --ar 16:9 --stylize 100"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
>           cli.fal(prompt, json_output=True)

tests/integration/test_workflow.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <midjargon.cli.main.MidjargonCLI object at 0x10401ce30>
prompt = 'a serene landscape --ar 16:9 --stylize 100', json_output = True
no_color = False

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.
    
        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())
    
            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
>           sys.exit(1)
E           SystemExit: 1

src/midjargon/cli/main.py:121: SystemExit
----------------------------- Captured stderr call -----------------------------
Error: midjargon.engines.fal.fal.FalPrompt() got multiple values for keyword 
argument 'extra_params'
____________________________ test_cli_perm_command _____________________________

    def test_cli_perm_command():
        """Test permutation expansion using CLI."""
        cli = MidjargonCLI()
        prompt = "a {red, blue} bird on a {branch, rock}"
        with StringIO() as capture_stdout:
            sys.stdout = capture_stdout
            cli.perm(prompt, json_output=True)
            sys.stdout = sys.__stdout__
>           data = parse_json_output(capture_stdout)

tests/integration/test_workflow.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

output_stream = <_io.StringIO object at 0x10402fa00>

    def parse_json_output(output_stream: StringIO) -> Any:
        """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
        output_stream.seek(0)
        output = output_stream.getvalue()
        # Remove ANSI escape sequences
        output = ANSI_ESCAPE.sub("", output)
        output = output.strip()
        if not output:
            msg = "No JSON found in output"
>           raise ValueError(msg)
E           ValueError: No JSON found in output

tests/cli/test_main.py:40: ValueError
_________________________ test_prompt_with_parameters __________________________

    def test_prompt_with_parameters():
        """Test prompt parsing with various parameters."""
        prompt = "a portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
        result = parse_midjargon_prompt(prompt)
    
        assert result.text == "a portrait"
>       assert result.parameters.aspect == "16:9"
E       AssertionError: assert '1:1' == '16:9'
E         
E         - 16:9
E         + 1:1

tests/test_core.py:31: AssertionError
___________________________ test_invalid_parameters ____________________________

    def test_invalid_parameters():
        """Test handling of invalid parameters."""
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

tests/test_core.py:49: Failed
____________________________ test_weighted_prompts _____________________________

    def test_weighted_prompts():
        """Test handling of weighted prompts."""
        prompt = "first prompt::0.7 second prompt::0.3"
        results = expand_midjargon_input(prompt)
    
>       assert len(results) == 2
E       AssertionError: assert 1 == 2
E        +  where 1 = len([PromptVariant(prompt=MidjourneyPrompt(text='first prompt::0.7 second prompt::0.3', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)])

tests/test_core.py:80: AssertionError
____________________________ test_combined_features ____________________________

    def test_combined_features():
        """Test combination of multiple features."""
        prompt = "a {red, blue} bird::0.6 a {green, yellow} tree::0.4"
        results = expand_midjargon_input(prompt)
    
        assert len(results) == 4
        # Check first group
        red_blue = [r for r in results if "bird" in r.prompt.text]
>       assert len(red_blue) == 2
E       AssertionError: assert 4 == 2
E        +  where 4 = len([PromptVariant(prompt=MidjourneyPrompt(text='a red bird::0.6 a green tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a red bird::0.6 a yellow tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird::0.6 a green tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0), PromptVariant(prompt=MidjourneyPrompt(text='a blue bird::0.6 a yellow tree::0.4', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]), weight=1.0)])

tests/test_core.py:93: AssertionError
___________________________ test_character_reference ___________________________

    def test_character_reference():
        """Test handling of character references."""
        prompt = "test --cref https://example.com/char.jpg --cw 50"
        result = parse_midjargon_prompt(prompt)
    
        assert result.character_reference
        assert str(result.character_reference[0].url) == "https://example.com/char.jpg"
>       assert result.character_weight == 50
E       AssertionError: assert 100 == 50
E        +  where 100 = MidjourneyPrompt(text='test', image_prompts=[], stylize=100, chaos=0, weird=0, image_weight=1.0, seed=None, stop=100, aspect_width=None, aspect_height=None, aspect_ratio=None, style=None, version=None, personalization=False, quality=1.0, character_reference=[CharacterReference(url=HttpUrl('https://example.com/char.jpg'), weight=1.0, code=None)], character_weight=100, style_reference=[], style_weight=None, style_version=2, repeat=None, turbo=False, relax=False, tile=False, negative_prompt=None, extra_params={}, images=[]).character_weight

tests/test_core.py:126: AssertionError
____________________________ test_prompt_to_string _____________________________

prompt = 'a portrait --stylize 200 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
>           return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
E           pydantic_core._pydantic_core.ValidationError: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:153: ValidationError

During handling of the above exception, another exception occurred:

    def test_prompt_to_string():
        """Test conversion of prompt back to string format."""
        original = "a portrait --ar 16:9 --stylize 200"
        result = parse_midjargon_prompt(original)
    
        # Convert back to string
        output = result.to_string()
    
        # Parse again to verify equivalence
>       reparsed = parse_midjargon_prompt(output)

tests/test_core.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

prompt = 'a portrait --stylize 200 --chaos 0 --weird 0 --aspect 1:1 --tile False --turbo False --relax False --no [] --character_reference [] --style_reference []'

    def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
        """Parse a Midjourney prompt into a validated MidjourneyPrompt object.
    
        Args:
            prompt: The raw prompt string to parse.
    
        Returns:
            A validated MidjourneyPrompt object.
    
        Raises:
            ValueError: If the prompt is invalid or missing required components.
        """
        # Extract image URLs
        images, remaining_text = extract_image_urls(prompt)
    
        # Split into text and parameters
        if " --" in remaining_text:
            text_part, param_part = remaining_text.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg)
        else:
            text_part = remaining_text.strip()
            parameters = {}
    
        # Create and validate the prompt object
        try:
            return MidjourneyPrompt(
                text=text_part,
                image_prompts=images,
                **parameters,
            )
        except Exception as e:
            msg = f"Failed to create prompt object: {e!s}"
>           raise ValueError(msg)
E           ValueError: Failed to create prompt object: 2 validation errors for MidjourneyPrompt
E           character_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type
E           style_reference
E             Input should be a valid list [type=list_type, input_value='[]', input_type=str]
E               For further information visit https://errors.pydantic.dev/2.10/v/list_type

src/midjargon/core/parser.py:160: ValueError
============================= slowest 10 durations =============================

(10 durations < 0.005s hidden.  Use -vv to show these durations.)
=========================== short test summary info ============================
FAILED tests/cli/test_main.py::test_basic_prompt - TypeError: MidjargonCLI.js...
FAILED tests/cli/test_main.py::test_permutations - ValueError: No JSON found ...
FAILED tests/cli/test_main.py::test_raw_output - TypeError: MidjargonCLI.json...
FAILED tests/cli/test_main.py::test_json_output_formatting - TypeError: Midja...
FAILED tests/cli/test_main.py::test_invalid_input - TypeError: MidjargonCLI.j...
FAILED tests/cli/test_main.py::test_parameter_validation - TypeError: Midjarg...
FAILED tests/cli/test_main.py::test_image_url_handling - TypeError: Midjargon...
FAILED tests/cli/test_main.py::test_no_color_output - TypeError: MidjargonCLI...
FAILED tests/cli/test_main.py::test_complex_prompt - TypeError: MidjargonCLI....
FAILED tests/cli/test_main.py::test_personalization_parameter - TypeError: Mi...
FAILED tests/cli/test_main.py::test_numeric_range_permutations - TypeError: M...
FAILED tests/cli/test_main.py::test_nested_parameter_permutations - TypeError...
FAILED tests/cli/test_main.py::test_mj_command - SystemExit: 1
FAILED tests/cli/test_main.py::test_fal_command - SystemExit: 1
FAILED tests/cli/test_main.py::test_perm_command - ValueError: No JSON found ...
FAILED tests/core/test_input.py::test_basic_input - AssertionError: assert Pr...
FAILED tests/core/test_input.py::test_single_permutation - AssertionError: as...
FAILED tests/core/test_input.py::test_empty_input - AssertionError: assert Pr...
FAILED tests/core/test_input.py::test_multiple_permutations - AssertionError:...
FAILED tests/core/test_input.py::test_nested_permutations - ValueError: Faile...
FAILED tests/core/test_input.py::test_escaped_braces - AssertionError: assert...
FAILED tests/core/test_input.py::test_escaped_commas - AssertionError: assert...
FAILED tests/core/test_input.py::test_unmatched_braces - ValueError: Unclosed...
FAILED tests/core/test_input.py::test_empty_permutation - ValueError: Empty p...
FAILED tests/core/test_input.py::test_whitespace_handling - AssertionError: a...
FAILED tests/core/test_input.py::test_expand_midjargon_input - AssertionError...
FAILED tests/core/test_input.py::test_handling_escaped_characters - Assertion...
FAILED tests/core/test_parameters.py::test_basic_parameter_parsing - Assertio...
FAILED tests/core/test_parameters.py::test_flag_parameters - assert True is None
FAILED tests/core/test_parameters.py::test_parameter_with_multiple_values - A...
FAILED tests/core/test_parameters.py::test_parameter_with_spaces - ValueError...
FAILED tests/core/test_parameters.py::test_mixed_parameters - ValueError: Fai...
FAILED tests/core/test_parameters.py::test_shorthand_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_niji_version_parameter - Assertion...
FAILED tests/core/test_parameters.py::test_version_parameter - AssertionError...
FAILED tests/core/test_parameters.py::test_personalization_parameter - assert...
FAILED tests/core/test_parameters.py::test_reference_parameters - AssertionEr...
FAILED tests/core/test_parameters.py::test_invalid_parameters - Failed: DID N...
FAILED tests/core/test_parameters.py::test_parse_parameters - AssertionError:...
FAILED tests/core/test_parameters.py::test_flag_parameters_handling - assert ...
FAILED tests/core/test_parameters.py::test_special_seed_values - ValueError: ...
FAILED tests/core/test_parameters.py::test_reference_url_handling - Assertion...
FAILED tests/core/test_parameters.py::test_niji_version_handling - AssertionE...
FAILED tests/core/test_parser.py::test_basic_prompt_parsing - KeyError: 'aspect'
FAILED tests/core/test_parser.py::test_prompt_with_image_url - AssertionError...
FAILED tests/core/test_parser.py::test_prompt_with_multiple_image_urls - Asse...
FAILED tests/core/test_parser.py::test_prompt_with_parameters - KeyError: 'as...
FAILED tests/core/test_parser.py::test_prompt_with_empty_parameters - assert ...
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_aspect_ratio
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_invalid_values
FAILED tests/engines/midjourney/test_midjourney_parser.py::test_empty_values
FAILED tests/integration/test_workflow.py::test_basic_workflow - ValueError: ...
FAILED tests/integration/test_workflow.py::test_permutation_workflow - ValueE...
FAILED tests/integration/test_workflow.py::test_image_workflow - ValueError: ...
FAILED tests/integration/test_workflow.py::test_parameter_workflow - ValueErr...
FAILED tests/integration/test_workflow.py::test_new_parameters_workflow - Val...
FAILED tests/integration/test_workflow.py::test_weighted_prompts_workflow - V...
FAILED tests/integration/test_workflow.py::test_error_workflow - AssertionErr...
FAILED tests/integration/test_workflow.py::test_complex_workflow - ValueError...
FAILED tests/integration/test_workflow.py::test_permutations_with_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_flag_parameters
FAILED tests/integration/test_workflow.py::test_permutations_with_complex_parameters
FAILED tests/integration/test_workflow.py::test_cli_mj_command - SystemExit: 1
FAILED tests/integration/test_workflow.py::test_cli_fal_command - SystemExit: 1
FAILED tests/integration/test_workflow.py::test_cli_perm_command - ValueError...
FAILED tests/test_core.py::test_prompt_with_parameters - AssertionError: asse...
FAILED tests/test_core.py::test_invalid_parameters - Failed: DID NOT RAISE <c...
FAILED tests/test_core.py::test_weighted_prompts - AssertionError: assert 1 == 2
FAILED tests/test_core.py::test_combined_features - AssertionError: assert 4 ...
FAILED tests/test_core.py::test_character_reference - AssertionError: assert ...
FAILED tests/test_core.py::test_prompt_to_string - ValueError: Failed to crea...
======================== 71 failed, 21 passed in 1.11s =========================
```

## File: LICENSE (Size: 1.04 KB)

```
MIT License

Copyright (c) 2025 Adam Twardoch

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## File: LOG.md (Size: 5.23 KB)

```
---
this_file: LOG.md
---
# Implementation Log

## Overview

The midjargon package is a robust Python library for parsing and manipulating Midjourney-style prompts. The implementation follows a modular architecture with clear separation of concerns.

## Core Components Status

### 1. Core Modules [❌ FAILING]

#### 1.1 Parser (`src/midjargon/core/parser.py`) [❌]

- ❌ Main prompt parser failing with multiple issues:
  - Unclosed quotation errors in parameter parsing
  - Model validation errors
  - Type conversion issues
  - Missing attribute access
- 🚧 Needs complete overhaul of parameter parsing and model handling

#### 1.2 Parameters (`src/midjargon/core/parameters.py`) [❌]

- ❌ Multiple parameter handling issues:
  - Type conversion failures (numeric vs string)
  - Flag parameter handling broken
  - Reference parameter validation failing
  - Version parameter issues
- 🚧 Requires complete rework of parameter validation and type conversion

#### 1.3 Permutations (`src/midjargon/core/permutations.py`) [❌]

- ❌ Permutation expansion failing:
  - Weighted prompts not working
  - Nested groups failing
  - Escape character issues
  - Whitespace handling problems
- 🚧 Needs complete revision of permutation logic

#### 1.4 Input (`src/midjargon/core/input.py`) [❌]

- ❌ Input processing issues:
  - URL validation failing
  - Basic sanitization issues
  - Multi-prompt handling broken
  - Weight parsing failing
- 🚧 Requires complete rework of input processing

### 2. Engine-Specific Modules [❌ FAILING]

#### 2.1 Midjourney Engine (`src/midjargon/engines/midjourney/`) [❌]

- ❌ Multiple critical issues:
  - MidjourneyPrompt model attribute access failing
  - Parameter validation errors
  - Type conversion issues
  - Reference handling broken
- 🚧 Needs complete overhaul of model implementation

#### 2.2 Fal.ai Engine (`src/midjargon/engines/fal/`) [❌]

- ❌ Similar issues to Midjourney engine:
  - Model attribute access failing
  - Parameter mapping issues
  - Type conversion problems
  - Validation errors
- 🚧 Requires complete rework

### 3. CLI Interface (`src/midjargon/cli/`) [❌ FAILING]

- ❌ Multiple command implementation issues:
  - JSON output formatting broken
  - Command parameter handling failing
  - Error handling inadequate
  - Missing functionality
- 🚧 Needs complete revision of command handling and output formatting

## Test Suite Status [❌ FAILING]

### Critical Issues (2024-03-21)

1. Model Implementation Issues
   - MidjourneyPrompt missing key attributes ('images', 'parameters')
   - Incorrect attribute access patterns
   - Type conversion failures
   - Validation errors in model fields

2. Parameter Handling Issues
   - Failed parameter parsing and validation
   - Incorrect type conversions
   - Problems with reference parameters
   - Flag parameter handling broken
   - Version parameter validation failing

3. CLI Implementation Issues
   - JSON output formatting broken
   - Missing command implementations
   - Incorrect parameter handling
   - Output formatting inconsistencies

4. Core Functionality Issues
   - Permutation expansion failing
   - Weighted prompt handling broken
   - Nested permutation issues
   - Escape character processing failing

5. Engine-Specific Issues
   - MidjourneyParser initialization failing
   - Parameter validation errors
   - Type conversion mismatches
   - Reference handling broken

## Next Steps

1. Fix Model Implementation
   - Implement proper attribute access
   - Fix type conversion
   - Add proper validation
   - Fix reference handling

2. Fix Parameter Handling
   - Rewrite parameter parsing
   - Fix type conversion
   - Implement proper validation
   - Add proper error handling

3. Fix CLI Implementation
   - Fix command handling
   - Fix output formatting
   - Add proper error handling
   - Implement missing functionality

4. Fix Core Functionality
   - Fix permutation expansion
   - Fix weighted prompts
   - Fix escape handling
   - Add proper validation

See TODO.md for detailed next steps and implementation plan.

## Dependencies [✅]

All core dependencies are in place:
- ✅ pydantic (>=2.0.0): Data validation
- ✅ rich (>=13.0.0): CLI output formatting
- ✅ fire (>=0.5.0): CLI interface
- ✅ python-box (>=7.3.2): Dictionary operations
- ✅ fal-client (>=0.5.8): Fal.ai integration

## Development Guidelines [✅]

1. Type Safety [✅]
   - ✅ Full type hints
   - ✅ Mypy validation
   - ✅ Runtime type checking

2. Code Quality [✅]
   - ✅ Ruff for linting/formatting
   - ✅ Pre-commit hooks
   - ✅ Comprehensive docstrings

3. Testing [🚧]
   - ✅ Pytest for testing
   - ✅ Coverage reporting
   - 🚧 Fixing test failures
   - [ ] Benchmark tests

4. Documentation [🚧]
   - ✅ Inline documentation
   - [ ] API documentation
   - [ ] Error handling guide

## Next Steps

See TODO.md for detailed next steps and future plans.

## Notes

- Core functionality is complete and working well
- CLI interface has been enhanced with no-color support and consistent formatting
- Need to focus on engine implementations next
- Consider adding more advanced features after engines
- Documentation needs expansion
- Performance optimization can wait until after engines
- Parameter handling has been improved with better type conversion and validation
```

## File: README.md (Size: 3.63 KB)

```
---
this_file: README.md
---

# Midjargon

`midjargon` is a powerful Python library designed to simplify the parsing and manipulation of Midjourney-style prompts. 

Midjourney uses a specialized syntax for prompts, which we call “midjargon”. It allows for `{}` permutation and for specifying of parameters using an `--` prefix. This syntax is useful for other applications, such as constructing prompts for Flux models. 

The `midjargon` package reads midjargon prompts, deconstructs them into manageable components, ensuring type-safe operations and comprehensive validation. It also converts midjargon prompts into other formats, such as Fal.ai, and serializes them back into the Midjourney format.

_It’s work in progress, but already pretty usable._

## Features

- **Robust Prompt Parsing**:
  - Parses Midjourney prompts into structured components (text, parameters, image URLs)
  - Type-safe parsing with comprehensive validation
  - Supports complex prompt structures and syntax

- **Advanced Permutation Support**:
  - Handles nested permutations in curly braces `{option1, option2}`
  - Supports escaped characters in permutations (e.g., `\,` for literal commas)
  - Automatically expands all possible combinations

- **Comprehensive Parameter Handling**:
  - Validates parameter names and values
  - Supports numeric ranges and type conversion
  - Processes boolean flags and multi-value parameters

- **Image URL Processing**:
  - Extracts and validates image URLs
  - Supports multiple image inputs and file extensions

- **Multi-prompt Support**:
  - Handles weighted prompts using `::`
  - Processes multiple variations in a single input

- **Type Safety**:
  - Full type hints throughout the codebase
  - Pydantic models for robust validation

- **Rich CLI Interface**:
  - Fire-based command-line interface with rich output
  - CLI commands for converting prompts to different formats (Midjourney, Fal.ai)
  - JSON output option for automation

## Installation

```bash
pip install midjargon
```

## Quick Start

### Basic Usage

```python
from midjargon import parse_midjourney_dict, expand_midjargon_input

# Parse a simple prompt
prompt = "a serene landscape --ar 16:9 --stylize 100"
result = expand_midjargon_input(prompt)[0]
validated = parse_midjourney_dict(result)
```

### CLI Usage

Midjargon exposes a single CLI interface with multiple commands. Here are some examples:

```bash
# You can run the tool with uv without installing dependencies: 
uv run midjargon

# You can also run it directly: 
midjargon

# Or using your Python interpreter:
python -m midjargon
```

To get help on the commands: 

```bash
# Help for Fal.ai conversion (convert prompt to Fal.ai format)
midjargon fal --help

# Help for Midjourney conversion
midjargon mj --help

# Help for JSON parsing (MidjargonDict output)
midjargon json --help

# Help for permutation expansion
midjargon perm --help
```

You can also run commands directly:

```bash
# Convert prompt to Fal.ai format:
midjargon fal "a portrait of a cat --ar 1:1"

# Parse prompt to MidjargonDict:
midjargon json "a futuristic city --chaos 20 --stylize 200"

# Convert prompt to Midjourney format:
midjargon mj "a landscape --ar 16:9 --tile"

# Expand prompt permutations:
midjargon perm "a {red, blue} bird on a tree"
```

## Project Structure

TODO: Add a file tree

## Contributing

Contributions are welcome! Please submit a pull request with your changes.

### Development Setup

1. Clone the repository
2. Install dependencies:
   ```bash
   uv pip install --system --upgrade ".[all]"
   ```
3. Run tests:
   ```bash
   hatch test
   ```
4. Format code:
   ```bash
   hatch fmt
   ```

## License

MIT License - See LICENSE file for details
```

## File: TODO.md (Size: 4.34 KB)

```
---
this_file: TODO.md
---
# Midjargon Package Implementation Status

## Critical Issues (Priority 1)

1. 🚧 Fix Pydantic Model Implementation
   - [ ] Fix MidjourneyPrompt model
     - [ ] Add proper 'images' property getter/setter
     - [ ] Add proper 'parameters' property getter/setter
     - [ ] Fix model validation for all fields
     - [ ] Ensure proper type conversion in model fields
     - [ ] Fix character reference validation
     - [ ] Add proper model field documentation
   - [ ] Fix parameter type conversion
     - [ ] Ensure numeric parameters maintain correct types (int/float)
     - [ ] Fix version parameter validation (v4, v5, etc.)
     - [ ] Fix style reference parameter handling
     - [ ] Add proper validation for all parameter types
   - [ ] Fix model attribute access patterns
     - [ ] Implement proper __getattr__ handling
     - [ ] Fix model field access methods
     - [ ] Add proper validation error messages

2. 🚧 Fix Core Parser Issues
   - [ ] Fix parameter parsing
     - [ ] Fix quotation handling in parameters
     - [ ] Fix numeric parameter parsing
     - [ ] Fix flag parameter handling
     - [ ] Add proper error messages for parsing failures
   - [ ] Fix permutation expansion
     - [ ] Fix weighted prompt handling
     - [ ] Fix nested permutation groups
     - [ ] Fix whitespace handling in permutations
     - [ ] Add proper escape character handling
   - [ ] Fix input validation
     - [ ] Add proper input sanitization
     - [ ] Fix URL validation
     - [ ] Add proper error handling for invalid inputs

3. 🚧 Fix CLI Implementation
   - [ ] Fix command implementations
     - [ ] Fix 'json' command output formatting
     - [ ] Fix 'mj' command parameter handling
     - [ ] Fix 'fal' command implementation
     - [ ] Fix 'perm' command implementation
   - [ ] Fix output formatting
     - [ ] Fix JSON output structure
     - [ ] Fix permutation output format
     - [ ] Add proper error formatting
     - [ ] Ensure consistent output across all commands
   - [ ] Add proper error handling
     - [ ] Add descriptive error messages
     - [ ] Add proper error recovery
     - [ ] Add validation error formatting

## High Priority Tasks (Priority 2)

1. 🚧 Fix Engine Implementation
   - [ ] Fix MidjourneyParser
     - [ ] Fix initialization issues
     - [ ] Add proper parameter validation
     - [ ] Fix type conversion
     - [ ] Add proper reference handling
   - [ ] Fix FalParser
     - [ ] Fix initialization issues
     - [ ] Add proper parameter mapping
     - [ ] Fix type conversion
     - [ ] Add proper validation

2. 🚧 Fix Test Suite
   - [ ] Fix core functionality tests
     - [ ] Fix parameter parsing tests
     - [ ] Fix model validation tests
     - [ ] Fix permutation tests
     - [ ] Add missing edge cases
   - [ ] Fix CLI tests
     - [ ] Fix command tests
     - [ ] Fix output format tests
     - [ ] Add error handling tests
   - [ ] Fix integration tests
     - [ ] Fix workflow tests
     - [ ] Fix engine-specific tests
     - [ ] Add missing scenarios

## Medium Priority Tasks (Priority 3)

1. 🚧 Documentation Updates
   - [ ] Update API documentation
     - [ ] Document model attributes
     - [ ] Document parameter handling
     - [ ] Document CLI commands
   - [ ] Add error handling guide
     - [ ] Document common errors
     - [ ] Add troubleshooting steps
     - [ ] Add validation rules
   - [ ] Update examples
     - [ ] Add CLI usage examples
     - [ ] Add parameter examples
     - [ ] Add error handling examples

2. 🚧 Code Quality Improvements
   - [ ] Add proper type hints
   - [ ] Add proper docstrings
   - [ ] Fix linting issues
   - [ ] Add proper logging
   - [ ] Add proper error messages

## Low Priority Tasks (Priority 4)

1. Performance Optimization
   - [ ] Profile code for bottlenecks
   - [ ] Optimize permutation expansion
   - [ ] Improve memory usage
   - [ ] Add caching where beneficial

2. Additional Features
   - [ ] Add support for custom engines
   - [ ] Implement prompt templates
   - [ ] Add prompt validation rules
   - [ ] Create prompt optimization suggestions

## Dependencies
- pydantic (>=2.0.0)
- rich (>=13.0.0)
- fire (>=0.5.0)
- python-box (>=7.3.2)
- fal-client (>=0.5.8)

## Development Guidelines
1. Maintain type safety
2. Follow code quality standards
3. Add comprehensive tests
4. Keep documentation updated
5. Consider performance
6. Handle errors gracefully
```

## File: dist/.gitkeep (Size: 0.00 KB)

```

```

## File: docs/specification.md (Size: 15.07 KB)

```
---
this_file: docs/specification.md
---

# **Midjourney Prompt Format Specification**

_2025-02-06 by Adam Twardoch, not affiliated with Midjourney_

Midjourney prompts use “midjargon”, a structured syntax to instruct the Midjourney models to generate images. A prompt consists of three main sections, in order:

1. **Image Reference (Optional)**
2. **Text Description (Required if no image is provided)**
3. **Parameters (Optional)**

Each section has defined syntax and placement requirements. Advanced features such as multi-prompts with weights, permutation prompts, personalization, and style or character references are integrated into the text description and parameters.

Midjourney supports two distinct types of stylizations. The official Midjourney documentation often ambiguously calls both “style”: 

- Style reference
- Personalization

## Parameters

Parameters are modifiers appended at the end of the prompt that adjust various aspects of image generation. Parameters always begin with two hyphens `--` and may accept a value. The order of parameters (after the text description) is flexible.

Terms that follow a parameter `--a` are treated as its arguments (values). If `--a` is directly followed by another parameter `--b`, then `--a` is considered a boolean flag. 

---

## Choosing the model

### Midjourney series (`--v` or `--version`)

Uses the specified version of the general Midjourney model series. 

#### Syntax

```
--v <version_number>
```

#### Values

- `5`, `5.1`, `5.2`, `6`, `6.1`

> Example

```
--v 6
```

### Niji series (`--niji`)

Uses the specified version of the Niji model series, optimized for anime and illustrative styles.

#### Syntax

```
--niji <version_number>
```

- Values: `5`, `6`

> Example

```
--niji 6
```

### Model mode (`--style`)

Applies specific model mode. 

```
--style <mode_name>
```

- Mode name can be `raw`, it reduces automatic personalization.

> Example

```
--style raw
```

## Using images

### Image references

One or more direct image URLs or attachments used to influence the generated image's style, color, composition, and content.

Must appear at the very **start** of the prompt.

Each image can be:

- A direct image URL ending with `.png`, `.jpg`, `.jpeg`, `.gif`, or `.webp`.
- An attached image in Discord or uploaded via the Midjourney web interface.

Multiple images are separated by whitespace.

> Example

```
https://example.com/image1.jpg https://example.com/image2.png
```

#### Image weight (`--iw`)

`--iw <value>`

Adjusts the influence of all image references relative to the text prompt. 

- Value Range `0.0` to `3.0` (float)
- Default: `1.0` (varies by model)

> Example

```
--iw 1.5
```

As with other parameters, `--iw` must be placed after the text description, even though it refers to the image references that are placed at the very start of the prompt.

### Character reference (`--cref`)

`--cref <url1> [<url2> ...]`

Uses images as character references to maintain consistency.

#### Character weight (`--cw`)

Adjusts the strength of the character reference.

`--cw <value>`

- Value range: `0` to `100` (integer)
- Default: `100`

The character weight `0` typically only copies the face. 

> Example

```
--cref https://example.com/character.jpg --cw 50
```

### Style reference (`--sref`)

The `--sref` parameter uses images as style references without influencing content. It applies the visual characteristics of a specific images or stylization code. 

In effect, it pulls the generated image towards a specific look that is expressed explicitly (via the image) or less directly (via the stylization code).

```
--sref <url|code> [<url|code> ...]
```

One or more image URLs or a specific stylization CODE (the CODE acts as a shorthand for a predefined image reference)

#### Style weight (`--sw`)

Adjusts the strength of the style reference.

`--sw <value>`

- Value Range: `0` to `1000` (integer)

#### Style version (`--sv`)

Selects different style reference algorithms.

`--sv <value>`

- Values: `1`, `2`, `3`, `4`

> Example

```
--sref https://example.com/style.jpg --sw 200 --sv 2
```

#### Random style reference

`--sref random`

Generates a random style reference.

### Persona reference (`--p`)

References one or more “personas”, personalized style profiles, which pull the generated image towards the preferences or a general style of a particular user or moodboard, with the degree controlled by `--s`.

- Without specifying a persona code, `--p` uses your current personalization profile.
- Providing one or more persona codes of a personalization profile or moodboard (e.g., `--p p123456789`) applies a specific personalization.

#### Personalization weight (`--s`)

```
--stylize <value>
```

The `--s` (`--stylize`, or personalization weight) parameter controls the degree of personalization. 

- If a persona with a code is provided, the `--s` parameter controls how much the generated image will be pulled towards that persona.
- If the personalization switch is used (`--p`) without a code, the `--s` parameter controls how much the generated image will be pulled towards your current personalization profile.
- If the personalization switch is not used (no `--p` at all), the `--s` parameter controls how much the generated image will be pulled towards the model’s general “persona” (overall aesthetic preference).

- Value range: `0` to `1000` (integer)
- Default: `100`

The value of `0` applies minimal personalization, though certain influence of the model remains. To reduce the model influence, and have purer personalization use `--style raw` together with a low `--s` value.

> Example:

```
--p p123456789 --s 500 --style raw
```

## Describing the image

A natural language description of the desired image, specifying the subject, mood, style, and other artistic details.

### Clarity & specificity

Use specific adjectives, nouns, and phrases. Describe the subject, medium, environment, lighting, color, mood, and composition.

### Positive framing

Emphasize what should appear in the image rather than what should be excluded (exclusions are handled by the `--no` parameter).

### Tokenization

The text is internally tokenized; word order and precision are important.

### Text generation

Use double quotation marks `"` around words or phrases to specify exact text you want to appear in the image.

> Example

```
A neon sign that says "Open"
```

### Negative text description (`--no`)

Signals to the model elements or aspects that you don’t want to see in the image. 

```
--no <item1, item2, ...>
```

- Value: Comma-separated list of terms

> Example:

```
--no cars, trees, watermarks
```

## Image layout

### Aspect ratio (`--ar`)

Sets the width-to-height ratio of the image

```
--ar <width>:<height>
```

- Value: Two integers separated by a colon
- Default: `1:1`

> Example:

```
--ar 16:9
```

### Tile (`--tile`)

Creates images that are seamlessly tileable

```
--tile
```

- Value: None (boolean flag)

> Example:

```
--tile
```

---

## Separating and prioritizing

Use a double colon `::` to separate concepts, optionally followed by a weight. If omitted, the weight defaults to 1.

```
concept1 ::<weight1> concept2 ::<weight2> ...
```

- Weight values can be floating-point numbers within the range `-10.0` to `10.0`.
- Negative weights (e.g., `::-0.5`) de-emphasize or exclude a concept.

### Purpose

This syntax allows you to balance and blend different concepts in one prompt. Weights are normalized internally to maintain their proportional relationships.

### Examples

```
futuristic city ::2 cyberpunk skyline ::1
beautiful landscape ::1.5 mountains ::-0.5 water
serene lake ::2 foggy mountains ::1
portrait ::1.5 dramatic lighting ::1 dark background ::0.8
still life painting ::1 fruit ::-0.5
```

---

## Variation

### Chaos (`--chaos` or `--c`)

Controls variation or unpredictability in the output

```
--chaos <value>
```

- Value range: `0` to `100` (integer)
- Default: `0`

> Example

```
--chaos 50
```

### Weird (`--weird` or `--w`)

Introduces unconventional aesthetics

```
--weird <value>
```

- Value range: `0` to `3000` (integer)
- Default: `0`

> Example

```
--weird 1000
```

---

## Generation process

### Seed (`--seed`)

Sets a specific seed to reproduce outcomes

```
--seed <value>
```

- Value range: `0` to `4294967295` (integer)

> Example:

```
--seed 123456789
```

### Prompt permutation

Prompt permutation allows you to quickly generate multiple prompts by including comma-separated options within curly braces `{}`. The surrounding fixed text is repeated with each provided option to create separate prompt variations.

Enclose a comma-separated list of options within curly braces. 

```
A {red, blue, green} car
```

This expands to 3 prompts:

- `A red car`
- `A blue car`
- `A green car`

Repeat permutations.

```
A {red, blue} {car, truck} with {chrome, matte} finish
```

This expands to 2×2×2=8 prompts. 

Permute parameters.

```
portrait --ar {1:1, 16:9} --s {100, 500, 1000}
```

This expands to 2×3=6 prompts. 

Nest permutations.

```
{realistic, artistic} scene --v {5.2, 6 {, --style raw}} 
```

This expands to 2×(2+1)=6 prompts:

- `realistic scene --v 5.2`
- `realistic scene --v 6`
- `realistic scene --v 6 --style raw`
- `artistic scene --v 5.2`
- `artistic scene --v 6`
- `artistic scene --v 6 --style raw`

Within a permutation group, use commas to separate portions, prefix a comma with a backslash to actually have it in the expanded prompt.

```
A {bright\, vibrant, dark\, moody} atmosphere
```

This expands to 2 prompts:

- `A bright, vibrant atmosphere`
- `A dark, moody atmosphere`

The total number of permutations may be limited based on subscription tier. Permutation prompts are only available in Fast Mode.

Permutation is great for exploring various syntaxes and prompt structures: 

```
beautiful woman{::, ::2, ::0.3, \,} sports car
```

expands into

- `beautiful woman:: sports car`
- `beautiful woman::2 sports car`
- `beautiful woman::0.3 sports car`
- `beautiful woman, sports car`



### Repeat (`--repeat` or `--r`)

The `--r` parameter produces multiple prompts, similarly to prompt permutation, but the multiplication happens on the model side. It can be combined with permutation prompts.

If a prompt includes the `--r` parameter, the model runs the same prompt multiple times to generate variations. It can be used with `--sref random` to generate different style references each time. 

```
--repeat <number>
```

- Value range: Basic Subscribers: 2–4, Standard Subscribers: 2–10, Pro/Mega Subscribers: 2–40

> Example:

```
--repeat 5
```

## Quality and speed

### Quality (`--quality` or `--q`)

Controls the time spent generating an image; affects detail

```
--quality <value>
```

- Values: `0.25`, `0.5`, `1` (default)

> Example

```
--quality 0.5
```

#### Turbo Mode (`--turbo`)

Generates images faster using additional GPU resources

```
--turbo
```

- Value: None (boolean flag)

#### Relax Mode (`--relax`)

Generates images in relaxed mode without consuming GPU time

```
--relax
```

- Value: None (boolean flag)

### Stop (`--stop`)

Stops image generation at a specified percentage of completion for different artistic effects

```
--stop <value>
```

- Value range: `10` to `100` (integer)
- Default: `100`

> Example:

```
--stop 80
```

---

## Summary

- **Order matters**: Image prompts come first (if used), followed by the text description, and then all parameters.
- **Parameter prefix**: Every parameter starts with `--` and, if required, is followed by a space and its value.
- **Advanced techniques**: Use multi-prompts with `::` and permutation prompts with `{}` to fine-tune creative direction and generate multiple variations.
- **Personalization and references**: `--sw` controls the weight of the style reference (`--sref`). `--s` controls the weight of personalization (`--p`, or of the default persona when `--p` is not provided). Style reference and personalization operate independently: each pulls the image in a distinct stylistic direction. To test the full effect of style reference without personalization influence, use: `--style raw --s 0`.
- **Model and feature dependencies**: Some parameters (e.g., `--iw`, `--sv`, `--p`, permutation prompts) are model-specific or depend on the subscription tier or mode (e.g., Fast Mode).
- **Text generation**: Use double quotation marks `"` to specify exact text to appear in the image.

## Prompt examples

1. **Basic Text-Only Prompt:**

```
/imagine prompt: A serene sunset over the ocean
```

2. **Prompt with Image URLs, Text, and Parameters:**

```
/imagine prompt: https://example.com/inspiration.jpg A portrait of a wise old man --style raw --v 5.1
```

3. **Prompt with Character and Style References:**

```
/imagine prompt: A hero in battle --cref https://example.com/hero.png --cw 75 --sref https://example.com/style.jpg --sw 150
```

4. **Multi-Prompt with Weighting:**

```
/imagine prompt: futuristic city ::2 cyberpunk skyline ::1 --chaos 20
```

5. **Permutation Prompt for Multiple Variations:**

```
/imagine prompt: A {red, blue, green} bird on a {flower, leaf} --ar {16:9, 1:1}
```

6. **Prompt with Personalization and Parameters:**

```
/imagine prompt: A vibrant garden in spring --p p123456789 --stylize 500 --seed 987654321
```

7. **Complex Mixed Prompt:**

```
/imagine prompt: {realistic, artistic} portrait of a {young, old} {man, woman} --style {raw, expressive} --v 6 --ar 1:1 --stylize {100, 1000}
```

8. **Prompt with Exclusions and Turbo Mode:**

```
/imagine prompt: A futuristic landscape at dusk --ar 21:9 --stylize 300 --chaos 50 --seed 987654321 --no buildings, cars --turbo
```

---

## Notes for parser implementers

### Parsing order

1. **Permutation:**

- Process all permutation groups `{...}`.
- Handle nested permutations.
- Expand into individual prompts.
- `a{b, c}d` should expand to `abd` `acd`. The spaces right around the `{` and `}` should be treated as they are. Spaces around the separating commas can be collapsed fully, as if there is no space.
- `\{` `\}` `\,` must produce the literal `{` `}` `,` in the expanded permutations

2. **Image referece:**

- Identify and validate image URLs or attachments at the start.
- Check for supported file formats.
- Handle multiple images.

3. **Text description:**

- Extract main prompt text.
- Segment text by weight markers `::`.
- Handle escaped characters.
- Identify text in double quotes `"` for explicit text generation.

4. **Parameter Processing:**

- Extract parameters starting with `--`.
- Parse parameter values.
- Handle boolean flags.
- Validate parameter ranges.
- Values should be typically strings, unless it’s obviously an int or float. Version "number" should be kept a string.

### Boolean Parameters

- If a parameter is followed by another parameter (e.g., `--tile --ar 16:9`), it's treated as a boolean flag.

### Multi-Value Parameters

- Some parameters accept multiple values (e.g., `--no cars, trees`).

### Parameter Validation

- Numeric ranges are enforced.
- Aspect ratios must be valid integers.
- Version numbers must be supported.
- Style names and codes must be recognized.

### Error handling

The parser should handle common errors gracefully:

- Invalid URL formats.
- Malformed permutation syntax.
- Invalid parameter values.
- Missing required components.
- Unsupported parameter combinations.
```

## File: examples/basic_usage.py (Size: 2.75 KB)

```
#!/usr/bin/env python3
# this_file: examples/basic_usage.py

"""
Example script demonstrating basic usage of the midjargon package.
"""

from rich.console import Console
from rich.panel import Panel

from midjargon.core.input import expand_midjargon_input
from midjargon.core.parser import parse_midjargon_prompt

console = Console()


def main():
    # Example 1: Basic prompt parsing
    console.print("\n[bold blue]Example 1: Basic Prompt[/]")
    prompt = "a beautiful landscape --ar 16:9 --stylize 200"
    result = parse_midjargon_prompt(prompt)
    console.print(
        Panel(
            f"Text: {result.text}\n"
            f"Aspect Ratio: {result.parameters.aspect}\n"
            f"Stylize: {result.parameters.stylize}"
        )
    )

    # Example 2: Using image references
    console.print("\n[bold blue]Example 2: Image Reference[/]")
    prompt = "https://example.com/image.jpg a photo in this style --stylize 100"
    result = parse_midjargon_prompt(prompt)
    console.print(
        Panel(
            f"Text: {result.text}\n"
            f"Image URL: {result.images[0].url if result.images else 'None'}\n"
            f"Stylize: {result.parameters.stylize}"
        )
    )

    # Example 3: Permutations
    console.print("\n[bold blue]Example 3: Permutations[/]")
    prompt = "a {red, blue} bird on a {green, yellow} tree"
    variants = expand_midjargon_input(prompt)
    for i, variant in enumerate(variants, 1):
        console.print(f"Variant {i}: {variant.prompt.text}")

    # Example 4: Weighted prompts
    console.print("\n[bold blue]Example 4: Weighted Prompts[/]")
    prompt = "first style::0.7 second style::0.3"
    variants = expand_midjargon_input(prompt)
    for variant in variants:
        console.print(Panel(f"Text: {variant.prompt.text}\nWeight: {variant.weight}"))

    # Example 5: Style references
    console.print("\n[bold blue]Example 5: Style References[/]")
    prompt = "test --sref p123456 --sw 200"
    result = parse_midjargon_prompt(prompt)
    if result.parameters.style_reference:
        console.print(
            Panel(
                f"Text: {result.text}\n"
                f"Style Code: {result.parameters.style_reference.code}\n"
                f"Weight: {result.parameters.style_reference.weight}"
            )
        )

    # Example 6: Combined features
    console.print("\n[bold blue]Example 6: Combined Features[/]")
    prompt = "a {vintage, modern} {portrait, landscape}::0.6 another style::0.4"
    variants = expand_midjargon_input(prompt)
    console.print(f"Total variants: {len(variants)}")
    for i, variant in enumerate(variants, 1):
        console.print(
            Panel(
                f"Variant {i}:\nText: {variant.prompt.text}\nWeight: {variant.weight}"
            )
        )


if __name__ == "__main__":
    main()
```

## File: package.toml (Size: 0.43 KB)

```
# Package configuration
# this_file: package.toml
[package]
include_cli = true      # Include CLI boilerplate
include_logging = true  # Include logging setup
use_pydantic = true     # Use Pydantic for data validation
use_rich = true         # Use Rich for terminal output

[features]
mkdocs = false          # Enable MkDocs documentation
vcs = true              # Initialize Git repository
github_actions = true   # Add GitHub Actions workflows
```

## File: pyproject.toml (Size: 5.08 KB)

```
# this_file: pyproject.toml
[project]
classifiers = [
  "Development Status :: 4 - Beta",
  "Programming Language :: Python",
  "Programming Language :: Python :: 3.10",
  "Programming Language :: Python :: 3.11",
  "Programming Language :: Python :: 3.12",
  "Programming Language :: Python :: Implementation :: CPython",
  "Programming Language :: Python :: Implementation :: PyPy",
]
description = ""
dynamic = ["version"]
keywords = []
license = "MIT"
name = "midjargon"
readme = "README.md"
requires-python = ">=3.10"
dependencies = [
  "pydantic>=2.0.0",
  "rich>=13.0.0",
  "fire>=0.5.0",
  "python-box>=7.3.2",
  "fal-client>=0.5.8",
]

[project.optional-dependencies]
all = [
  "pre-commit>=3.6.0",
  "ruff>=0.1.0",
  "mypy>=1.0.0",
  "pytest>=7.0.0",
  "pytest-cov>=4.0.0","pyupgrade>=3.19.0"
]
dev = ["pre-commit>=3.6.0", "ruff>=0.1.0", "mypy>=1.0.0", "pyupgrade>=3.19.0"]
test = ["pytest>=7.0.0", "pytest-cov>=4.0.0"]

[project.scripts]
midjargon = "midjargon.__main__:main"

[[project.authors]]
email = "adam+github@twardoch.com"
name = "Adam Twardoch"


[project.urls]
Documentation = "https://github.com/twardoch/midjargon#readme"
Issues = "https://github.com/twardoch/midjargon/issues"
Source = "https://github.com/twardoch/midjargon"

[build-system]
build-backend = "hatchling.build"
requires = [
    "hatchling>=1.21.0", "hatch-vcs>=0.3.0"
  ]


[tool.coverage.paths]
midjargon = ["src/midjargon", "*/midjargon/src/midjargon"]
tests = ["tests", "*/midjargon/tests"]


[tool.coverage.report]
exclude_lines = ["no cov", "if __name__ == .__main__.:", "if TYPE_CHECKING:"]


[tool.coverage.run]
branch = true
omit = ["src/midjargon/__about__.py"]
parallel = true
source_pkgs = ["midjargon", "tests"]


[tool.hatch.build.hooks.vcs]
version-file = "src/midjargon/__version__.py"

[tool.hatch.build.targets.wheel]
packages = ["src/midjargon"]

[[tool.hatch.envs.all.matrix]]
python = ["3.10", "3.11", "3.12"]

[tool.hatch.envs.default]
dependencies = ["pytest", "pytest-cov", "mypy>=1.0.0", "ruff>=0.1.0"]

[tool.hatch.envs.default.scripts]
lint = ["ruff check src/midjargon tests", "ruff format src/midjargon tests"]
test = "pytest {args:tests}"
test-cov = "pytest --cov-report=term-missing --cov-config=pyproject.toml --cov=src/midjargon --cov=tests {args:tests}"
type-check = "mypy src/midjargon tests"

[tool.hatch.envs.lint]
dependencies = ["mypy>=1.0.0", "ruff>=0.1.0"]
detached = true

[tool.hatch.envs.lint.scripts]
all = ["style", "typing"]
fmt = ["fd -e py -x pyupgrade --keep-runtime-typing --py310-plus", "ruff format {args:.}", "ruff check --fix --unsafe-fixes {args:.}"]
style = ["fd -e py -x pyupgrade --keep-runtime-typing --py310-plus", "ruff format {args:.}", "ruff check --fix --unsafe-fixes {args:.}", "ruff format {args:.}"]
typing = "mypy --install-types --non-interactive {args:src/midjargon tests}"

[tool.hatch.envs.test]
dependencies = [
  "pytest>=7.0.0",
  "pytest-cov>=4.0.0",
  "midjargon[test]",
]

[tool.hatch.envs.test.scripts]
test = "pytest --cov=src/midjargon --cov-report=term-missing --cov-branch --no-cov-on-fail {args:tests}"
test-cov = "pytest --cov=src/midjargon --cov-report=term-missing --cov-branch --no-cov-on-fail {args:tests}"

[tool.hatch.version]
source = "vcs"

[tool.hatch.version.raw-options]
version_scheme = "post-release"

[tool.mypy]
check_untyped_defs = true
disallow_incomplete_defs = true
disallow_untyped_decorators = true
disallow_untyped_defs = true
no_implicit_optional = true
python_version = "3.10"
warn_no_return = true
warn_redundant_casts = true
warn_return_any = true
warn_unreachable = true
warn_unused_configs = true
warn_unused_ignores = true

[tool.pytest.ini_options]
addopts = "-v --durations=10 -p no:briefcase"
asyncio_mode = "auto"
console_output_style = "progress"
filterwarnings = ["ignore::DeprecationWarning", "ignore::UserWarning"]
log_cli = true
log_cli_level = "INFO"
markers = [
  "benchmark: marks tests as benchmarks (select with '-m benchmark')",
  "unit: mark a test as a unit test",
  "integration: mark a test as an integration test",
  "permutation: tests for permutation functionality",
  "parameter: tests for parameter parsing",
  "prompt: tests for prompt parsing",
]
norecursedirs = [
  ".*",
  "build",
  "dist",
  "venv",
  "__pycache__",
  "*.egg-info",
  "_private",
]

python_classes = ["Test*"]
python_files = ["test_*.py"]
python_functions = ["test_*"]
testpaths = ["tests"]

[tool.pytest-benchmark]
min_rounds = 100
min_time = 0.1
histogram = true
storage = "file"
save-data = true
compare = [
    "min",    # Minimum time
    "max",    # Maximum time
    "mean",   # Mean time
    "stddev", # Standard deviation
    "median", # Median time
    "iqr",    # Inter-quartile range
    "ops",    # Operations per second
    "rounds", # Number of rounds
] 

[tool.ruff]
line-length = 88
target-version = "py310"

[tool.ruff.lint]
extend-select = [
  "A",
  "ARG",
  "B",
  "C",
  "DTZ",
  "E",
  "EM",
  "F",
  "FBT",
  "I",
  "ICN",
  "ISC",
  "N",
  "PLC",
  "PLE",
  "PLR",
  "PLW",
  "Q",
  "RUF",
  "S",
  "T",
  "TID",
  "UP",
  "W",
  "YTT",
]
ignore = ["ARG001", "E501", "I001", "RUF001", "PLR2004", "EXE003", "ISC001"]

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["S101"]
```

## File: src/midjargon/__init__.py (Size: 0.58 KB)

```
# this_file: src/midjargon/__init__.py
"""
midjargon

A Python library for parsing and manipulating Midjourney prompts.
"""

__version__ = "0.1.0"

from midjargon.core.input import expand_midjargon_input
from midjargon.core.models import MidjourneyPrompt, PromptVariant
from midjargon.core.parser import parse_midjargon_prompt_to_dict
from midjargon.engines.midjourney import MidjourneyParser, parse_midjourney_dict

__all__ = [
    "MidjourneyParser",
    "MidjourneyPrompt",
    "PromptVariant",
    "expand_midjargon_input",
    "parse_midjargon_prompt_to_dict",
    "parse_midjourney_dict",
]
```

## File: src/midjargon/cli/__init__.py (Size: 0.04 KB)

```
# this_file: src/midjargon/cli/__init__.py
```

## File: src/midjargon/cli/main.py (Size: 4.90 KB)

```
#!/usr/bin/env -S uv run
# this_file: src/midjargon/cli/main.py
# /// script
# dependencies = ["fire", "rich"]
# ///

import sys
from typing import Any
from collections.abc import Sequence

import fire
from rich.console import Console

from midjargon.core.input import expand_midjargon_input
from midjargon.core.models import PromptVariant
from midjargon.engines.fal import FalParser
from midjargon.engines.midjourney import MidjourneyParser

# Set up console for output
console = Console()
error_console = Console(stderr=True)


def format_json_output(variants: Sequence[PromptVariant]) -> list[dict[str, Any]]:
    """Format variants as JSON output."""
    return [variant.prompt.model_dump() for variant in variants]


def format_rich_output(variants: Sequence[PromptVariant]) -> str:
    """Format variants as rich text output."""
    if len(variants) == 1:
        return variants[0].prompt.to_string()
    return "\n".join(f"{i + 1}. {v.prompt.to_string()}" for i, v in enumerate(variants))


class MidjargonCLI:
    """CLI interface for midjargon."""

    def json(self, prompt: str, no_color: bool = False) -> None:
        """Parse a prompt to MidjargonDict format.

        Args:
            prompt: The prompt to parse.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            format_json_output(variants)
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)

    def mj(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Midjourney format.

        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = MidjourneyParser()
            results = []
            for variant in variants:
                mj_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(mj_prompt.model_dump())

            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    params = " ".join(
                        f"--{k} {v}"
                        for k, v in result.items()
                        if k not in {"text", "image_prompts", "extra_params"}
                        and v is not None
                    )
                    console.print(
                        f"{result['text']} {params}",
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)

    def fal(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Convert a prompt to Fal.ai format.

        Args:
            prompt: The prompt to convert.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            parser = FalParser()
            results = []
            for variant in variants:
                fal_prompt = parser.parse_dict(variant.prompt.model_dump())
                results.append(fal_prompt.model_dump())

            if json_output:
                pass
            else:
                for i, result in enumerate(results):
                    if len(results) > 1:
                        console.print(f"{i + 1}. ", end="", highlight=not no_color)
                    console.print(
                        result["text"],
                        highlight=not no_color,
                    )
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)

    def perm(
        self, prompt: str, json_output: bool = False, no_color: bool = False
    ) -> None:
        """Expand permutations in a prompt.

        Args:
            prompt: The prompt to expand.
            json_output: Whether to output JSON.
            no_color: Whether to disable colored output.
        """
        try:
            variants = expand_midjargon_input(prompt)
            if json_output:
                format_json_output(variants)
            else:
                pass
        except Exception as e:
            error_console.print(f"[red]Error:[/red] {e!s}", highlight=not no_color)
            sys.exit(1)


def main() -> None:
    """Main entry point."""
    try:
        fire.Fire(MidjargonCLI)
    except Exception as e:
        error_console.print(f"[red]Error:[/red] {e!s}")
        sys.exit(1)


if __name__ == "__main__":
    main()
```

## File: src/midjargon/core/__init__.py (Size: 0.04 KB)

```
# this_file: src/midjargon/core/__init__.py
```

## File: src/midjargon/core/input.py (Size: 2.59 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/input.py

from midjargon.core.models import MidjourneyPrompt, PromptVariant
from midjargon.core.permutations import expand_permutations


def parse_weighted_prompt(prompt: str) -> list[tuple[str, float]]:
    """Parse a prompt with optional weights.

    Args:
        prompt: Raw prompt string with optional weights.

    Returns:
        List of (prompt, weight) tuples.

    Raises:
        ValueError: If prompt is empty or invalid.
    """
    if not prompt or not prompt.strip():
        msg = "Empty prompt"
        raise ValueError(msg)

    # Split on double colon and parse weights
    result = []
    current_prompt = []
    i = 0

    while i < len(prompt):
        if prompt[i : i + 2] == "::" and (i == 0 or prompt[i - 1] != "\\"):
            # Found weight separator
            text = "".join(current_prompt).strip()
            if not text:
                msg = "Empty prompt before weight"
                raise ValueError(msg)

            # Parse weight
            i += 2
            weight_start = i
            while i < len(prompt) and (prompt[i].isdigit() or prompt[i] == "."):
                i += 1

            if i == weight_start:
                msg = f"Missing weight after :: at position {i - 2}"
                raise ValueError(msg)

            try:
                weight = float(prompt[weight_start:i])
                if weight <= 0:
                    msg = f"Weight must be positive at position {weight_start}"
                    raise ValueError(msg)
            except ValueError as e:
                msg = f"Invalid weight at position {weight_start}: {prompt[weight_start:i]}"
                raise ValueError(msg) from e

            result.append((text, weight))
            current_prompt = []
        else:
            current_prompt.append(prompt[i])
            i += 1

    # Handle last part
    if current_prompt:
        text = "".join(current_prompt).strip()
        if text:
            result.append((text, 1.0))  # Default weight

    if not result:
        msg = "Empty prompt"
        raise ValueError(msg)

    return result


def expand_midjargon_input(prompt: str) -> list[PromptVariant]:
    """Expand a midjourney prompt by processing permutations and returning a list of prompt variants.

    Args:
        prompt: The prompt string to expand.

    Returns:
        A list of PromptVariant objects, each containing an expanded prompt.
    """
    permutation_options = expand_permutations(prompt)
    return [
        PromptVariant(prompt=MidjourneyPrompt(text=opt), weight=1.0)
        for opt in permutation_options
    ]
```

## File: src/midjargon/core/main.py (Size: 1.50 KB)

```
# this_file: src/midjargon/core/main.py

from typing import Any

from midjargon.core.models import PromptVariant


def format_json_output(
    variants: list[PromptVariant], include_parsed: bool = False
) -> dict[str, Any]:
    """Format prompt variants as JSON output.

    Args:
        variants: List of prompt variants to format.
        include_parsed: Whether to include parsed data in output.

    Returns:
        Dictionary containing formatted output.
    """
    if not variants:
        return {}

    # For single variants without weights, return simple format
    if len(variants) == 1 and variants[0].weight == 1.0:
        variant = variants[0].prompt
        result = {
            "text": variant.text,
            "images": [str(img.url) for img in variant.images],
            "parameters": variant.parameters.model_dump(exclude_none=True),
        }
        if include_parsed:
            result["parsed"] = variant.model_dump(exclude_none=True)
        return result

    # For multiple variants or weighted variants, return array format
    results = []
    for variant in variants:
        prompt = variant.prompt
        result = {
            "text": prompt.text,
            "images": [str(img.url) for img in prompt.images],
            "parameters": prompt.parameters.model_dump(exclude_none=True),
            "weight": variant.weight,
        }
        if include_parsed:
            result["parsed"] = prompt.model_dump(exclude_none=True)
        results.append(result)
    return {"variants": results}
```

## File: src/midjargon/core/models.py (Size: 8.35 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/models.py

from enum import Enum
from typing import Any, Optional

from pydantic import (
    BaseModel,
    Field,
    HttpUrl,
    ValidationInfo,
    computed_field,
    field_validator,
)


class MidjourneyVersion(str, Enum):
    """Midjourney model version."""

    V4 = "v4"
    V5 = "v5"
    V5_1 = "v5.1"
    V5_2 = "v5.2"
    V6 = "v6"
    V6_1 = "v6.1"
    NIJI4 = "niji4"
    NIJI5 = "niji5"
    NIJI6 = "niji6"

    @classmethod
    def _missing_(cls, value: Any) -> Optional["MidjourneyVersion"]:
        """Handle missing values by trying to normalize the input."""
        try:
            # Try to normalize version string
            value = str(value).lower().strip()

            # Handle numeric versions (e.g., 4, 5, 6)
            if value.replace(".", "").isdigit():
                if "." not in value:
                    value = f"v{value}"
                else:
                    value = f"v{value}"

            # Handle niji versions
            if value == "niji":
                return cls.NIJI6
            if value.startswith("niji"):
                for member in cls:
                    if member.value == value:
                        return member
                return cls.NIJI6

            # Handle v prefix
            if not value.startswith("v") and not value.startswith("niji"):
                value = f"v{value}"

            # Try exact match first
            for member in cls:
                if member.value == value:
                    return member

            # Try prefix match for v* versions
            if value.startswith("v"):
                base_version = value.split(".")[0]
                latest_version = None
                for member in cls:
                    if member.value.startswith(base_version):
                        if (
                            latest_version is None
                            or member.value > latest_version.value
                        ):
                            latest_version = member
                if latest_version:
                    return latest_version

            return None
        except:
            return None


class StyleMode(str, Enum):
    """Available style modes."""

    RAW = "raw"
    CUTE = "cute"
    EXPRESSIVE = "expressive"
    SCENIC = "scenic"
    ORIGINAL = "original"


class ImageReference(BaseModel):
    """Reference to an image."""

    url: HttpUrl
    weight: float = 1.0


class CharacterReference(BaseModel):
    """Reference to a character."""

    url: HttpUrl | None = None
    weight: float = 1.0
    code: str | None = None


class StyleReference(BaseModel):
    """Reference to a style."""

    url: HttpUrl | None = None
    weight: float = 1.0
    code: str | None = None


class MidjourneyParameters(BaseModel):
    """Parameters for a Midjourney prompt."""

    version: MidjourneyVersion | None = None
    style: StyleMode | None = None
    stylize: int = 100
    chaos: int = 0
    weird: int = 0
    seed: int | str | None = None
    aspect: str = "1:1"
    tile: bool = False
    turbo: bool = False
    relax: bool = False
    no: list[str] = Field(default_factory=list)
    character_reference: list[CharacterReference] = Field(default_factory=list)
    style_reference: list[StyleReference] = Field(default_factory=list)

    @field_validator("aspect")
    @classmethod
    def validate_aspect(cls, v: str) -> str:
        """Validate aspect ratio format."""
        try:
            w, h = map(int, v.split(":"))
            if w <= 0 or h <= 0:
                raise ValueError
            return f"{w}:{h}"
        except:
            msg = "Invalid aspect ratio format. Expected W:H"
            raise ValueError(msg)

    @field_validator("stylize")
    @classmethod
    def validate_stylize(cls, v: int) -> int:
        """Validate stylize value."""
        if not 0 <= v <= 1000:
            msg = f"Stylize value must be between 0 and 1000, got {v}"
            raise ValueError(msg)
        return v

    @field_validator("chaos")
    @classmethod
    def validate_chaos(cls, v: int) -> int:
        """Validate chaos value."""
        if not 0 <= v <= 100:
            msg = f"Chaos value must be between 0 and 100, got {v}"
            raise ValueError(msg)
        return v

    @field_validator("weird")
    @classmethod
    def validate_weird(cls, v: int) -> int:
        """Validate weird value."""
        if not 0 <= v <= 3000:
            msg = f"Weird value must be between 0 and 3000, got {v}"
            raise ValueError(msg)
        return v


class MidjourneyPrompt(BaseModel):
    """A complete Midjourney prompt."""

    text: str
    image_prompts: list[HttpUrl] = Field(default_factory=list)
    stylize: float = Field(default=100, ge=0, le=1000)
    chaos: float = Field(default=0, ge=0, le=100)
    weird: float = Field(default=0, ge=0, le=3000)
    image_weight: float = Field(default=1.0, ge=0, le=2.0)
    seed: int | None = None
    stop: float = Field(default=100, ge=0, le=100)
    aspect_width: int | None = None
    aspect_height: int | None = None
    aspect_ratio: str | None = None
    style: StyleMode | None = None
    version: MidjourneyVersion | None = None
    personalization: bool = False
    quality: float = Field(default=1.0, ge=0.25, le=2.0)
    character_reference: list[CharacterReference] = Field(default_factory=list)
    character_weight: float = Field(default=100, ge=0, le=100)
    style_reference: list[StyleReference] = Field(default_factory=list)
    style_weight: float | None = Field(default=None, ge=0, le=100)
    style_version: int = Field(default=2, ge=1, le=3)
    repeat: int | None = None
    turbo: bool = False
    relax: bool = False
    tile: bool = False
    negative_prompt: str | None = None
    extra_params: dict[str, Any] = Field(default_factory=dict)

    @field_validator("aspect_ratio")
    @classmethod
    def validate_aspect_ratio(cls, v: str | None, info: ValidationInfo) -> str | None:
        """Validate aspect ratio format."""
        if v is not None:
            try:
                w, h = map(int, v.split(":"))
                if w <= 0 or h <= 0:
                    msg = "Invalid aspect ratio: values must be positive"
                    raise ValueError(msg)
                info.data["aspect_width"] = w
                info.data["aspect_height"] = h
            except ValueError as e:
                msg = f"Invalid aspect ratio format: {e}"
                raise ValueError(msg)
        return v

    @computed_field
    def images(self) -> list[HttpUrl]:
        """Get image URLs."""
        return self.image_prompts

    @property
    def parameters(self) -> MidjourneyParameters:
        """Get all parameters as a MidjourneyParameters object."""
        exclude = {"text", "image_prompts", "extra_params", "images", "parameters"}
        params = {}
        for field_name, field in self.model_fields.items():
            if field_name not in exclude:
                value = getattr(self, field_name)
                if value is not None and value != field.default:
                    if field_name == "character_reference" and not value:
                        continue
                    if field_name == "style_reference" and not value:
                        continue
                    params[field_name] = value
        return MidjourneyParameters(**params)

    def to_string(self) -> str:
        """Convert prompt to string format."""
        parts = [self.text]

        # Add image prompts
        for url in self.image_prompts:
            parts.append(str(url))

        # Add parameters
        params = []
        for field, value in self.parameters.model_dump().items():
            if value is None:
                continue
            if isinstance(value, bool) and value:
                params.append(f"--{field}")
            elif isinstance(value, list) and value:
                for v in value:
                    params.append(f"--{field} {v}")
            else:
                params.append(f"--{field} {value}")

        # Add extra parameters
        for key, value in self.extra_params.items():
            if value is None:
                params.append(f"--{key}")
            else:
                params.append(f"--{key} {value}")

        if params:
            parts.append(" ".join(params))

        return " ".join(parts)


class PromptVariant(BaseModel):
    """A variant of a prompt with weight."""

    prompt: MidjourneyPrompt
    weight: float = 1.0
```

## File: src/midjargon/core/parameters.py (Size: 6.60 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/parameters.py

import shlex
from typing import Any
from urllib.parse import urlparse

from pydantic import HttpUrl

from midjargon.core.models import (
    CharacterReference,
    MidjourneyVersion,
    StyleMode,
    StyleReference,
)

# Parameter aliases mapping
ALIASES = {
    # Version aliases
    "v": "version",
    "ver": "version",
    "niji": "version",
    # Style aliases
    "s": "stylize",
    # Chaos aliases
    "c": "chaos",
    # Weird aliases
    "w": "weird",
    # Seed aliases
    "sameseed": "seed",
    # Aspect ratio aliases
    "ar": "aspect",
    # Character reference aliases
    "cref": "character_reference",
    # Style reference aliases
    "sref": "style_reference",
    # Character weight aliases
    "cw": "character_weight",
    # Style weight aliases
    "sw": "style_weight",
    # Style version aliases
    "sv": "style_version",
    # Personalization aliases
    "p": "personalization",
}

# Parameters that can have multiple values
MULTI_VALUE_PARAMS = {"no", "character_reference", "style_reference"}

# Parameters that are flags (no value needed)
FLAG_PARAMS = {"tile", "turbo", "relax", "fast", "video", "personalization"}

# Parameters that should remain as strings
STRING_PARAMS = {"aspect", "negative_prompt"}

# Parameters that should be integers
INT_PARAMS = {"seed", "style_version", "repeat"}


def is_url(value: str) -> bool:
    """Check if a string is a valid URL."""
    try:
        result = urlparse(value)
        return all([result.scheme, result.netloc])
    except:
        return False


def convert_parameter_value(param: str, value: str | None) -> Any:
    """Convert a parameter value to the appropriate type."""
    # Handle flag parameters
    if param in FLAG_PARAMS:
        return True if value is None else value.lower() == "true"

    # Handle empty values
    if value is None:
        return None

    # Handle string parameters
    if param in STRING_PARAMS:
        return str(value)

    # Handle version parameter
    if param == "version":
        try:
            return MidjourneyVersion(value)
        except ValueError:
            msg = f"Invalid version value: {value}"
            raise ValueError(msg)

    # Handle integer parameters
    if param in INT_PARAMS:
        try:
            return int(value)
        except ValueError:
            msg = f"Invalid integer value for {param}: {value}"
            raise ValueError(msg)

    # Handle float parameters
    if param in {
        "stylize",
        "chaos",
        "weird",
        "quality",
        "character_weight",
        "style_weight",
        "image_weight",
        "stop",
    }:
        try:
            return float(value)
        except ValueError:
            msg = f"Invalid numeric value for {param}: {value}"
            raise ValueError(msg)

    # Handle style parameter
    if param == "style":
        try:
            return StyleMode(value)
        except ValueError:
            msg = f"Invalid style value: {value}"
            raise ValueError(msg)

    # Handle character and style references
    if param in {"character_reference", "style_reference"}:
        ref_class = (
            CharacterReference if param == "character_reference" else StyleReference
        )
        try:
            if is_url(value):
                return ref_class(url=HttpUrl(value), weight=1.0)
            else:
                # Handle reference codes (e.g., p123456)
                return ref_class(
                    url=HttpUrl(f"https://example.com/{value}"), code=value, weight=1.0
                )
        except Exception:
            msg = f"Invalid reference value for {param}: {value}"
            raise ValueError(msg)

    # Default case: return as string
    return value


def parse_parameters(param_str: str) -> dict[str, Any]:
    """Parse parameters from a string into a dictionary."""
    if not param_str:
        return {}

    # Split parameters while preserving quoted strings
    try:
        parts = shlex.split(param_str)
    except ValueError as e:
        msg = f"Failed to parse parameters: {e}"
        raise ValueError(msg)

    result: dict[str, Any] = {}
    current_param = None
    current_values = []

    for part in parts:
        if part.startswith("--"):
            # Store previous parameter if exists
            if current_param:
                try:
                    if current_param in MULTI_VALUE_PARAMS:
                        # Handle multi-value parameters
                        values = (
                            [
                                convert_parameter_value(current_param, v)
                                for v in current_values
                            ]
                            if current_values
                            else [True]
                        )
                        if current_param in result:
                            result[current_param].extend(values)
                        else:
                            result[current_param] = values
                    else:
                        # Handle single value parameters
                        value = convert_parameter_value(
                            current_param, current_values[0] if current_values else None
                        )
                        result[current_param] = value
                except Exception as e:
                    msg = f"Failed to parse parameter {current_param}: {e}"
                    raise ValueError(msg)

            # Start new parameter
            current_param = ALIASES.get(
                part[2:], part[2:]
            )  # Remove -- and resolve alias
            current_values = []
        elif current_param:
            current_values.append(part)
        else:
            msg = f"Unexpected value without parameter: {part}"
            raise ValueError(msg)

    # Handle last parameter
    if current_param:
        try:
            if current_param in MULTI_VALUE_PARAMS:
                values = (
                    [convert_parameter_value(current_param, v) for v in current_values]
                    if current_values
                    else [True]
                )
                if current_param in result:
                    result[current_param].extend(values)
                else:
                    result[current_param] = values
            else:
                value = convert_parameter_value(
                    current_param, current_values[0] if current_values else None
                )
                result[current_param] = value
        except Exception as e:
            msg = f"Failed to parse parameter {current_param}: {e}"
            raise ValueError(msg)

    return result
```

## File: src/midjargon/core/parser.py (Size: 4.92 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/parser.py

from typing import Any
from urllib.parse import urlparse

from pydantic import HttpUrl

from midjargon.core.models import CharacterReference, MidjourneyPrompt, StyleReference


def is_valid_image_url(url: str) -> bool:
    """Check if a URL is a valid image URL."""
    try:
        result = urlparse(url)
        return bool(
            result.scheme
            and result.netloc
            and any(
                result.path.lower().endswith(ext)
                for ext in [".jpg", ".jpeg", ".png", ".gif", ".webp"]
            )
        )
    except:
        return False


def is_url(text: str) -> bool:
    """Check if text is a URL."""
    try:
        result = urlparse(text)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False


def extract_image_urls(prompt: str) -> tuple[list[HttpUrl], str]:
    """Extract image URLs from the start of a prompt.

    Args:
        prompt: The raw prompt string.

    Returns:
        A tuple of (list of image URLs, remaining text).
    """
    parts = prompt.strip().split()
    urls = []
    text_start = 0

    for i, part in enumerate(parts):
        if is_url(part):
            urls.append(HttpUrl(part))
            text_start = i + 1
        else:
            break

    return urls, " ".join(parts[text_start:])


def parse_parameters(param_str: str) -> dict[str, Any]:
    """Parse parameter string into a dictionary.

    Args:
        param_str: The parameter string to parse.

    Returns:
        Dictionary of parameter names and values.

    Raises:
        ValueError: If parameter parsing fails.
    """
    params: dict[str, Any] = {}

    # Split into individual parameters
    parts = param_str.split("--")
    for part in parts[1:]:  # Skip empty first part
        if not part.strip():
            continue

        # Split parameter name and value
        param_parts = part.strip().split(maxsplit=1)
        param_name = param_parts[0]
        param_value = param_parts[1] if len(param_parts) > 1 else None

        # Handle special parameters
        if param_name == "cref":
            if param_value:
                if is_url(param_value):
                    params.setdefault("character_reference", []).append(
                        CharacterReference(url=HttpUrl(param_value), code=None)
                    )
                else:
                    params.setdefault("character_reference", []).append(
                        CharacterReference(url=None, code=param_value)
                    )
        elif param_name == "sref":
            if param_value:
                if is_url(param_value):
                    params.setdefault("style_reference", []).append(
                        StyleReference(url=HttpUrl(param_value), code=None)
                    )
                else:
                    params.setdefault("style_reference", []).append(
                        StyleReference(url=None, code=param_value)
                    )
        # Handle regular parameters
        elif param_value is None:
            params[param_name] = True
        else:
            try:
                # Try to convert to number
                if "." in param_value:
                    params[param_name] = float(param_value)
                else:
                    params[param_name] = int(param_value)
            except ValueError:
                params[param_name] = param_value

    return params


def parse_midjargon_prompt(prompt: str) -> MidjourneyPrompt:
    """Parse a Midjourney prompt into a validated MidjourneyPrompt object.

    Args:
        prompt: The raw prompt string to parse.

    Returns:
        A validated MidjourneyPrompt object.

    Raises:
        ValueError: If the prompt is invalid or missing required components.
    """
    # Extract image URLs
    images, remaining_text = extract_image_urls(prompt)

    # Split into text and parameters
    if " --" in remaining_text:
        text_part, param_part = remaining_text.split(" --", 1)
        text_part = text_part.strip()
        param_str = "--" + param_part.strip()
        try:
            parameters = parse_parameters(param_str)
        except Exception as e:
            msg = f"Failed to parse parameters: {e!s}"
            raise ValueError(msg)
    else:
        text_part = remaining_text.strip()
        parameters = {}

    # Create and validate the prompt object
    try:
        return MidjourneyPrompt(
            text=text_part,
            image_prompts=images,
            **parameters,
        )
    except Exception as e:
        msg = f"Failed to create prompt object: {e!s}"
        raise ValueError(msg)


def parse_midjargon_prompt_to_dict(prompt: str) -> dict[str, Any]:
    """Parse a Midjourney prompt into a dictionary.

    Args:
        prompt: The raw prompt string to parse.

    Returns:
        Dictionary representation of the prompt.
    """
    parsed = parse_midjargon_prompt(prompt)
    return parsed.model_dump()
```

## File: src/midjargon/core/permutations.py (Size: 3.63 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/core/permutations.py


def find_unescaped(s: str, char: str, start: int = 0) -> int:
    """Find the next unescaped occurrence of a character.

    Args:
        s: String to search in.
        char: Character to find.
        start: Starting position for search.

    Returns:
        Index of the first unescaped occurrence, or -1 if not found.
    """
    i = start
    while i < len(s):
        if s[i] == "\\":
            i += 2  # Skip escaped character
            continue
        if s[i] == char:
            return i
        i += 1
    return -1


def split_unescaped(s: str, delimiter: str = ",") -> list[str]:
    """Split string on unescaped delimiters and handle escapes.

    Args:
        s: String to split.
        delimiter: Character to split on.

    Returns:
        List of substrings.
    """
    parts = []
    current = []
    i = 0

    while i < len(s):
        if s[i] == "\\":
            if i + 1 < len(s):
                current.append(s[i + 1])  # Keep escaped character
                i += 2
            else:
                current.append(s[i])  # Keep trailing backslash
                i += 1
        elif s[i] == delimiter:
            parts.append("".join(current).strip())
            current = []
            i += 1
        else:
            current.append(s[i])
            i += 1

    if current:
        parts.append("".join(current).strip())

    return parts


def find_matching_brace(s: str, start: int) -> tuple[int, str]:
    """Find matching closing brace and extract error message if any.

    Args:
        s: String to search in.
        start: Position of opening brace.

    Returns:
        Tuple of (position of closing brace, error message).
        Position will be -1 if no match found.
    """
    count = 1
    i = start + 1

    while i < len(s):
        if s[i] == "\\":
            i += 2
            continue
        if s[i] == "{":
            count += 1
        elif s[i] == "}":
            count -= 1
            if count == 0:
                return i, ""
        i += 1

    if count > 0:
        return -1, f"Unclosed brace at position {start}"
    return -1, "Invalid brace structure"


def expand_permutations(s: str) -> list[str]:
    """Recursively expand permutations in the prompt string using {a, b, ...} syntax.

    Handles:
    - Nested permutation groups
    - Escaped characters (\\, \\{, \\}, \\,)
    - Proper error reporting

    Args:
        s: String containing permutation groups.

    Returns:
        List of all possible permutations.

    Raises:
        ValueError: If the permutation syntax is invalid.
    """
    # Find first unescaped opening brace
    start = find_unescaped(s, "{")
    if start == -1:
        return [s]

    # Find matching closing brace
    end, error = find_matching_brace(s, start)
    if end == -1:
        raise ValueError(error)

    # Extract and split options
    options_str = s[start + 1 : end]
    try:
        options = split_unescaped(options_str)
    except Exception as e:
        msg = f"Failed to parse options at position {start}: {e!s}"
        raise ValueError(msg)

    if not options:
        msg = f"Empty permutation group at position {start}"
        raise ValueError(msg)

    # Recursively expand each option
    results = []
    prefix = s[:start]
    suffix = s[end + 1 :]

    for option in options:
        # Replace the entire '{...}' with the option
        new_s = prefix + option + suffix
        try:
            results.extend(expand_permutations(new_s))
        except Exception as e:
            msg = f"Failed to expand option '{option}': {e!s}"
            raise ValueError(msg)

    return results
```

## File: src/midjargon/engines/__init__.py (Size: 0.05 KB)

```
# this_file: src/midjargon/engines/__init__.py
```

## File: src/midjargon/engines/fal/__init__.py (Size: 0.20 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/fal/__init__.py

from midjargon.engines.fal.fal import FalParser, FalPrompt, parse_fal_dict

__all__ = ["FalParser", "FalPrompt", "parse_fal_dict"]
```

## File: src/midjargon/engines/fal/fal.py (Size: 3.27 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/fal/fal.py

from typing import Any

from pydantic import BaseModel, HttpUrl, computed_field


class FalPrompt(BaseModel):
    """Fal.ai prompt model with all parameters."""

    text: str
    image_prompts: list[HttpUrl] = []
    negative_prompt: str | None = None
    num_inference_steps: int | None = 50
    guidance_scale: float | None = 7.5
    width: int | None = 1024
    height: int | None = 1024
    seed: int | None = None
    scheduler: str | None = None
    extra_params: dict[str, Any] = {}

    @computed_field
    def images(self) -> list[HttpUrl]:
        """Get image URLs."""
        return self.image_prompts

    @computed_field
    def parameters(self) -> dict[str, Any]:
        """Get all parameters as a dictionary."""
        params = self.model_dump(exclude={"text", "image_prompts", "extra_params"})
        return {k: v for k, v in params.items() if v is not None}

    def to_string(self) -> str:
        """Convert prompt to string format."""
        parts = [self.text]

        # Add image prompts
        for url in self.image_prompts:
            parts.append(str(url))

        # Add parameters
        params = []
        for field, value in self.model_dump(exclude_unset=True).items():
            if field in {"text", "image_prompts", "extra_params"} or value is None:
                continue
            if isinstance(value, bool) and value:
                params.append(f"--{field}")
            elif isinstance(value, list) and value:
                for v in value:
                    params.append(f"--{field} {v}")
            else:
                params.append(f"--{field} {value}")

        # Add extra parameters
        for key, value in self.extra_params.items():
            if value is None:
                params.append(f"--{key}")
            else:
                params.append(f"--{key} {value}")

        if params:
            parts.append(" ".join(params))

        return " ".join(parts)


class FalParser:
    """Parser for converting between Fal.ai prompt formats."""

    def parse_dict(self, prompt_dict: dict[str, Any]) -> FalPrompt:
        """Parse a dictionary into a FalPrompt.

        Args:
            prompt_dict: Dictionary containing prompt data.

        Returns:
            FalPrompt instance.

        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)

        # Extract known fields
        known_fields = set(FalPrompt.model_fields)

        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value

        # Create prompt with all parameters
        return FalPrompt(text=text, **params, extra_params=extra_params)


def parse_fal_dict(prompt_dict: dict[str, Any]) -> FalPrompt:
    """Convert a dictionary to a FalPrompt.

    Args:
        prompt_dict: Dictionary containing prompt data.

    Returns:
        FalPrompt instance.
    """
    parser = FalParser()
    return parser.parse_dict(prompt_dict)
```

## File: src/midjargon/engines/midjourney/__init__.py (Size: 0.28 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/__init__.py

from midjargon.engines.midjourney.midjourney import (
    MidjourneyParser,
    MidjourneyPrompt,
    parse_midjourney_dict,
)

__all__ = ["MidjourneyParser", "MidjourneyPrompt", "parse_midjourney_dict"]
```

## File: src/midjargon/engines/midjourney/midjourney.py (Size: 1.55 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/midjourney.py

from typing import Any


from midjargon.core.models import (
    MidjourneyPrompt,
)


class MidjourneyParser:
    """Parser for converting between Midjourney prompt formats."""

    def parse_dict(self, prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
        """Parse a dictionary into a MidjourneyPrompt.

        Args:
            prompt_dict: Dictionary containing prompt data.

        Returns:
            MidjourneyPrompt instance.

        Raises:
            ValueError: If the prompt text is empty.
        """
        # Validate text
        text = prompt_dict.pop("text", "").strip()
        if not text:
            msg = "Empty prompt"
            raise ValueError(msg)

        # Extract known fields
        known_fields = set(MidjourneyPrompt.model_fields)

        # Split into known and extra parameters
        params = {}
        extra_params = {}
        for key, value in prompt_dict.items():
            if key in known_fields:
                params[key] = value
            else:
                extra_params[key] = value

        # Create prompt with all parameters
        return MidjourneyPrompt(text=text, **params, extra_params=extra_params)


def parse_midjourney_dict(prompt_dict: dict[str, Any]) -> MidjourneyPrompt:
    """Convert a dictionary to a MidjourneyPrompt.

    Args:
        prompt_dict: Dictionary containing prompt data.

    Returns:
        MidjourneyPrompt instance.
    """
    parser = MidjourneyParser()
    return parser.parse_dict(prompt_dict)
```

## File: src/midjargon/engines/midjourney/parser.py (Size: 2.02 KB)

```
#!/usr/bin/env python3
# this_file: src/midjargon/engines/midjourney/parser.py

from typing import Any

from midjargon.core.models import MidjourneyParameters, MidjourneyPrompt
from midjargon.core.parameters import parse_parameters


class MidjourneyParser:
    """Parser for Midjourney prompts."""

    def __init__(self, prompt_dict: dict[str, Any] | None = None):
        """Initialize the parser.

        Args:
            prompt_dict: Optional dictionary containing prompt data.
        """
        self.prompt_dict = prompt_dict or {}
        self.prompt = MidjourneyPrompt(
            text=self.prompt_dict.get("text", ""),
            images=self.prompt_dict.get("images", []),
            parameters=MidjourneyParameters(**self.prompt_dict.get("parameters", {})),
        )

    def parse(self) -> MidjourneyPrompt:
        """Parse the prompt data into a MidjourneyPrompt object.

        Returns:
            A validated MidjourneyPrompt object.
        """
        return self.prompt

    @staticmethod
    def from_string(prompt_str: str) -> "MidjourneyParser":
        """Create a parser from a prompt string.

        Args:
            prompt_str: The raw prompt string to parse.

        Returns:
            A MidjourneyParser instance.

        Raises:
            ValueError: If prompt parsing fails.
        """
        # Split into text and parameters
        if " --" in prompt_str:
            text_part, param_part = prompt_str.split(" --", 1)
            text_part = text_part.strip()
            param_str = "--" + param_part.strip()
            try:
                parameters = parse_parameters(param_str)
            except Exception as e:
                msg = f"Failed to parse parameters: {e!s}"
                raise ValueError(msg) from e
        else:
            text_part = prompt_str.strip()
            parameters = {}

        # Create prompt dictionary
        prompt_dict = {
            "text": text_part,
            "images": [],
            "parameters": parameters,
        }

        return MidjourneyParser(prompt_dict)
```

## File: test-cases/prompts-fal.txt (Size: 32.46 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "images": [],
    "version": 6,
    "stylize": 250,
    "seed": 12345,
    "prompt": "\"Do not enter\" sign in Elvish script, overgrown with vines"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 250,
    "seed": 67890,
    "prompt": "\"Do not enter\" sign in Elvish script, overgrown with vines"
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "images": [],
  "version": 6.1,
  "stylize": 750,
  "weird": 250,
  "prompt": "\"Lost in translation\" neon sign in a Tokyo alleyway"
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "images": [],
  "version": 6.1,
  "stylize": 1000,
  "zoom": 1.5,
  "aspect_ratio": "1:2",
  "prompt": "\"Made in Midjourney\" stamp on a vintage postage stamp"
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
[
  {
    "images": [],
    "style": "raw",
    "stylize": 0,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "raw",
    "stylize": 0,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "raw",
    "stylize": 1000,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "raw",
    "stylize": 1000,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 0,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 0,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 1000,
    "weird": 0,
    "prompt": "A black and white oak tree icon"
  },
  {
    "images": [],
    "style": "default",
    "stylize": 1000,
    "weird": 3000,
    "prompt": "A black and white oak tree icon"
  }
]======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "images": [],
    "video": null,
    "version": 5.2,
    "chaos": 30,
    "aspect_ratio": "1:1",
    "prompt": "A botanical sketch of fern fronds"
  },
  {
    "images": [],
    "video": null,
    "version": 5.2,
    "chaos": 30,
    "aspect_ratio": "16:9",
    "prompt": "A botanical sketch of fern fronds"
  },
  {
    "images": [],
    "video": null,
    "version": 6,
    "chaos": 30,
    "aspect_ratio": "1:1",
    "prompt": "A botanical sketch of fern fronds"
  },
  {
    "images": [],
    "video": null,
    "version": 6,
    "chaos": 30,
    "aspect_ratio": "16:9",
    "prompt": "A botanical sketch of fern fronds"
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "images": [],
  "version": 6,
  "stylize": 100,
  "aspect_ratio": "2:3",
  "prompt": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages"
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "images": [],
    "stop": 80,
    "weird": 2000,
    "aspect_ratio": "3:2",
    "prompt": "A cat in a Tundra environment"
  },
  {
    "images": [],
    "stop": 80,
    "weird": 2000,
    "aspect_ratio": "3:2",
    "prompt": "A cat in a Jungle environment"
  },
  {
    "images": [],
    "stop": 80,
    "weird": 2000,
    "aspect_ratio": "3:2",
    "prompt": "A cat in a City environment"
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 50,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 50,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 750,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 5.2,
    "style": "raw",
    "stylize": 750,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 50,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 50,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 750,
    "quality": 0.25,
    "prompt": "A child's crayon drawing of a cat"
  },
  {
    "images": [],
    "version": 6,
    "style": "raw",
    "stylize": 750,
    "quality": 1.0,
    "prompt": "A child's crayon drawing of a cat"
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "images": [],
  "version": 6,
  "stylize": 500,
  "aspect_ratio": "1:1",
  "prompt": "A cyberpunk cat with a neon sign that says \"Midjourney\""
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "images": [],
  "version": 6.1,
  "stylize": 250,
  "aspect_ratio": "16:9",
  "prompt": "A pastel watercolor landscape with \"/imagine\" written in the clouds"
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "images": [],
    "tile": null,
    "chaos": 25,
    "prompt": "A pattern of pink and blue striped river stones"
  },
  {
    "images": [],
    "tile": null,
    "chaos": 75,
    "prompt": "A pattern of pink and blue striped river stones"
  },
  {
    "images": [],
    "tile": null,
    "chaos": 25,
    "prompt": "A pattern of colorful watercolor fall leaves"
  },
  {
    "images": [],
    "tile": null,
    "chaos": 75,
    "prompt": "A pattern of colorful watercolor fall leaves"
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "images": [],
  "style": "random-64",
  "no": "color, shading",
  "aspect_ratio": "2:3",
  "prompt": "A pencil sketch of a dragon made of constellations"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "prompt": "A portrait of a melancholic robot butler"
  },
  {
    "images": [],
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "prompt": "A portrait of a melancholic robot butler"
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "stop": 30,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "stop": 70,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "stop": 30,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "stop": 70,
    "prompt": "A surreal sculpture made of clockwork oranges and melting clocks"
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
[
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "5:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": "random",
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  },
  {
    "images": [],
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295,
    "aspect_ratio": "7:4",
    "prompt": "A vibrant California poppies image"
  }
]======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "images": [],
    "stop": 50,
    "quality": 0.5,
    "prompt": "A continuous line charcoal drawing of a value study of a cyborg geisha"
  },
  {
    "images": [],
    "stop": 50,
    "quality": 0.5,
    "prompt": "A loose gestural charcoal drawing of a value study of a cyborg geisha"
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
[
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A dreary cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "16:9",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "raw",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 0,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  },
  {
    "images": [],
    "style": "random",
    "chaos": 100,
    "aspect_ratio": "1:1",
    "prompt": "A vibrant cyberpunk cityscape"
  }
]======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
[
  {
    "images": [],
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome",
    "prompt": "A Millennial Pink colored cat"
  },
  {
    "images": [],
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome",
    "prompt": "A Acid Green colored cat"
  },
  {
    "images": [],
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome",
    "prompt": "A Ebony colored cat"
  }
]======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a determined sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a determined sloth riding a unicorn through a salt flat"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a determined sloth riding a unicorn through a salt flat"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest"
  },
  {
    "images": [],
    "chaos": 25,
    "prompt": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat"
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
[
  {
    "images": [],
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers",
    "prompt": "A pixel art style cat"
  },
  {
    "images": [],
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers",
    "prompt": "A acrylic pour style cat"
  }
]======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "images": [],
  "stylize": 50,
  "no": "board, pieces",
  "style": "raw",
  "aspect_ratio": "4:3",
  "prompt": "An impressionistic watercolor of a cat playing chess with a dog"
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "images": [],
  "negative": "weight fruit::-.5",
  "version": 4,
  "chaos": 60,
  "prompt": "cheese:: cake:: painting multi-prompt"
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "images": [],
    "weird": 750,
    "stylize": 200,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 200,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 600,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 600,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 900,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 750,
    "stylize": 900,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 200,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 200,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 600,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 600,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 900,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 1750,
    "stylize": 900,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 200,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 200,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 600,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 600,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 900,
    "aspect_ratio": "2:3",
    "prompt": "Clockwork chicken"
  },
  {
    "images": [],
    "weird": 2750,
    "stylize": 900,
    "aspect_ratio": "3:2",
    "prompt": "Clockwork chicken"
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "images": [],
    "weird": 250,
    "stylize": 100,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 100,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 100,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 500,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 500,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 500,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 1000,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 1000,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 250,
    "stylize": 1000,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 100,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 100,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 100,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 500,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 500,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 500,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 1000,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 1000,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 1000,
    "stylize": 1000,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 100,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 100,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 100,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 500,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 500,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 500,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 1000,
    "chaos": 10,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 1000,
    "chaos": 50,
    "prompt": "Cyanotype cat"
  },
  {
    "images": [],
    "weird": 2000,
    "stylize": 1000,
    "chaos": 90,
    "prompt": "Cyanotype cat"
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "1:1",
    "prompt": "Ice cream icon"
  },
  {
    "images": [],
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect_ratio": "2:3",
    "prompt": "Ice cream icon"
  }
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "images": [],
  "remix": null,
  "prompt": "image of a robot holding flowers",
  "zoom": "2x"
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1400s cat"
  },
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1400s cat"
  },
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1990s cat"
  },
  {
    "images": [],
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect_ratio": "5:4",
    "prompt": "Imagine a 1990s cat"
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "images": [],
    "weird": 500,
    "chaos": 20,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 20,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 60,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 60,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 500,
    "chaos": 80,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 20,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 20,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 60,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 60,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 1500,
    "chaos": 80,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 20,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 20,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 60,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 60,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 80,
    "quality": 0.5,
    "prompt": "Lithograph potato"
  },
  {
    "images": [],
    "weird": 2500,
    "chaos": 80,
    "quality": 1.0,
    "prompt": "Lithograph potato"
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "images": [],
    "stylize": 250,
    "weird": 500,
    "prompt": "space:: ship multi-prompt"
  },
  {
    "images": [],
    "stylize": 750,
    "weird": 500,
    "prompt": "space:: ship multi-prompt"
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "images": [],
  "vary": "region",
  "selection": "sky area",
  "prompt": "stream running through a redwood forest",
  "pan": "up"
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "images": [],
    "version": 5.2,
    "stylize": 100,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 5.2,
    "stylize": 100,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 5.2,
    "stylize": 500,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 5.2,
    "stylize": 500,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 100,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 100,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 500,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6,
    "stylize": 500,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 100,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 100,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 500,
    "quality": 1.0,
    "prompt": "Vibrant California poppies"
  },
  {
    "images": [],
    "version": 6.1,
    "stylize": 500,
    "quality": 2.0,
    "prompt": "Vibrant California poppies"
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "A flock of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from gigantic orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 0.25,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 2,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  },
  {
    "images": [],
    "quality": 1.0,
    "repeat": 5,
    "prompt": "Three of iridescent hummingbirds drinking nectar from miniature orchids"
  }
]
```

## File: test-cases/prompts-in.txt (Size: 3.16 KB)

```
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
space:: ship multi-prompt  --stylize {250, 750} --weird 500
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
{Happy, Angry, Shy} cat --style raw --chaos 60 --quality 1 --repeat 3
```

## File: test-cases/prompts-json.txt (Size: 31.71 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "images": [],
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "version": "6",
    "stylize": 250,
    "seed": 12345
  },
  {
    "images": [],
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "version": "6",
    "stylize": 250,
    "seed": 67890
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "images": [],
  "text": "\"Lost in translation\" neon sign in a Tokyo alleyway",
  "version": "6.1",
  "stylize": 750,
  "weird": 250
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "images": [],
  "text": "\"Made in Midjourney\" stamp on a vintage postage stamp",
  "version": "6.1",
  "stylize": 1000,
  "zoom": "1.5",
  "aspect": "1:2"
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
[
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 0,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 0,
    "weird": 3000
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 1000,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "raw",
    "stylize": 1000,
    "weird": 3000
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 0,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 0,
    "weird": 3000
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 1000,
    "weird": 0
  },
  {
    "images": [],
    "text": "A black and white oak tree icon",
    "style": "default",
    "stylize": 1000,
    "weird": 3000
  }
]======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "5.2",
    "aspect": "1:1",
    "chaos": 30
  },
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "5.2",
    "aspect": "16:9",
    "chaos": 30
  },
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "6",
    "aspect": "1:1",
    "chaos": 30
  },
  {
    "images": [],
    "text": "A botanical sketch of fern fronds",
    "video": null,
    "version": "6",
    "aspect": "16:9",
    "chaos": 30
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "images": [],
  "text": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages",
  "version": "6",
  "stylize": 100,
  "aspect": "2:3"
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "images": [],
    "text": "A cat in a Tundra environment",
    "aspect": "3:2",
    "stop": 80,
    "weird": 2000
  },
  {
    "images": [],
    "text": "A cat in a Jungle environment",
    "aspect": "3:2",
    "stop": 80,
    "weird": 2000
  },
  {
    "images": [],
    "text": "A cat in a City environment",
    "aspect": "3:2",
    "stop": 80,
    "weird": 2000
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 50,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 50,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 750,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "5.2",
    "style": "raw",
    "stylize": 750,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 50,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 50,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 750,
    "quality": 0.25
  },
  {
    "images": [],
    "text": "A child's crayon drawing of a cat",
    "version": "6",
    "style": "raw",
    "stylize": 750,
    "quality": 1.0
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "images": [],
  "text": "A cyberpunk cat with a neon sign that says \"Midjourney\"",
  "version": "6",
  "stylize": 500,
  "aspect": "1:1"
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "images": [],
  "text": "A pastel watercolor landscape with \"/imagine\" written in the clouds",
  "version": "6.1",
  "stylize": 250,
  "aspect": "16:9"
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "images": [],
    "text": "A pattern of pink and blue striped river stones",
    "tile": null,
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pattern of pink and blue striped river stones",
    "tile": null,
    "chaos": 75
  },
  {
    "images": [],
    "text": "A pattern of colorful watercolor fall leaves",
    "tile": null,
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pattern of colorful watercolor fall leaves",
    "tile": null,
    "chaos": 75
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "images": [],
  "text": "A pencil sketch of a dragon made of constellations",
  "aspect": "2:3",
  "style": "random-64",
  "no": "color, shading"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100
  },
  {
    "images": [],
    "text": "A portrait of a melancholic robot butler",
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 500,
    "chaos": 80,
    "stop": 30
  },
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 500,
    "chaos": 80,
    "stop": 70
  },
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 1500,
    "chaos": 80,
    "stop": 30
  },
  {
    "images": [],
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "weird": 1500,
    "chaos": 80,
    "stop": 70
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
[
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "5:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 10,
    "quality": 1.0,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 0.5,
    "seed": 4294967295
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": "random"
  },
  {
    "images": [],
    "text": "A vibrant California poppies image",
    "aspect": "7:4",
    "chaos": 50,
    "quality": 1.0,
    "seed": 4294967295
  }
]======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "images": [],
    "text": "A continuous line charcoal drawing of a value study of a cyborg geisha",
    "stop": 50,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "A loose gestural charcoal drawing of a value study of a cyborg geisha",
    "stop": 50,
    "quality": 0.5
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
[
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A dreary cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "16:9",
    "style": "random",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "raw",
    "chaos": 100
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 0
  },
  {
    "images": [],
    "text": "A vibrant cyberpunk cityscape",
    "aspect": "1:1",
    "style": "random",
    "chaos": 100
  }
]======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
[
  {
    "images": [],
    "text": "A Millennial Pink colored cat",
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome"
  },
  {
    "images": [],
    "text": "A Acid Green colored cat",
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome"
  },
  {
    "images": [],
    "text": "A Ebony colored cat",
    "stylize": 250,
    "style": "random-16",
    "no": "monochrome"
  }
]======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "images": [],
    "text": "A pastel painting of a determined sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pastel painting of a determined sloth riding a unicorn through a salt flat",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a determined sloth riding a unicorn through a salt flat",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest",
    "chaos": 25
  },
  {
    "images": [],
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat",
    "chaos": 25
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
[
  {
    "images": [],
    "text": "A pixel art style cat",
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers"
  },
  {
    "images": [],
    "text": "A acrylic pour style cat",
    "style": "random-128",
    "weird": 1000,
    "no": "fur, whiskers"
  }
]======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "images": [],
  "text": "An impressionistic watercolor of a cat playing chess with a dog",
  "aspect": "4:3",
  "stylize": 50,
  "no": "board, pieces",
  "style": "raw"
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "images": [],
  "text": "cheese:: cake:: painting multi-prompt",
  "negative": "weight fruit::-.5",
  "version": "4",
  "chaos": 60
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 200,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 200,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 600,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 600,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 900,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 750,
    "stylize": 900,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 200,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 200,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 600,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 600,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 900,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 1750,
    "stylize": 900,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 200,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 200,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 600,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 600,
    "aspect": "3:2"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 900,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Clockwork chicken",
    "weird": 2750,
    "stylize": 900,
    "aspect": "3:2"
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 100,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 100,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 100,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 500,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 500,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 500,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 1000,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 1000,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 250,
    "stylize": 1000,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 100,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 100,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 100,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 500,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 500,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 500,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 1000,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 1000,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 1000,
    "stylize": 1000,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 100,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 100,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 100,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 500,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 500,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 500,
    "chaos": 90
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 1000,
    "chaos": 10
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 1000,
    "chaos": 50
  },
  {
    "images": [],
    "text": "Cyanotype cat",
    "weird": 2000,
    "stylize": 1000,
    "chaos": 90
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "cute",
    "weird": 1000,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 5",
    "style": "expressive",
    "weird": 1000,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "cute",
    "weird": 1000,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 250,
    "aspect": "2:3"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect": "1:1"
  },
  {
    "images": [],
    "text": "Ice cream icon",
    "version": "niji 6",
    "style": "expressive",
    "weird": 1000,
    "aspect": "2:3"
  }
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "images": [],
  "text": "image of a robot holding flowers",
  "remix": null,
  "prompt": "A cyborg holding cybernetic orchids",
  "zoom": "2x"
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "images": [],
    "text": "Imagine a 1400s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect": "5:4"
  },
  {
    "images": [],
    "text": "Imagine a 1400s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect": "5:4"
  },
  {
    "images": [],
    "text": "Imagine a 1990s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 1,
    "aspect": "5:4"
  },
  {
    "images": [],
    "text": "Imagine a 1990s cat",
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_version": 4,
    "aspect": "5:4"
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 20,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 20,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 60,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 60,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 80,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 500,
    "chaos": 80,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 20,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 20,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 60,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 60,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 80,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 1500,
    "chaos": 80,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 20,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 20,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 60,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 60,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 80,
    "quality": 0.5
  },
  {
    "images": [],
    "text": "Lithograph potato",
    "weird": 2500,
    "chaos": 80,
    "quality": 1.0
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "images": [],
    "text": "space:: ship multi-prompt",
    "stylize": 250,
    "weird": 500
  },
  {
    "images": [],
    "text": "space:: ship multi-prompt",
    "stylize": 750,
    "weird": 500
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "images": [],
  "text": "stream running through a redwood forest",
  "vary": "region",
  "selection": "sky area",
  "prompt": "aurora borealis",
  "pan": "up"
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 100,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 100,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 500,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "5.2",
    "stylize": 500,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 100,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 100,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 500,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6",
    "stylize": 500,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 100,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 100,
    "quality": 2.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 500,
    "quality": 1.0
  },
  {
    "images": [],
    "text": "Vibrant California poppies",
    "version": "6.1",
    "stylize": 500,
    "quality": 2.0
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 5
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "quality": 1.0,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 0.25,
    "repeat": 5
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 2
  },
  {
    "images": [],
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "quality": 1.0,
    "repeat": 5
  }
]
```

## File: test-cases/prompts-mj.txt (Size: 105.65 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 12345,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "\"Do not enter\" sign in Elvish script, overgrown with vines",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": 67890,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
{
  "text": "\"Lost in translation\" neon sign in a Tokyo alleyway",
  "image_prompts": [],
  "stylize": 750,
  "chaos": 0,
  "weird": 250,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
{
  "text": "\"Made in Midjourney\" stamp on a vintage postage stamp",
  "image_prompts": [],
  "stylize": 1000,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 2,
  "aspect_ratio": "1:2",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "zoom": "1.5"
  }
}======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'expressive', 'raw', 'scenic', 'original'} [type=value_error, input_value='default', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 16,
    "aspect_height": 9,
    "aspect_ratio": "16:9",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  },
  {
    "text": "A botanical sketch of fern fronds",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 30,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 16,
    "aspect_height": 9,
    "aspect_ratio": "16:9",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {
      "video": null
    }
  }
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
{
  "text": "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 2,
  "aspect_height": 3,
  "aspect_ratio": "2:3",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  {
    "text": "A cat in a Tundra environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a Jungle environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A cat in a City environment",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 80,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 50,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A child's crayon drawing of a cat",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "raw",
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
{
  "text": "A cyberpunk cat with a neon sign that says \"Midjourney\"",
  "image_prompts": [],
  "stylize": 500,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v6",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
{
  "text": "A pastel watercolor landscape with \"/imagine\" written in the clouds",
  "image_prompts": [],
  "stylize": 250,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 16,
  "aspect_height": 9,
  "aspect_ratio": "16:9",
  "style": null,
  "version": "v6.1",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {}
}======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of pink and blue striped river stones",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pattern of colorful watercolor fall leaves",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 75,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": true,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'cute', 'original', 'raw', 'expressive'} [type=value_error, input_value='random-64', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 0,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 50,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 100,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A portrait of a melancholic robot butler",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [
      "<image URL of classic butler>"
    ],
    "character_weight": 100,
    "style_reference": [
      "<image URL of sad painting>"
    ],
    "style_weight": 800,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 30,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A surreal sculpture made of clockwork oranges and melting clocks",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 70,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
{
  "error": "Invalid value for seed: random - Invalid numeric value: could not convert string to float: 'random'"
}======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  {
    "text": "A continuous line charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A loose gestural charcoal drawing of a value study of a cyborg geisha",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 50,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'scenic', 'raw', 'cute', 'original', 'expressive'} [type=value_error, input_value='random', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'expressive', 'original', 'raw', 'scenic'} [type=value_error, input_value='random-16', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A pastel painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a determined sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 25,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
{
  "error": "1 validation error for MidjourneyPrompt\nstyle\n  Value error, Invalid style value. Must be one of: {'cute', 'scenic', 'raw', 'expressive', 'original'} [type=value_error, input_value='random-128', input_type=str]\n    For further information visit https://errors.pydantic.dev/2.10/v/value_error"
}======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
{
  "text": "An impressionistic watercolor of a cat playing chess with a dog",
  "image_prompts": [],
  "stylize": 50,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 4,
  "aspect_height": 3,
  "aspect_ratio": "4:3",
  "style": "raw",
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": "board, pieces",
  "extra_params": {}
}======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
{
  "text": "cheese:: cake:: painting multi-prompt",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 60,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": "v4",
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "negative": "weight fruit::-.5"
  }
}======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 1750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 200,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 600,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Clockwork chicken",
    "image_prompts": [],
    "stylize": 900,
    "chaos": 0,
    "weird": 2750,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 3,
    "aspect_height": 2,
    "aspect_ratio": "3:2",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 10,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 50,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Cyanotype cat",
    "image_prompts": [],
    "stylize": 1000,
    "chaos": 90,
    "weird": 2000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 5",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "cute",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 250,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Ice cream icon",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 1000,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 2,
    "aspect_height": 3,
    "aspect_ratio": "2:3",
    "style": "expressive",
    "version": "niji 6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
{
  "text": "image of a robot holding flowers",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "remix": null,
    "prompt": "A cyborg holding cybernetic orchids",
    "zoom": "2x"
  }
}======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1400s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 1,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Imagine a 1990s cat",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 5,
    "aspect_height": 4,
    "aspect_ratio": "5:4",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [
      "<image URL of medieval tapestry>"
    ],
    "style_weight": null,
    "style_version": 4,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 1500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 20,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 60,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.5,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Lithograph potato",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 80,
    "weird": 2500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 250,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "space:: ship multi-prompt",
    "image_prompts": [],
    "stylize": 750,
    "chaos": 0,
    "weird": 500,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
{
  "text": "stream running through a redwood forest",
  "image_prompts": [],
  "stylize": 100,
  "chaos": 0,
  "weird": 0,
  "image_weight": 1.0,
  "seed": null,
  "stop": 100,
  "aspect_width": 1,
  "aspect_height": 1,
  "aspect_ratio": "1:1",
  "style": null,
  "version": null,
  "personalization": false,
  "quality": 1.0,
  "character_reference": [],
  "character_weight": 100,
  "style_reference": [],
  "style_weight": null,
  "style_version": 2,
  "repeat": null,
  "turbo": false,
  "relax": false,
  "tile": false,
  "negative_prompt": null,
  "extra_params": {
    "vary": "region",
    "selection": "sky area",
    "prompt": "aurora borealis",
    "pan": "up"
  }
}======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v5.2",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Vibrant California poppies",
    "image_prompts": [],
    "stylize": 500,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": "v6.1",
    "personalization": false,
    "quality": 2.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": null,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "A flock of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from gigantic orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 0.25,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 2,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  },
  {
    "text": "Three of iridescent hummingbirds drinking nectar from miniature orchids",
    "image_prompts": [],
    "stylize": 100,
    "chaos": 0,
    "weird": 0,
    "image_weight": 1.0,
    "seed": null,
    "stop": 100,
    "aspect_width": 1,
    "aspect_height": 1,
    "aspect_ratio": "1:1",
    "style": null,
    "version": null,
    "personalization": false,
    "quality": 1.0,
    "character_reference": [],
    "character_weight": 100,
    "style_reference": [],
    "style_weight": null,
    "style_version": 2,
    "repeat": 5,
    "turbo": false,
    "relax": false,
    "tile": false,
    "negative_prompt": null,
    "extra_params": {}
  }
]
```

## File: test-cases/prompts-out.txt (Size: 13.41 KB)

```
> mj '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> fal '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> json '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> perm '"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}'
> mj '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> fal '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> json '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> perm '"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250'
> mj '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> fal '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> json '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> perm '"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2'
> mj 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> fal 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> json 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> perm 'A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}'
> mj 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> fal 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> json 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> perm 'A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30'
> mj 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> fal 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> json 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> perm 'A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3'
> mj 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> fal 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> json 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> perm 'A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000'
> mj 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> fal 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> json 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> perm 'A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}'
> mj 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> fal 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> json 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> perm 'A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1'
> mj 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> fal 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> json 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> perm 'A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9'
> mj 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> fal 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> json 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> perm 'A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}'
> mj 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> fal 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> json 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> perm 'A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading'
> mj 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> fal 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> json 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> perm 'A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}'
> mj 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> fal 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> json 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> perm 'A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}'
> mj 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> fal 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> json 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> perm 'A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}'
> mj 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> fal 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> json 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> perm 'A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5'
> mj 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> fal 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> json 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> perm 'A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}'
> mj 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> fal 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> json 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> perm 'A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome'
> mj 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> fal 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> json 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> perm 'A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25'
> mj 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> fal 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> json 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> perm 'A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers'
> mj 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> fal 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> json 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> perm 'An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw'
> mj 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> fal 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> json 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> perm 'cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60'
> mj 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> fal 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> json 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> perm 'Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}'
> mj 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> fal 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> json 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> perm 'Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}'
> mj 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> fal 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> json 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> perm 'Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}'
> mj 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> fal 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> json 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> perm 'image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x'
> mj 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> fal 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> json 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> perm 'Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4'
> mj 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> fal 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> json 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> perm 'Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}'
> mj 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> fal 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> json 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> perm 'space:: ship multi-prompt  --stylize {250, 750} --weird 500'
> mj 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> fal 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> json 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> perm 'stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up'
> mj 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> fal 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> json 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> perm 'Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}'
> mj '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
> fal '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
> json '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
> perm '{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}'
```

## File: test-cases/prompts-perm.txt (Size: 19.07 KB)

```
======
"Do not enter" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed {12345, 67890}
[
  "\"Do not enter\" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed 12345",
  "\"Do not enter\" sign in Elvish script, overgrown with vines --v 6 --stylize 250 --seed 67890"
]======
"Lost in translation" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250
[
  "\"Lost in translation\" neon sign in a Tokyo alleyway --v 6.1 --stylize 750 --weird 250"
]======
"Made in Midjourney" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2
[
  "\"Made in Midjourney\" stamp on a vintage postage stamp --v 6.1 --stylize 1000 --zoom 1.5 --ar 1:2"
]======
A black and white oak tree icon --style {raw, default} --stylize {0, 1000} --weird {0, 3000}
[
  "A black and white oak tree icon --style raw --stylize 0 --weird 0",
  "A black and white oak tree icon --style raw --stylize 0 --weird 3000",
  "A black and white oak tree icon --style raw --stylize 1000 --weird 0",
  "A black and white oak tree icon --style raw --stylize 1000 --weird 3000",
  "A black and white oak tree icon --style default --stylize 0 --weird 0",
  "A black and white oak tree icon --style default --stylize 0 --weird 3000",
  "A black and white oak tree icon --style default --stylize 1000 --weird 0",
  "A black and white oak tree icon --style default --stylize 1000 --weird 3000"
]======
A botanical sketch of fern fronds --video --version {5.2, 6} --ar {1:1, 16:9} --chaos 30
[
  "A botanical sketch of fern fronds --video --version 5.2 --ar 1:1 --chaos 30",
  "A botanical sketch of fern fronds --video --version 5.2 --ar 16:9 --chaos 30",
  "A botanical sketch of fern fronds --video --version 6 --ar 1:1 --chaos 30",
  "A botanical sketch of fern fronds --video --version 6 --ar 16:9 --chaos 30"
]======
A cartoon drawing of a manual with the words "read the docs" in big text on the pages --v 6 --stylize 100 --ar 2:3
[
  "A cartoon drawing of a manual with the words \"read the docs\" in big text on the pages --v 6 --stylize 100 --ar 2:3"
]======
A cat in a {Tundra, Jungle, City} environment --ar 3:2 --stop 80 --weird 2000
[
  "A cat in a Tundra environment --ar 3:2 --stop 80 --weird 2000",
  "A cat in a Jungle environment --ar 3:2 --stop 80 --weird 2000",
  "A cat in a City environment --ar 3:2 --stop 80 --weird 2000"
]======
A child's crayon drawing of a cat --version {5.2, 6} --style raw --stylize {50, 750} --quality {.25, 1}
[
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 50 --quality .25",
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 50 --quality 1",
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 750 --quality .25",
  "A child's crayon drawing of a cat --version 5.2 --style raw --stylize 750 --quality 1",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 50 --quality .25",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 50 --quality 1",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 750 --quality .25",
  "A child's crayon drawing of a cat --version 6 --style raw --stylize 750 --quality 1"
]======
A cyberpunk cat with a neon sign that says "Midjourney" --v 6 --stylize 500 --ar 1:1
[
  "A cyberpunk cat with a neon sign that says \"Midjourney\" --v 6 --stylize 500 --ar 1:1"
]======
A pastel watercolor landscape with "/imagine" written in the clouds --v 6.1 --stylize 250 --ar 16:9
[
  "A pastel watercolor landscape with \"/imagine\" written in the clouds --v 6.1 --stylize 250 --ar 16:9"
]======
A pattern of {pink and blue striped river stones, colorful watercolor fall leaves} --tile --chaos {25, 75}
[
  "A pattern of pink and blue striped river stones --tile --chaos 25",
  "A pattern of pink and blue striped river stones --tile --chaos 75",
  "A pattern of colorful watercolor fall leaves --tile --chaos 25",
  "A pattern of colorful watercolor fall leaves --tile --chaos 75"
]======
A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading
[
  "A pencil sketch of a dragon made of constellations --ar 2:3 --style random-64 --no color, shading"
]======
A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw {0, 50, 100} --sref <image URL of sad painting> --sw {100, 800}
[
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 0 --sref <image URL of sad painting> --sw 100",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 0 --sref <image URL of sad painting> --sw 800",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 50 --sref <image URL of sad painting> --sw 100",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 50 --sref <image URL of sad painting> --sw 800",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 100 --sref <image URL of sad painting> --sw 100",
  "A portrait of a melancholic robot butler --cref <image URL of classic butler> --cw 100 --sref <image URL of sad painting> --sw 800"
]======
A surreal sculpture made of clockwork oranges and melting clocks --weird {500, 1500} --chaos 80 --stop {30, 70}
[
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 500 --chaos 80 --stop 30",
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 500 --chaos 80 --stop 70",
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 1500 --chaos 80 --stop 30",
  "A surreal sculpture made of clockwork oranges and melting clocks --weird 1500 --chaos 80 --stop 70"
]======
A vibrant California poppies image --aspect {5:4, 7:4} --chaos {10, 50} --quality {.5, 1} --seed {random, 4294967295}
[
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 10 --quality 1 --seed 4294967295",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 5:4 --chaos 50 --quality 1 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 10 --quality 1 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality .5 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality .5 --seed 4294967295",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality 1 --seed random",
  "A vibrant California poppies image --aspect 7:4 --chaos 50 --quality 1 --seed 4294967295"
]======
A {continuous line, loose gestural} charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5
[
  "A continuous line charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5",
  "A loose gestural charcoal drawing of a value study of a cyborg geisha --stop 50 --q 0.5"
]======
A {dreary, vibrant} cyberpunk cityscape --ar {16:9, 1:1} --style {raw, random} --chaos {0, 100}
[
  "A dreary cyberpunk cityscape --ar 16:9 --style raw --chaos 0",
  "A dreary cyberpunk cityscape --ar 16:9 --style raw --chaos 100",
  "A dreary cyberpunk cityscape --ar 16:9 --style random --chaos 0",
  "A dreary cyberpunk cityscape --ar 16:9 --style random --chaos 100",
  "A dreary cyberpunk cityscape --ar 1:1 --style raw --chaos 0",
  "A dreary cyberpunk cityscape --ar 1:1 --style raw --chaos 100",
  "A dreary cyberpunk cityscape --ar 1:1 --style random --chaos 0",
  "A dreary cyberpunk cityscape --ar 1:1 --style random --chaos 100",
  "A vibrant cyberpunk cityscape --ar 16:9 --style raw --chaos 0",
  "A vibrant cyberpunk cityscape --ar 16:9 --style raw --chaos 100",
  "A vibrant cyberpunk cityscape --ar 16:9 --style random --chaos 0",
  "A vibrant cyberpunk cityscape --ar 16:9 --style random --chaos 100",
  "A vibrant cyberpunk cityscape --ar 1:1 --style raw --chaos 0",
  "A vibrant cyberpunk cityscape --ar 1:1 --style raw --chaos 100",
  "A vibrant cyberpunk cityscape --ar 1:1 --style random --chaos 0",
  "A vibrant cyberpunk cityscape --ar 1:1 --style random --chaos 100"
]======
A {Millennial Pink, Acid Green, Ebony} colored cat --s 250 --style random-16 --no monochrome
[
  "A Millennial Pink colored cat --s 250 --style random-16 --no monochrome",
  "A Acid Green colored cat --s 250 --style random-16 --no monochrome",
  "A Ebony colored cat --s 250 --style random-16 --no monochrome"
]======
A {pastel, blacklight} painting of a {determined, sleepy} sloth riding a unicorn through a {crystal forest, salt flat} --chaos 25
[
  "A pastel painting of a determined sloth riding a unicorn through a crystal forest --chaos 25",
  "A pastel painting of a determined sloth riding a unicorn through a salt flat --chaos 25",
  "A pastel painting of a sleepy sloth riding a unicorn through a crystal forest --chaos 25",
  "A pastel painting of a sleepy sloth riding a unicorn through a salt flat --chaos 25",
  "A blacklight painting of a determined sloth riding a unicorn through a crystal forest --chaos 25",
  "A blacklight painting of a determined sloth riding a unicorn through a salt flat --chaos 25",
  "A blacklight painting of a sleepy sloth riding a unicorn through a crystal forest --chaos 25",
  "A blacklight painting of a sleepy sloth riding a unicorn through a salt flat --chaos 25"
]======
A {pixel art, acrylic pour} style cat --style random-128 --weird 1000 --no fur, whiskers
[
  "A pixel art style cat --style random-128 --weird 1000 --no fur, whiskers",
  "A acrylic pour style cat --style random-128 --weird 1000 --no fur, whiskers"
]======
An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw
[
  "An impressionistic watercolor of a cat playing chess with a dog --ar 4:3 --s 50 --no board, pieces --style raw"
]======
cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60
[
  "cheese:: cake:: painting multi-prompt --negative weight fruit::-.5 --version 4 --chaos 60"
]======
Clockwork chicken --weird {750, 1750, 2750} --stylize {200, 600, 900} --ar {2:3, 3:2}
[
  "Clockwork chicken --weird 750 --stylize 200 --ar 2:3",
  "Clockwork chicken --weird 750 --stylize 200 --ar 3:2",
  "Clockwork chicken --weird 750 --stylize 600 --ar 2:3",
  "Clockwork chicken --weird 750 --stylize 600 --ar 3:2",
  "Clockwork chicken --weird 750 --stylize 900 --ar 2:3",
  "Clockwork chicken --weird 750 --stylize 900 --ar 3:2",
  "Clockwork chicken --weird 1750 --stylize 200 --ar 2:3",
  "Clockwork chicken --weird 1750 --stylize 200 --ar 3:2",
  "Clockwork chicken --weird 1750 --stylize 600 --ar 2:3",
  "Clockwork chicken --weird 1750 --stylize 600 --ar 3:2",
  "Clockwork chicken --weird 1750 --stylize 900 --ar 2:3",
  "Clockwork chicken --weird 1750 --stylize 900 --ar 3:2",
  "Clockwork chicken --weird 2750 --stylize 200 --ar 2:3",
  "Clockwork chicken --weird 2750 --stylize 200 --ar 3:2",
  "Clockwork chicken --weird 2750 --stylize 600 --ar 2:3",
  "Clockwork chicken --weird 2750 --stylize 600 --ar 3:2",
  "Clockwork chicken --weird 2750 --stylize 900 --ar 2:3",
  "Clockwork chicken --weird 2750 --stylize 900 --ar 3:2"
]======
Cyanotype cat --weird {250, 1000, 2000} --stylize {100, 500, 1000} --chaos {10, 50, 90}
[
  "Cyanotype cat --weird 250 --stylize 100 --chaos 10",
  "Cyanotype cat --weird 250 --stylize 100 --chaos 50",
  "Cyanotype cat --weird 250 --stylize 100 --chaos 90",
  "Cyanotype cat --weird 250 --stylize 500 --chaos 10",
  "Cyanotype cat --weird 250 --stylize 500 --chaos 50",
  "Cyanotype cat --weird 250 --stylize 500 --chaos 90",
  "Cyanotype cat --weird 250 --stylize 1000 --chaos 10",
  "Cyanotype cat --weird 250 --stylize 1000 --chaos 50",
  "Cyanotype cat --weird 250 --stylize 1000 --chaos 90",
  "Cyanotype cat --weird 1000 --stylize 100 --chaos 10",
  "Cyanotype cat --weird 1000 --stylize 100 --chaos 50",
  "Cyanotype cat --weird 1000 --stylize 100 --chaos 90",
  "Cyanotype cat --weird 1000 --stylize 500 --chaos 10",
  "Cyanotype cat --weird 1000 --stylize 500 --chaos 50",
  "Cyanotype cat --weird 1000 --stylize 500 --chaos 90",
  "Cyanotype cat --weird 1000 --stylize 1000 --chaos 10",
  "Cyanotype cat --weird 1000 --stylize 1000 --chaos 50",
  "Cyanotype cat --weird 1000 --stylize 1000 --chaos 90",
  "Cyanotype cat --weird 2000 --stylize 100 --chaos 10",
  "Cyanotype cat --weird 2000 --stylize 100 --chaos 50",
  "Cyanotype cat --weird 2000 --stylize 100 --chaos 90",
  "Cyanotype cat --weird 2000 --stylize 500 --chaos 10",
  "Cyanotype cat --weird 2000 --stylize 500 --chaos 50",
  "Cyanotype cat --weird 2000 --stylize 500 --chaos 90",
  "Cyanotype cat --weird 2000 --stylize 1000 --chaos 10",
  "Cyanotype cat --weird 2000 --stylize 1000 --chaos 50",
  "Cyanotype cat --weird 2000 --stylize 1000 --chaos 90"
]======
Ice cream icon --niji {5, 6} --style {cute, expressive} --weird {250, 1000} --ar {1:1, 2:3}
[
  "Ice cream icon --niji 5 --style cute --weird 250 --ar 1:1",
  "Ice cream icon --niji 5 --style cute --weird 250 --ar 2:3",
  "Ice cream icon --niji 5 --style cute --weird 1000 --ar 1:1",
  "Ice cream icon --niji 5 --style cute --weird 1000 --ar 2:3",
  "Ice cream icon --niji 5 --style expressive --weird 250 --ar 1:1",
  "Ice cream icon --niji 5 --style expressive --weird 250 --ar 2:3",
  "Ice cream icon --niji 5 --style expressive --weird 1000 --ar 1:1",
  "Ice cream icon --niji 5 --style expressive --weird 1000 --ar 2:3",
  "Ice cream icon --niji 6 --style cute --weird 250 --ar 1:1",
  "Ice cream icon --niji 6 --style cute --weird 250 --ar 2:3",
  "Ice cream icon --niji 6 --style cute --weird 1000 --ar 1:1",
  "Ice cream icon --niji 6 --style cute --weird 1000 --ar 2:3",
  "Ice cream icon --niji 6 --style expressive --weird 250 --ar 1:1",
  "Ice cream icon --niji 6 --style expressive --weird 250 --ar 2:3",
  "Ice cream icon --niji 6 --style expressive --weird 1000 --ar 1:1",
  "Ice cream icon --niji 6 --style expressive --weird 1000 --ar 2:3"
]======
image of a robot holding flowers --remix --prompt "A cyborg holding cybernetic orchids" --zoom 2x
[
  "image of a robot holding flowers --remix --prompt \"A cyborg holding cybernetic orchids\" --zoom 2x"
]======
Imagine a {1400s, 1990s} cat --sref <image URL of medieval tapestry> --sv {1, 4} --ar 5:4
[
  "Imagine a 1400s cat --sref <image URL of medieval tapestry> --sv 1 --ar 5:4",
  "Imagine a 1400s cat --sref <image URL of medieval tapestry> --sv 4 --ar 5:4",
  "Imagine a 1990s cat --sref <image URL of medieval tapestry> --sv 1 --ar 5:4",
  "Imagine a 1990s cat --sref <image URL of medieval tapestry> --sv 4 --ar 5:4"
]======
Lithograph potato --weird {500, 1500, 2500} --chaos {20, 60, 80} --quality {.5, 1}
[
  "Lithograph potato --weird 500 --chaos 20 --quality .5",
  "Lithograph potato --weird 500 --chaos 20 --quality 1",
  "Lithograph potato --weird 500 --chaos 60 --quality .5",
  "Lithograph potato --weird 500 --chaos 60 --quality 1",
  "Lithograph potato --weird 500 --chaos 80 --quality .5",
  "Lithograph potato --weird 500 --chaos 80 --quality 1",
  "Lithograph potato --weird 1500 --chaos 20 --quality .5",
  "Lithograph potato --weird 1500 --chaos 20 --quality 1",
  "Lithograph potato --weird 1500 --chaos 60 --quality .5",
  "Lithograph potato --weird 1500 --chaos 60 --quality 1",
  "Lithograph potato --weird 1500 --chaos 80 --quality .5",
  "Lithograph potato --weird 1500 --chaos 80 --quality 1",
  "Lithograph potato --weird 2500 --chaos 20 --quality .5",
  "Lithograph potato --weird 2500 --chaos 20 --quality 1",
  "Lithograph potato --weird 2500 --chaos 60 --quality .5",
  "Lithograph potato --weird 2500 --chaos 60 --quality 1",
  "Lithograph potato --weird 2500 --chaos 80 --quality .5",
  "Lithograph potato --weird 2500 --chaos 80 --quality 1"
]======
space:: ship multi-prompt --stylize {250, 750} --weird 500
[
  "space:: ship multi-prompt  --stylize 250 --weird 500",
  "space:: ship multi-prompt  --stylize 750 --weird 500"
]======
stream running through a redwood forest --vary region --selection "sky area" --prompt "aurora borealis" --pan up
[
  "stream running through a redwood forest --vary region --selection \"sky area\" --prompt \"aurora borealis\" --pan up"
]======
Vibrant California poppies --version {5.2, 6, 6.1} --stylize {100, 500} --quality {1, 2}
[
  "Vibrant California poppies --version 5.2 --stylize 100 --quality 1",
  "Vibrant California poppies --version 5.2 --stylize 100 --quality 2",
  "Vibrant California poppies --version 5.2 --stylize 500 --quality 1",
  "Vibrant California poppies --version 5.2 --stylize 500 --quality 2",
  "Vibrant California poppies --version 6 --stylize 100 --quality 1",
  "Vibrant California poppies --version 6 --stylize 100 --quality 2",
  "Vibrant California poppies --version 6 --stylize 500 --quality 1",
  "Vibrant California poppies --version 6 --stylize 500 --quality 2",
  "Vibrant California poppies --version 6.1 --stylize 100 --quality 1",
  "Vibrant California poppies --version 6.1 --stylize 100 --quality 2",
  "Vibrant California poppies --version 6.1 --stylize 500 --quality 1",
  "Vibrant California poppies --version 6.1 --stylize 500 --quality 2"
]======
{A flock, Three} of iridescent hummingbirds drinking nectar from {gigantic, miniature} orchids --q {0.25, 1} --repeat {2, 5}
[
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 5",
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 5",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 5",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 2",
  "A flock of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 0.25 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from gigantic orchids --q 1 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 0.25 --repeat 5",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 2",
  "Three of iridescent hummingbirds drinking nectar from miniature orchids --q 1 --repeat 5"
]
```

## File: test-cases/prompts.sh (Size: 0.44 KB)

```
#!/usr/bin/env bash
# this_file: test-cases/prompts.sh

# THIS READS PROMPTS FROM prompts-in.txt
# THE ERRORS are in prompts-out.txt
# THE OUTPUT OF THE midjargon commands are in the -mj -fal -json -perm files

cat ./prompts-in.txt | while read p; do
    for o in mj fal json perm; do
        echo "> $o '$p'"
        echo "======" >>prompts-$o.txt
        echo "$p" >>prompts-$o.txt
        midjargon "$o" "$p" --json >>prompts-$o.txt
    done
done
```

## File: tests/__init__.py (Size: 0.03 KB)

```
# this_file: tests/__init__.py
```

## File: tests/cli/__init__.py (Size: 0.03 KB)

```
# this_file: tests/cli/__init__.py
```

## File: tests/cli/test_main.py (Size: 10.77 KB)

```
#!/usr/bin/env -S uv run
# /// script
# dependencies = ["pytest", "rich"]
# ///
# this_file: tests/cli/test_main.py

"""Tests for CLI functionality."""

import json
import re
import sys
from io import StringIO
from typing import Any

import pytest
from rich.console import Console

from midjargon.cli.main import MidjargonCLI

# Test constants
ASPECT_WIDTH = 16
ASPECT_HEIGHT = 9
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
IMAGE_PROMPTS_COUNT = 2
PERMUTATION_COUNT_2X2 = 4  # 2 options x 2 options

ANSI_ESCAPE = re.compile(r"\x1B[@-_][0-?]*[ -/]*[@-~]")


def parse_json_output(output_stream: StringIO) -> Any:
    """Parse JSON output from the CLI, removing ANSI escape sequences if any."""
    output_stream.seek(0)
    output = output_stream.getvalue()
    # Remove ANSI escape sequences
    output = ANSI_ESCAPE.sub("", output)
    output = output.strip()
    if not output:
        msg = "No JSON found in output"
        raise ValueError(msg)
    try:
        return json.loads(output)
    except json.JSONDecodeError as e:
        msg = "No JSON found in output"
        raise ValueError(msg) from e


@pytest.fixture
def cli():
    """Fixture to provide CLI instance."""
    return MidjargonCLI()


def test_basic_prompt(cli):
    """Test basic prompt processing."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(
            f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT}",
            json_output=True,
        )
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a beautiful landscape"
    assert data["aspect"] == f"{ASPECT_WIDTH}:{ASPECT_HEIGHT}"


def test_permutations(cli):
    """Test permutation processing."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm("a {red, blue} bird", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 2
    texts = set(data)
    assert texts == {"a red bird", "a blue bird"}


def test_raw_output(cli):
    """Test raw output mode."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(f"a photo --stylize {STYLIZE_VALUE}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"
    assert data["stylize"] == STYLIZE_VALUE


def test_json_output_formatting(cli):
    """Test JSON output formatting."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"
    assert "images" in data


def test_invalid_input(cli):
    """Test handling of invalid input."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
        assert data["text"] == ""


def test_parameter_validation(cli):
    """Test parameter validation."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(
            f"a photo --stylize {STYLIZE_VALUE * 20}", json_output=True
        )  # Over max
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
        assert data["stylize"] == STYLIZE_VALUE * 20  # Now accepts any value


def test_image_url_handling(cli):
    """Test handling of image URLs."""
    url = "https://example.com/image.jpg"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(f"{url} a fusion", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a fusion"
    assert len(data["images"]) == 1
    assert data["images"][0] == url


def test_no_color_output(cli):
    """Test no-color output mode."""
    Console(force_terminal=False)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo", json_output=True, no_color=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a photo"


def test_complex_prompt(cli):
    """Test complex prompt with multiple features."""
    prompt = (
        "https://example.com/img1.jpg https://example.com/img2.jpg "
        "a {red, blue} bird on a {branch, rock} "
        f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} --chaos {CHAOS_VALUE}"
    )
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == PERMUTATION_COUNT_2X2
    for prompt in data:
        assert len(prompt["images"]) == IMAGE_PROMPTS_COUNT
        assert prompt["stylize"] == STYLIZE_VALUE
        assert prompt["chaos"] == CHAOS_VALUE
        assert prompt["aspect"] == f"{ASPECT_WIDTH}:{ASPECT_HEIGHT}"


def test_personalization_parameter(cli):
    """Test personalization parameter handling in different forms."""
    # Test flag form (--p)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --p", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] is None  # Flag parameters should be None

    # Test with code (--p CODE1)
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --p CODE1", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] == ["CODE1"]

    # Test with multiple codes (--p "CODE1 CODE2")
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json('a photo --p "CODE1 CODE2"', json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["personalization"] == ["CODE1", "CODE2"]


def test_numeric_range_permutations(cli):
    """Test handling of numeric parameters in permutations."""
    # Test stylize parameter range
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 2
    stylize_values = {prompt["stylize"] for prompt in data}
    assert stylize_values == {75, 300}

    # Test multiple numeric parameters
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("a photo --s {75, 300} --c {0, 50}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4  # 2x2 combinations
    stylize_values = {prompt["stylize"] for prompt in data}
    chaos_values = {prompt["chaos"] for prompt in data}
    assert stylize_values == {75, 300}
    assert chaos_values == {0, 50}


def test_nested_parameter_permutations(cli):
    """Test handling of nested permutations with parameters."""
    # Test personalization with nested options
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("smooth edges {, --p {, CODE1}} --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 6  # 3x2 combinations (no --p, empty --p, --p CODE1) x (75, 300)

    # Verify all combinations
    variants = [
        (None, 75),  # No --p, stylize 75
        (None, 300),  # No --p, stylize 300
        (True, 75),  # Empty --p, stylize 75
        (True, 300),  # Empty --p, stylize 300
        (["CODE1"], 75),  # --p with code, stylize 75
        (["CODE1"], 300),  # --p with code, stylize 300
    ]
    for prompt in data:
        assert prompt["text"] == "smooth edges"
        assert (prompt.get("personalization"), prompt["stylize"]) in variants

    # Test more complex nested permutations
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.json("smooth edges {, --p {, CODE1 CODE2}} --s {75, 300}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 6  # 3x2 combinations

    # Verify all combinations
    variants = [
        (None, 75),  # No --p, stylize 75
        (None, 300),  # No --p, stylize 300
        (True, 75),  # Empty --p, stylize 75
        (True, 300),  # Empty --p, stylize 300
        (["CODE1", "CODE2"], 75),  # --p with codes, stylize 75
        (["CODE1", "CODE2"], 300),  # --p with codes, stylize 300
    ]
    for prompt in data:
        assert prompt["text"] == "smooth edges"
        assert (prompt.get("personalization"), prompt["stylize"]) in variants


def test_mj_command(cli):
    """Test Midjourney prompt conversion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.mj("a serene landscape --ar 16:9 --stylize 100", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)  # Changed from list to dict
    assert data["text"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_fal_command(cli):
    """Test Fal.ai prompt conversion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.fal("a serene landscape --ar 16:9 --stylize 100", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["prompt"] == "a serene landscape"
    assert data["aspect_ratio"] == "16:9"
    assert data["stylize"] == 100


def test_perm_command(cli):
    """Test permutation expansion."""
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm("a {red, blue} bird on a {branch, rock}", json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4
    expected = [
        "a red bird on a branch",
        "a red bird on a rock",
        "a blue bird on a branch",
        "a blue bird on a rock",
    ]
    assert set(data) == set(expected)
```

## File: tests/conftest.py (Size: 1.04 KB)

```
# this_file: tests/conftest.py
"""Pytest configuration and shared fixtures."""

import pytest


@pytest.fixture
def sample_prompts():
    """Return a dictionary of sample prompts for testing."""
    return {
        "basic": "a serene landscape --ar 16:9 --stylize 100",
        "with_image": "https://example.com/image.jpg mystical forest --chaos 20",
        "permutation": "a {red, blue} bird on a {flower, leaf} --ar 16:9",
        "multi_prompt": "mystical forest ::2 foggy mountains ::1 --chaos 20",
        "with_flags": "landscape photo --tile --no blur,cars",
        "escaped_commas": "a {red\\, blue, green} bird",
        "nested": "a {big {red, blue}, small green} bird",
        "multiple_images": "https://example.com/1.jpg https://example.com/2.jpg forest --iw 2",
    }


@pytest.fixture
def invalid_prompts():
    """Return a dictionary of invalid prompts for testing."""
    return {
        "empty": "",
        "only_params": "--ar 16:9",
        "unclosed_brace": "a {red, blue bird",
        "invalid_weight": "forest ::x mountains",
    }
```

## File: tests/core/__init__.py (Size: 0.04 KB)

```
# this_file: tests/core/__init__.py
```

## File: tests/core/test_input.py (Size: 3.74 KB)

```
# this_file: tests/core/test_input.py
"""Tests for input handling."""

from midjargon.core.input import expand_midjargon_input

# Test constants
PERMUTATION_COUNT_2 = 2  # Single permutation with 2 options
PERMUTATION_COUNT_3 = 3  # Single permutation with 3 options


def test_basic_input():
    """Test basic input without permutations."""
    result = expand_midjargon_input("a simple prompt")
    assert len(result) == 1
    assert result[0] == "a simple prompt"


def test_single_permutation():
    """Test input with a single permutation."""
    result = expand_midjargon_input("a {red, blue} bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red bird" in result
    assert "a blue bird" in result


def test_empty_input():
    """Test empty input handling."""
    result = expand_midjargon_input("")
    assert len(result) == 1
    assert result[0] == ""


def test_multiple_permutations():
    """Test input with multiple permutations."""
    result = expand_midjargon_input("a {red, blue, green} bird")
    assert len(result) == PERMUTATION_COUNT_3
    assert "a red bird" in result
    assert "a blue bird" in result
    assert "a green bird" in result


def test_nested_permutations():
    """Test input with nested permutations."""
    result = expand_midjargon_input("a {red {cat, dog}, blue bird}")
    assert len(result) == PERMUTATION_COUNT_3
    assert "a red cat" in result
    assert "a red dog" in result
    assert "a blue bird" in result


def test_escaped_braces():
    """Test input with escaped braces."""
    result = expand_midjargon_input(r"a \{red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"


def test_escaped_commas():
    """Test input with escaped commas."""
    result = expand_midjargon_input(r"a {red\, blue, green} bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red, blue bird" in result
    assert "a green bird" in result


def test_unmatched_braces():
    """Test input with unmatched braces."""
    result = expand_midjargon_input("a {red, blue bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue bird"


def test_empty_permutation():
    """Test input with empty permutation options."""
    result = expand_midjargon_input("a {} bird")
    assert len(result) == 1
    assert result[0] == "a bird"


def test_whitespace_handling():
    """Test input with various whitespace patterns."""
    result = expand_midjargon_input("a {  red  ,  blue  } bird")
    assert len(result) == PERMUTATION_COUNT_2
    assert "a red bird" in result
    assert "a blue bird" in result


def test_expand_midjargon_input():
    """Test expand_midjargon_input function to verify prompt expansion."""
    result = expand_midjargon_input("a {red, blue} bird")
    assert len(result) == 2
    assert "a red bird" in result
    assert "a blue bird" in result

    result = expand_midjargon_input("a {red, blue, green} bird")
    assert len(result) == 3
    assert "a red bird" in result
    assert "a blue bird" in result
    assert "a green bird" in result

    result = expand_midjargon_input("a {red {cat, dog}, blue bird}")
    assert len(result) == 3
    assert "a red cat" in result
    assert "a red dog" in result
    assert "a blue bird" in result


def test_handling_escaped_characters():
    """Test handling of escaped characters in expand_midjargon_input."""
    result = expand_midjargon_input(r"a \{red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"

    result = expand_midjargon_input(r"a {red\, blue, green} bird")
    assert len(result) == 2
    assert "a red, blue bird" in result
    assert "a green bird" in result

    result = expand_midjargon_input(r"a {red, blue\} bird")
    assert len(result) == 1
    assert result[0] == "a {red, blue} bird"
```

## File: tests/core/test_parameters.py (Size: 9.75 KB)

```
# this_file: tests/core/test_parameters.py
"""Tests for parameter parsing functionality."""

import pytest

from midjargon.core.parameters import parse_parameters


def test_basic_parameter_parsing():
    """Test parsing of basic parameters."""
    param_str = "--ar 16:9 --stylize 100"
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["stylize"] == "100"


def test_flag_parameters():
    """Test parsing of flag parameters (without values)."""
    param_str = "--tile --turbo --relax"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None


def test_parameter_with_multiple_values():
    """Test parsing parameters that accept multiple values."""
    param_str = "--no blur,cars,watermark"
    params = parse_parameters(param_str)
    assert params["no"] == "blur,cars,watermark"


def test_parameter_with_spaces():
    """Test parsing parameters with values containing spaces."""
    param_str = '--style "raw photo" --seed 123456'
    params = parse_parameters(param_str)
    assert params["style"] == "raw photo"
    assert params["seed"] == "123456"


def test_mixed_parameters():
    """Test parsing a mix of different parameter types."""
    param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["tile"] is None
    assert params["no"] == "blur,cars"
    assert params["style"] == "raw photo"


def test_shorthand_parameters():
    """Test parsing of shorthand parameter names."""
    param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
    params = parse_parameters(param_str)
    assert params["stylize"] == "100"
    assert params["chaos"] == "50"
    assert params["weird"] == "1000"
    assert params["image_weight"] == "2.0"
    assert params["quality"] == "1.0"


def test_niji_version_parameter():
    """Test parsing of niji version parameter."""
    # Test basic niji
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"


def test_version_parameter():
    """Test parsing of version parameter."""
    # Test v parameter
    params = parse_parameters("--v 5.2")
    assert params["version"] == "5.2"


def test_personalization_parameter():
    """Test parsing of personalization parameter."""
    # Test basic p parameter
    params = parse_parameters("--p")
    assert params["personalization"] is None  # Flag without value is None

    # Test p parameter with value
    params = parse_parameters("--p custom")
    assert params["personalization"] == ["custom"]

    # Test p parameter with multiple values
    params = parse_parameters("--p custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]

    # Test personalization parameter with value
    params = parse_parameters("--personalization custom")
    assert params["personalization"] == ["custom"]

    # Test personalization parameter with multiple values
    params = parse_parameters("--personalization custom1 custom2")
    assert params["personalization"] == ["custom1", "custom2"]


def test_reference_parameters():
    """Test parsing of reference parameters."""
    param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
    params = parse_parameters(param_str)
    assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
    assert params["style_reference"] == ["style1.jpg", "style2.jpg"]


def test_parameter_order():
    """Test that parameter order is preserved in output."""
    param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
    params = parse_parameters(param_str)
    keys = list(params.keys())
    assert keys == ["seed", "aspect", "chaos", "tile"]


def test_invalid_parameters():
    """Test handling of invalid parameter formats."""
    with pytest.raises(ValueError, match="Empty parameter name"):
        parse_parameters("--")  # Empty parameter name

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--ar")  # Missing required value

    with pytest.raises(ValueError, match="Parameter name cannot start with dash"):
        parse_parameters("ar 16:9")  # Missing -- prefix

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--v")  # Missing version value


def test_parse_parameters():
    """Test parse_parameters function to verify parameter parsing."""
    param_str = "--ar 16:9 --stylize 100"
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["stylize"] == "100"

    param_str = "--tile --turbo --relax"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None

    param_str = "--no blur,cars,watermark"
    params = parse_parameters(param_str)
    assert params["no"] == "blur,cars,watermark"

    param_str = '--style "raw photo" --seed 123456'
    params = parse_parameters(param_str)
    assert params["style"] == "raw photo"
    assert params["seed"] == "123456"

    param_str = '--ar 16:9 --tile --no blur,cars --style "raw photo"'
    params = parse_parameters(param_str)
    assert params["aspect"] == "16:9"
    assert params["tile"] is None
    assert params["no"] == "blur,cars"
    assert params["style"] == "raw photo"

    param_str = "--s 100 --c 50 --w 1000 --iw 2.0 --q 1.0"
    params = parse_parameters(param_str)
    assert params["stylize"] == "100"
    assert params["chaos"] == "50"
    assert params["weird"] == "1000"
    assert params["image_weight"] == "2.0"
    assert params["quality"] == "1.0"

    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"

    params = parse_parameters("--v 5.2")
    assert params["version"] == "5.2"

    params = parse_parameters("--p")
    assert params["personalization"] is None  # Flag without value is None

    params = parse_parameters("--p custom")
    assert params["personalization"] == ["custom"]

    params = parse_parameters("--personalization custom")
    assert params["personalization"] == ["custom"]

    param_str = "--cref img1.jpg img2.jpg --sref style1.jpg style2.jpg"
    params = parse_parameters(param_str)
    assert params["character_reference"] == ["img1.jpg", "img2.jpg"]
    assert params["style_reference"] == ["style1.jpg", "style2.jpg"]

    param_str = "--seed 123 --ar 16:9 --chaos 20 --tile"
    params = parse_parameters(param_str)
    keys = list(params.keys())
    assert keys == ["seed", "aspect", "chaos", "tile"]

    with pytest.raises(ValueError, match="Empty parameter name"):
        parse_parameters("--")  # Empty parameter name

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--ar")  # Missing required value

    with pytest.raises(ValueError, match="Parameter name cannot start with dash"):
        parse_parameters("ar 16:9")  # Missing -- prefix

    with pytest.raises(ValueError, match="Missing value for parameter"):
        parse_parameters("--v")  # Missing version value


def test_flag_parameters_handling():
    """Test handling of flag parameters in parse_parameters."""
    param_str = "--tile --turbo --relax --video --remix"
    params = parse_parameters(param_str)
    assert params["tile"] is None
    assert params["turbo"] is None
    assert params["relax"] is None
    assert params["video"] is None
    assert params["remix"] is None

    param_str = "--p"
    params = parse_parameters(param_str)
    assert params["personalization"] is None  # Flag without value is None

    param_str = "--p custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]

    param_str = "--personalization custom"
    params = parse_parameters(param_str)
    assert params["personalization"] == ["custom"]


def test_special_seed_values():
    """Test handling of special seed values."""
    # Test random seed
    params = parse_parameters("--seed random")
    assert params["seed"] == "random"

    # Test numeric seed
    params = parse_parameters("--seed 12345")
    assert params["seed"] == "12345"


def test_reference_url_handling():
    """Test handling of URLs in reference parameters."""
    # Test character reference with quoted URL containing spaces
    params = parse_parameters('--cref "https://example.com/image with spaces.jpg"')
    assert params["character_reference"] == [
        "https://example.com/image with spaces.jpg"
    ]

    # Test style reference with quoted URL containing spaces
    params = parse_parameters('--sref "https://example.com/style with spaces.jpg"')
    assert params["style_reference"] == ["https://example.com/style with spaces.jpg"]

    # Test character reference with single URL (no quotes)
    params = parse_parameters("--cref https://example.com/image.jpg")
    assert params["character_reference"] == ["https://example.com/image.jpg"]

    # Test style reference with single URL (no quotes)
    params = parse_parameters("--sref https://example.com/style.jpg")
    assert params["style_reference"] == ["https://example.com/style.jpg"]


def test_niji_version_handling():
    """Test handling of niji version parameter."""
    # Test basic niji flag
    params = parse_parameters("--niji")
    assert params["version"] == "niji"

    # Test niji with version
    params = parse_parameters("--niji 5")
    assert params["version"] == "niji 5"

    # Test niji with version in permutation
    params = parse_parameters("--niji 6")
    assert params["version"] == "niji 6"

    # Ensure no 'v' prefix is added
    version = str(params["version"])  # Convert to string to use startswith
    assert not version.startswith("v")
```

## File: tests/core/test_parser.py (Size: 3.27 KB)

```
# this_file: tests/core/test_parser.py
"""Tests for prompt parsing functionality."""

from midjargon.core.parser import parse_midjargon_prompt_to_dict

# Test constants
ASPECT_RATIO = "16:9"
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
IMAGE_URL = "https://example.com/image.jpg"


def test_basic_prompt_parsing():
    """Test basic prompt parsing."""
    prompt = "a beautiful landscape --ar 16:9 --stylize 100"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a beautiful landscape"
    assert result["aspect"] == ASPECT_RATIO
    assert result["stylize"] == STYLIZE_VALUE


def test_prompt_with_image_url():
    """Test prompt parsing with image URL."""
    prompt = f"{IMAGE_URL} a mystical forest --chaos 50"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a mystical forest"
    assert result["images"] == [IMAGE_URL]
    assert result["chaos"] == CHAOS_VALUE


def test_prompt_with_multiple_image_urls():
    """Test prompt parsing with multiple image URLs."""
    image_urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = f"{image_urls[0]} {image_urls[1]} a serene landscape --stylize 100"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a serene landscape"
    assert result["images"] == image_urls
    assert result["stylize"] == STYLIZE_VALUE


def test_prompt_with_parameters():
    """Test prompt parsing with various parameters."""
    prompt = "a futuristic city --ar 16:9 --stylize 100 --chaos 50"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a futuristic city"
    assert result["aspect"] == ASPECT_RATIO
    assert result["stylize"] == STYLIZE_VALUE
    assert result["chaos"] == CHAOS_VALUE


def test_prompt_with_empty_parameters():
    """Test prompt parsing with empty parameters."""
    prompt = "a landscape photo --tile --no blur,cars"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a landscape photo"
    assert result["tile"] is None
    assert result["no"] == "blur,cars"


def test_prompt_with_escaped_characters():
    """Test prompt parsing with escaped characters."""
    prompt = r"a \{red, blue\} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == r"a \{red, blue\} bird"


def test_prompt_with_nested_permutations():
    """Test prompt parsing with nested permutations."""
    prompt = "a {big {red, blue}, small green} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {big {red, blue}, small green} bird"


def test_prompt_with_unmatched_braces():
    """Test prompt parsing with unmatched braces."""
    prompt = "a {red, blue bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {red, blue bird"


def test_prompt_with_empty_permutation():
    """Test prompt parsing with empty permutation options."""
    prompt = "a {} bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a {} bird"


def test_prompt_with_whitespace_handling():
    """Test prompt parsing with various whitespace patterns."""
    prompt = "a {  red  ,  blue  } bird"
    result = parse_midjargon_prompt_to_dict(prompt)
    assert result["text"] == "a { red , blue } bird"
```

## File: tests/engines/__init__.py (Size: 0.04 KB)

```
# this_file: tests/engines/__init__.py
```

## File: tests/engines/midjourney/__init__.py (Size: 0.05 KB)

```
# this_file: tests/engines/midjourney/__init__.py
```

## File: tests/engines/midjourney/test_midjourney_parser.py (Size: 7.50 KB)

```
# this_file: tests/engines/midjourney/test_midjourney_parser.py
"""Tests for Midjourney parser."""

import pytest
from pydantic import HttpUrl

from midjargon.engines.midjourney import MidjourneyParser

# Test constants
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
WEIRD_VALUE = 1000
SEED_VALUE = 12345
STOP_VALUE = 80
IMAGE_WEIGHT_VALUE = 2.0
VERSION_NUMBER = "5.2"
DEFAULT_STYLIZE = 100
QUALITY_VALUE = 1.5
CHARACTER_WEIGHT_VALUE = 50
STYLE_WEIGHT_VALUE = 500
STYLE_VERSION_VALUE = 3
REPEAT_VALUE = 5


def test_numeric_parameters():
    """Test parsing of numeric parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "stylize": str(STYLIZE_VALUE),
            "seed": str(SEED_VALUE),
            "chaos": str(CHAOS_VALUE),
        }
    )

    assert prompt.text == "a photo"
    assert prompt.stylize == float(STYLIZE_VALUE)
    assert prompt.seed == SEED_VALUE
    assert prompt.chaos == float(CHAOS_VALUE)


def test_style_parameters():
    """Test parsing of style parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {"text": "a photo", "style": "raw", "version": VERSION_NUMBER}
    )

    assert prompt.text == "a photo"
    assert prompt.style == "raw"
    assert prompt.version == f"v{VERSION_NUMBER}"


def test_aspect_ratio():
    """Test parsing of aspect ratio."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict({"text": "a photo", "ar": "16:9"})

    assert prompt.text == "a photo"
    assert prompt.aspect_width == 16
    assert prompt.aspect_height == 9
    assert prompt.aspect_ratio == "16:9"


def test_image_prompts():
    """Test parsing of image prompts."""
    parser = MidjourneyParser()
    urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = parser.parse_dict({"text": "a fusion", "image_prompts": urls})

    assert prompt.text == "a fusion"
    assert len(prompt.image_prompts) == 2
    assert all(isinstance(url, HttpUrl) for url in prompt.image_prompts)
    assert [str(url) for url in prompt.image_prompts] == urls


def test_extra_parameters():
    """Test handling of unknown parameters."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "unknown": "value",
            "flag": None,
        }
    )

    assert prompt.text == "a photo"
    assert prompt.extra_params == {"unknown": "value", "flag": None}


def test_parameter_conversion():
    """Test parameter value conversion."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "stylize": str(STYLIZE_VALUE),
            "seed": str(SEED_VALUE),
            "image_weight": str(IMAGE_WEIGHT_VALUE),
        }
    )

    assert prompt.text == "a photo"
    assert prompt.stylize == float(STYLIZE_VALUE)
    assert prompt.seed == SEED_VALUE
    assert prompt.image_weight == float(IMAGE_WEIGHT_VALUE)


def test_invalid_values():
    """Test handling of invalid parameter values."""
    parser = MidjourneyParser()

    # Invalid aspect ratio - now accepts any value
    result = parser.parse_dict({"text": "a photo", "ar": "999:999"})
    assert result.aspect_width == 999
    assert result.aspect_height == 999
    assert result.aspect_ratio == "999:999"

    # Invalid image URL - treated as extra parameter
    result = parser.parse_dict({"text": "a photo", "image": "not_a_url"})
    assert len(result.image_prompts) == 0
    assert result.extra_params.get("image") == "not_a_url"


def test_empty_values():
    """Test handling of empty values."""
    parser = MidjourneyParser()

    # Empty text
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": ""})

    # Empty image list
    prompt = parser.parse_dict({"text": "a photo", "image_prompts": []})
    assert prompt.text == "a photo"
    assert not prompt.image_prompts

    # None values
    prompt = parser.parse_dict({"text": "a photo", "stylize": None})
    assert prompt.text == "a photo"
    assert prompt.stylize == DEFAULT_STYLIZE  # Default value


def test_version_parameter():
    """Test parsing of version parameter."""
    parser = MidjourneyParser()
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "version": "6",
        }
    )

    assert prompt.text == "a photo"
    assert prompt.version == "v6"


def test_multiple_permutations():
    """Test handling of multiple permutations."""
    parser = MidjourneyParser()

    # Test with parameter permutations
    input_dicts = [
        {"text": "smooth edges", "stylize": "75"},
        {"text": "smooth edges", "stylize": "300"},
        {"text": "smooth edges", "stylize": "75", "personalization": True},
        {"text": "smooth edges", "stylize": "300", "personalization": True},
    ]

    results = [parser.parse_dict(d) for d in input_dicts]
    assert len(results) == 4

    # Verify each permutation is handled correctly
    result_tuples = {(r.text.strip(), r.stylize, r.personalization) for r in results}

    expected = {
        ("smooth edges", 75.0, False),
        ("smooth edges", 300.0, False),
        ("smooth edges", 75.0, True),
        ("smooth edges", 300.0, True),
    }

    assert result_tuples == expected

    # Test with flag permutations
    input_dicts = [
        {"text": "photo"},
        {"text": "photo", "tile": True},
        {"text": "photo", "turbo": True},
        {"text": "photo", "tile": True, "turbo": True},
    ]

    results = [parser.parse_dict(d) for d in input_dicts]
    assert len(results) == 4

    # Verify each permutation is handled correctly
    result_tuples = {(r.text.strip(), r.tile, r.turbo) for r in results}

    expected = {
        ("photo", False, False),
        ("photo", True, False),
        ("photo", False, True),
        ("photo", True, True),
    }

    assert result_tuples == expected


def test_personalization_parameter():
    """Test parsing of personalization parameter."""
    parser = MidjourneyParser()

    # Test flag with True value
    prompt = parser.parse_dict({"text": "a photo", "personalization": True})
    assert prompt.personalization is True

    # Test flag with False value
    prompt = parser.parse_dict({"text": "a photo", "personalization": False})
    assert prompt.personalization is False


def test_edge_cases():
    """Test handling of edge cases in Midjourney parser."""
    parser = MidjourneyParser()

    # Test empty prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": ""})

    # Test prompt with only spaces
    with pytest.raises(ValueError, match="Empty prompt"):
        parser.parse_dict({"text": "   "})

    # Test prompt with special characters
    prompt = parser.parse_dict({"text": "a photo with special characters !@#$%^&*()"})
    assert prompt.text == "a photo with special characters !@#$%^&*()"

    # Test prompt with long text
    long_text = "a" * 1000
    prompt = parser.parse_dict({"text": long_text})
    assert prompt.text == long_text

    # Test prompt with mixed types in extra parameters
    prompt = parser.parse_dict(
        {
            "text": "a photo",
            "extra1": "123",
            "extra2": "45.67",
            "extra3": "true",
            "extra4": None,
            "extra5": "item1",
        }
    )
    assert prompt.extra_params["extra1"] == "123"
    assert prompt.extra_params["extra2"] == "45.67"
    assert prompt.extra_params["extra3"] == "true"
    assert prompt.extra_params["extra4"] is None
    assert prompt.extra_params["extra5"] == "item1"
```

## File: tests/integration/__init__.py (Size: 0.04 KB)

```
# this_file: tests/integration/__init__.py
```

## File: tests/integration/test_workflow.py (Size: 10.86 KB)

```
#!/usr/bin/env python3
# this_file: tests/integration/test_workflow.py
"""Integration tests for complete midjargon workflow."""

import sys
from io import StringIO

import pytest

from midjargon import expand_midjargon_input, parse_midjargon_prompt_to_dict
from midjargon.cli.main import MidjargonCLI
from midjargon.core.models import MidjourneyPrompt
from midjargon.engines.midjourney import parse_midjourney_dict
from tests.cli.test_main import parse_json_output  # Added import for JSON parsing

# Test constants
ASPECT_WIDTH = 16
ASPECT_HEIGHT = 9
STYLIZE_VALUE = 100
CHAOS_VALUE = 50
WEIRD_VALUE = 1000
SEED_VALUE = 12345
STOP_VALUE = 80
IMAGE_WEIGHT_VALUE = 2.0
QUALITY_VALUE = 1.0
CHARACTER_WEIGHT_VALUE = 100
STYLE_WEIGHT_VALUE = 200
STYLE_VERSION_VALUE = 2
REPEAT_VALUE = 3
PERMUTATION_COUNT_2X2 = 4  # 2 options x 2 options
PERMUTATION_COUNT_2X2X2 = 8  # 2 options x 2 options x 2 options


def process_prompt(prompt: str) -> list[MidjourneyPrompt]:
    """Process a prompt through the complete workflow."""
    # Step 1: Expand permutations
    expanded = expand_midjargon_input(prompt)

    # Step 2: Parse each expanded prompt to a dictionary
    midjargon_dicts = [
        parse_midjargon_prompt_to_dict(variant.prompt.to_string())
        for variant in expanded
    ]

    # Step 3: Convert each dictionary to a MidjourneyPrompt
    return [parse_midjourney_dict(d) for d in midjargon_dicts]


def test_basic_workflow():
    """Test basic prompt workflow without permutations."""
    prompt = f"a beautiful landscape --ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "a beautiful landscape"
    assert result.aspect_width == ASPECT_WIDTH
    assert result.aspect_height == ASPECT_HEIGHT
    assert result.stylize == STYLIZE_VALUE


def test_permutation_workflow():
    """Test workflow with permutations."""
    prompt = f"a {{red, blue}} bird on a {{branch, rock}} --stylize {STYLIZE_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == PERMUTATION_COUNT_2X2  # 2x2 permutations
    texts = {r.text for r in results}
    expected = {
        "a red bird on a branch",
        "a red bird on a rock",
        "a blue bird on a branch",
        "a blue bird on a rock",
    }
    assert texts == expected
    assert all(r.stylize == STYLIZE_VALUE for r in results)


def test_image_workflow():
    """Test workflow with image URLs."""
    urls = [
        "https://example.com/image1.jpg",
        "https://example.com/image2.jpg",
    ]
    prompt = f"{' '.join(urls)} abstract fusion --iw {IMAGE_WEIGHT_VALUE}"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "abstract fusion"
    assert len(result.image_prompts) == 2
    assert [str(p) for p in result.image_prompts] == urls
    assert result.image_weight == IMAGE_WEIGHT_VALUE


def test_parameter_workflow():
    """Test workflow with various parameter types."""
    prompt = (
        "cyberpunk city --v 5.2 --style raw "
        f"--chaos {CHAOS_VALUE} --weird {WEIRD_VALUE} "
        f"--seed {SEED_VALUE} --stop {STOP_VALUE} "
        "--turbo --tile"
    )
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "cyberpunk city"
    assert result.version == "v5.2"
    assert result.style == "raw"
    assert result.chaos == CHAOS_VALUE
    assert result.weird == WEIRD_VALUE
    assert result.seed == SEED_VALUE
    assert result.stop == STOP_VALUE
    assert result.turbo is True
    assert result.tile is True


def test_new_parameters_workflow():
    """Test workflow with new parameter types."""
    prompt = (
        "portrait photo "
        f"--quality {QUALITY_VALUE} "
        f"--cw {CHARACTER_WEIGHT_VALUE} "
        f"--sw {STYLE_WEIGHT_VALUE} "
        f"--sv {STYLE_VERSION_VALUE} "
        f"--repeat {REPEAT_VALUE} "
        "--cref ref1.jpg ref2.jpg "
        "--sref style1.jpg style2.jpg "
        "--p custom_profile1 custom_profile2"
    )
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]

    assert result.text == "portrait photo"
    assert result.quality == QUALITY_VALUE
    assert result.character_weight == CHARACTER_WEIGHT_VALUE
    assert result.style_weight == STYLE_WEIGHT_VALUE
    assert result.style_version == STYLE_VERSION_VALUE
    assert result.repeat == REPEAT_VALUE
    assert result.character_reference == ["ref1.jpg", "ref2.jpg"]
    assert result.style_reference == ["style1.jpg", "style2.jpg"]
    assert result.personalization == ["custom_profile1", "custom_profile2"]


def test_weighted_prompts_workflow():
    """Test workflow with weighted prompts."""
    prompt = "cyberpunk city::2 neon lights::1"
    results = process_prompt(prompt)

    assert len(results) == 1
    result = results[0]
    assert result.text == "cyberpunk city::2 neon lights::1"


def test_error_workflow():
    """Test error handling in workflow."""
    # Test empty prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        process_prompt("")

    # Test whitespace-only prompt
    with pytest.raises(ValueError, match="Empty prompt"):
        process_prompt("   ")

    # Test invalid parameter value - raises ValueError
    with pytest.raises(ValueError, match=r"Invalid numeric value for stylize: 2000"):
        process_prompt(f"photo --stylize {STYLIZE_VALUE * 20}")

    # Test invalid image URL - treated as extra parameter
    results = process_prompt("photo --image not_a_url")
    assert len(results) == 1
    assert len(results[0].image_prompts) == 0
    assert results[0].extra_params.get("image") == "not_a_url"


def test_complex_workflow():
    """Test workflow with multiple features combined."""
    prompt = (
        "https://example.com/img1.jpg https://example.com/img2.jpg "
        "a {vintage, modern} {portrait, landscape} "
        "with {warm, cool} tones "
        f"--ar {ASPECT_WIDTH}:{ASPECT_HEIGHT} --stylize {STYLIZE_VALUE} "
        f"--chaos {CHAOS_VALUE} --v 5.2 --style raw "
        f"--quality {QUALITY_VALUE} --cw {CHARACTER_WEIGHT_VALUE} "
        "--turbo"
    )
    results = process_prompt(prompt)

    # 2x2x2 = 8 permutations
    assert len(results) == PERMUTATION_COUNT_2X2X2

    # Check common attributes
    for result in results:
        assert len(result.image_prompts) == 2
        assert result.aspect_width == ASPECT_WIDTH
        assert result.aspect_height == ASPECT_HEIGHT
        assert result.stylize == STYLIZE_VALUE
        assert result.chaos == CHAOS_VALUE
        assert result.version == "v5.2"
        assert result.style == "raw"
        assert result.quality == QUALITY_VALUE
        assert result.character_weight == CHARACTER_WEIGHT_VALUE
        assert result.turbo is True

    # Check text variations
    texts = {r.text for r in results}
    assert len(texts) == PERMUTATION_COUNT_2X2X2  # All combinations are unique


def test_permutations_with_parameters():
    """Test permutations with parameters are handled correctly."""
    prompt = "smooth edges {, --p} --s {75, 300}"
    results = process_prompt(prompt)

    assert len(results) == 4  # Should have 4 permutations

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (r.text.strip(), bool(r.personalization), r.stylize) for r in results
    }

    # Expected combinations
    expected = {
        ("smooth edges", False, 75),
        ("smooth edges", False, 300),
        ("smooth edges", True, 75),
        ("smooth edges", True, 300),
    }

    assert result_tuples == expected


def test_permutations_with_flag_parameters():
    """Test permutations with flag parameters (no value) are handled correctly."""
    prompt = "photo {, --tile} {, --turbo}"
    results = process_prompt(prompt)

    assert len(results) == 4  # Should have 4 permutations

    # Convert results to set of tuples for easier comparison
    result_tuples = {(r.text.strip(), r.tile is True, r.turbo is True) for r in results}

    # Expected combinations
    expected = {
        ("photo", False, False),
        ("photo", False, True),
        ("photo", True, False),
        ("photo", True, True),
    }

    assert result_tuples == expected


def test_permutations_with_complex_parameters():
    """Test permutations with complex parameter combinations."""
    prompt = "portrait {modern, vintage} {, --p custom} --ar {1:1, 16:9} --s 100"
    results = process_prompt(prompt)

    assert len(results) == 8  # Should have 8 permutations (2 x 2 x 2)

    # Convert results to set of tuples for easier comparison
    result_tuples = {
        (
            r.text.strip(),
            r.personalization[0]
            if isinstance(r.personalization, list)
            else r.personalization,
            f"{r.aspect_width}:{r.aspect_height}",
            r.stylize,
        )
        for r in results
    }

    expected = {
        ("portrait modern", False, "1:1", 100),
        ("portrait modern", False, "16:9", 100),
        ("portrait modern", "custom", "1:1", 100),
        ("portrait modern", "custom", "16:9", 100),
        ("portrait vintage", False, "1:1", 100),
        ("portrait vintage", False, "16:9", 100),
        ("portrait vintage", "custom", "1:1", 100),
        ("portrait vintage", "custom", "16:9", 100),
    }

    assert result_tuples == expected


def test_cli_mj_command():
    """Test Midjourney prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.mj(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["text"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_cli_fal_command():
    """Test Fal.ai prompt conversion using CLI."""
    cli = MidjargonCLI()
    prompt = "a serene landscape --ar 16:9 --stylize 100"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.fal(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, dict)
    assert data["prompt"] == "a serene landscape"
    assert data["stylize"] == 100
    assert data["aspect_ratio"] == "16:9"


def test_cli_perm_command():
    """Test permutation expansion using CLI."""
    cli = MidjargonCLI()
    prompt = "a {red, blue} bird on a {branch, rock}"
    with StringIO() as capture_stdout:
        sys.stdout = capture_stdout
        cli.perm(prompt, json_output=True)
        sys.stdout = sys.__stdout__
        data = parse_json_output(capture_stdout)
    assert isinstance(data, list)
    assert len(data) == 4
    assert "a red bird on a branch" in data
    assert "a red bird on a rock" in data
    assert "a blue bird on a branch" in data
    assert "a blue bird on a rock" in data
```

## File: tests/test_core.py (Size: 4.50 KB)

```
#!/usr/bin/env python3
# this_file: tests/test_core.py

import pytest

from midjargon import expand_midjargon_input
from midjargon.core.models import (
    MidjourneyParameters,
    MidjourneyPrompt,
)
from midjargon.core.parser import parse_midjargon_prompt
from midjargon.core.permutations import expand_permutations


def test_basic_prompt_parsing():
    """Test basic prompt parsing without parameters."""
    prompt = "a beautiful landscape"
    result = parse_midjargon_prompt(prompt)
    assert isinstance(result, MidjourneyPrompt)
    assert result.text == "a beautiful landscape"
    assert not result.image_prompts
    assert result.parameters == MidjourneyParameters()


def test_prompt_with_parameters():
    """Test prompt parsing with various parameters."""
    prompt = "a portrait --ar 16:9 --stylize 200 --chaos 50 --v 6"
    result = parse_midjargon_prompt(prompt)

    assert result.text == "a portrait"
    assert result.parameters.aspect == "16:9"
    assert result.parameters.stylize == 200
    assert result.parameters.chaos == 50
    assert result.parameters.version == "v6"


def test_prompt_with_image():
    """Test prompt parsing with image URLs."""
    prompt = "https://example.com/image.jpg a photo in this style"
    result = parse_midjargon_prompt(prompt)

    assert result.text == "a photo in this style"
    assert len(result.image_prompts) == 1
    assert str(result.image_prompts[0]) == "https://example.com/image.jpg"


def test_invalid_parameters():
    """Test handling of invalid parameters."""
    with pytest.raises(ValueError):
        parse_midjargon_prompt("test --invalid value")


def test_permutation_expansion():
    """Test permutation expansion."""
    prompt = "a {red, blue} bird on a {green, yellow} tree"
    results = expand_permutations(prompt)

    assert len(results) == 4
    assert "a red bird on a green tree" in results
    assert "a red bird on a yellow tree" in results
    assert "a blue bird on a green tree" in results
    assert "a blue bird on a yellow tree" in results


def test_escaped_permutations():
    """Test handling of escaped characters in permutations."""
    prompt = r"a {red\, orange, blue} bird"
    results = expand_permutations(prompt)

    assert len(results) == 2
    assert "a red, orange bird" in results
    assert "a blue bird" in results


def test_weighted_prompts():
    """Test handling of weighted prompts."""
    prompt = "first prompt::0.7 second prompt::0.3"
    results = expand_midjargon_input(prompt)

    assert len(results) == 2
    assert results[0].weight == 0.7
    assert results[1].weight == 0.3


def test_combined_features():
    """Test combination of multiple features."""
    prompt = "a {red, blue} bird::0.6 a {green, yellow} tree::0.4"
    results = expand_midjargon_input(prompt)

    assert len(results) == 4
    # Check first group
    red_blue = [r for r in results if "bird" in r.prompt.text]
    assert len(red_blue) == 2
    assert all("bird" in r.prompt.text for r in red_blue)
    assert all(r.weight == 0.6 for r in red_blue)

    # Check second group
    green_yellow = [r for r in results if "tree" in r.prompt.text]
    assert len(green_yellow) == 2
    assert all("tree" in r.prompt.text for r in green_yellow)
    assert all(r.weight == 0.4 for r in green_yellow)


def test_style_reference():
    """Test handling of style references."""
    # Test with code
    prompt = "test --sref p123456"
    result = parse_midjargon_prompt(prompt)
    assert result.style_reference
    assert result.style_reference[0].code == "p123456"

    # Test with URL
    prompt = "test --sref https://example.com/style.jpg"
    result = parse_midjargon_prompt(prompt)
    assert result.style_reference
    assert str(result.style_reference[0].url) == "https://example.com/style.jpg"


def test_character_reference():
    """Test handling of character references."""
    prompt = "test --cref https://example.com/char.jpg --cw 50"
    result = parse_midjargon_prompt(prompt)

    assert result.character_reference
    assert str(result.character_reference[0].url) == "https://example.com/char.jpg"
    assert result.character_weight == 50


def test_prompt_to_string():
    """Test conversion of prompt back to string format."""
    original = "a portrait --ar 16:9 --stylize 200"
    result = parse_midjargon_prompt(original)

    # Convert back to string
    output = result.to_string()

    # Parse again to verify equivalence
    reparsed = parse_midjargon_prompt(output)
    assert reparsed.text == result.text
    assert reparsed.parameters.model_dump() == result.parameters.model_dump()
```

## File: tests/test_package.py (Size: 0.18 KB)

```
# this_file: tests/test_package.py
"""Test suite for midjargon."""


def test_version():
    """Verify package exposes version."""
    import midjargon

    assert midjargon.__version__
```

## File: updateme.sh (Size: 0.45 KB)

```
#!/usr/bin/env bash
# this_file: midjargon/printme.sh
if [ -e ./midjargon.txt ]; then
    rm ./midjargon.txt
fi
if [ -z "$VIRTUAL_ENV" ]; then
    uv pip install --system gitignore-find
else
    uv pip install gitignore-find
fi
printfolder . ../midjargon.txt && mv ../midjargon.txt .

hatch run lint:style >ERRORS.txt
hatch test >>ERRORS.txt

cat midjargon.txt ERRORS.txt

echo ">> The codebase is in @midjargon.txt and the recent errors are in @ERRORS.txt"
```

